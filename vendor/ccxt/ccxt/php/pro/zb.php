<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\NotSupported;
use ccxt\AuthenticationError;
use React\Async;

class zb extends \ccxt\async\zb {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchOrderBook' => true,
                'watchTicker' => true,
                'watchTrades' => true,
                'watchOHLCV' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'spot' => 'wss://api.{hostname}/websocket',
                        'contract' => 'wss://fapi.{hostname}/ws/public/v1',
                    ),
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'ordersLimit' => 1000,
                'OHLCVLimit' => 1000,
            ),
        ));
    }

    public function watch_public($url, $messageHash, $symbol, $method, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($url, $messageHash, $symbol, $method, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $type = $market['spot'] ? 'spot' : 'contract';
            $request = null;
            $isLimitSet = $limit !== null;
            if ($type === 'spot') {
                $request = array(
                    'event' => 'addChannel',
                    'channel' => $messageHash,
                );
                if ($isLimitSet) {
                    $request['length'] = $limit;
                }
            } else {
                $request = array(
                    'action' => 'subscribe',
                    'channel' => $messageHash,
                );
                if ($isLimitSet) {
                    $request['size'] = $limit;
                }
            }
            $message = array_merge($request, $params);
            $subscription = array(
                'symbol' => $symbol,
                'messageHash' => $messageHash,
                'method' => $method,
            );
            if ($isLimitSet) {
                $subscription['limit'] = $limit;
            }
            return Async\await($this->watch($url, $messageHash, $message, $messageHash, $subscription));
        }) ();
    }

    public function watch_ticker(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = null;
            $type = $market['spot'] ? 'spot' : 'contract';
            if ($type === 'spot') {
                $messageHash = $market['baseId'] . $market['quoteId'] . '_' . 'ticker';
            } else {
                $messageHash = $market['id'] . '.' . 'Ticker';
            }
            $url = $this->implode_hostname($this->urls['api']['ws'][$type]);
            return Async\await($this->watch_public($url, $messageHash, $symbol, array($this, 'handle_ticker'), null, $params));
        }) ();
    }

    public function parse_ws_ticker($ticker, $market = null) {
        //
        // contract $ticker
        //      {
        //          data => array(
        //            38568.36, // open
        //            39958.75, // high
        //            38100, // low
        //            39211.78, // $last
        //            61695.496, // volume 24h
        //            1.67, // change
        //            1647369457, // time
        //            285916.615048
        //          )
        //    }
        //
        $timestamp = $this->safe_integer($ticker, 6);
        $last = $this->safe_string($ticker, 3);
        return $this->safe_ticker(array(
            'symbol' => $this->safe_symbol(null, $market),
            'timestamp' => $timestamp,
            'datetime' => null,
            'high' => $this->safe_string($ticker, 1),
            'low' => $this->safe_string($ticker, 2),
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => $this->safe_string($ticker, 0),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => $this->safe_string($ticker, 5),
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 4),
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function handle_ticker(Client $client, $message, $subscription) {
        //
        // spot $ticker
        //
        //     {
        //         date => '1624398991255',
        //         $ticker => array(
        //             high => '33298.38',
        //             vol => '56375.9469',
        //             last => '32396.95',
        //             low => '28808.19',
        //             buy => '32395.81',
        //             sell => '32409.3',
        //             turnover => '1771122527.0000',
        //             open => '31652.44',
        //             riseRate => '2.36'
        //         ),
        //         dataType => 'ticker',
        //         $channel => 'btcusdt_ticker'
        //     }
        //
        // contract $ticker
        //      {
        //          $channel => 'BTC_USDT.Ticker',
        //          $data => array(
        //            38568.36,
        //            39958.75,
        //            38100,
        //            39211.78,
        //            61695.496,
        //            1.67,
        //            1647369457,
        //            285916.615048
        //          )
        //      }
        //
        $symbol = $this->safe_string($subscription, 'symbol');
        $channel = $this->safe_string($message, 'channel');
        $market = $this->market($symbol);
        $data = $this->safe_value($message, 'ticker');
        $ticker = null;
        if ($data === null) {
            $data = $this->safe_value($message, 'data', array());
            $ticker = $this->parse_ws_ticker($data, $market);
        } else {
            $data['date'] = $this->safe_value($message, 'date');
            $ticker = $this->parse_ticker($data, $market);
        }
        $ticker['symbol'] = $symbol;
        $this->tickers[$symbol] = $ticker;
        $client->resolve ($ticker, $channel);
        return $message;
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if ($market['spot']) {
                throw new NotSupported($this->id . ' watchOHLCV() supports contract markets only');
            }
            if (($limit === null) || ($limit > 1440)) {
                $limit = 100;
            }
            $interval = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $messageHash = $market['id'] . '.KLine' . '_' . $interval;
            $url = $this->implode_hostname($this->urls['api']['ws']['contract']);
            $ohlcv = Async\await($this->watch_public($url, $messageHash, $symbol, array($this, 'handle_ohlcv'), $limit, $params));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message, $subscription) {
        //
        // snapshot update
        //    {
        //        $channel => 'BTC_USDT.KLine_1m',
        //        type => 'Whole',
        //        $data => array(
        //          array( 48543.77, 48543.77, 48542.82, 48542.82, 0.43, 1640227260 ),
        //          array( 48542.81, 48542.81, 48529.89, 48529.89, 1.202, 1640227320 ),
        //          array( 48529.95, 48529.99, 48529.85, 48529.9, 4.226, 1640227380 ),
        //          array( 48529.96, 48529.99, 48525.11, 48525.11, 8.858, 1640227440 ),
        //          array( 48525.05, 48525.05, 48464.17, 48476.63, 32.772, 1640227500 ),
        //          array( 48475.62, 48485.65, 48475.12, 48479.36, 20.04, 1640227560 ),
        //        )
        //    }
        // partial update
        //    {
        //        $channel => 'BTC_USDT.KLine_1m',
        //        $data => array(
        //          array( 39095.45, 45339.48, 36923.58, 39204.94, 1215304.988, 1645920000 )
        //        )
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $channel = $this->safe_string($message, 'channel', '');
        $parts = explode('_', $channel);
        $partsLength = count($parts);
        $interval = $this->safe_string($parts, $partsLength - 1);
        $timeframe = $this->find_timeframe($interval);
        $symbol = $this->safe_string($subscription, 'symbol');
        $market = $this->market($symbol);
        for ($i = 0; $i < count($data); $i++) {
            $candle = $data[$i];
            $parsed = $this->parse_ohlcv($candle, $market);
            $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
            $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol][$timeframe] = $stored;
            }
            $stored->append ($parsed);
            $client->resolve ($stored, $channel);
        }
        return $message;
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = null;
            $type = $market['spot'] ? 'spot' : 'contract';
            if ($type === 'spot') {
                $messageHash = $market['baseId'] . $market['quoteId'] . '_' . 'trades';
            } else {
                $messageHash = $market['id'] . '.' . 'Trade';
            }
            $url = $this->implode_hostname($this->urls['api']['ws'][$type]);
            $trades = Async\await($this->watch_public($url, $messageHash, $symbol, array($this, 'handle_trades'), $limit, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades(Client $client, $message, $subscription) {
        // contract $trades
        // {
        //     "channel":"BTC_USDT.Trade",
        //     "type":"Whole",
        //     "data":$array(
        //        $array(
        //           40768.07,
        //           0.01,
        //           1,
        //           1647442757
        //        ),
        //        $array(
        //           40792.22,
        //           0.334,
        //           -1,
        //           1647442765
        //        ),
        //        $array(
        //           40789.77,
        //           0.14,
        //           1,
        //           1647442766
        //        )
        //     )
        //  }
        // spot $trades
        //
        //     {
        //         $data => $array(
        //             $array( date => 1624537147, amount => '0.0357', price => '34066.11', trade_type => 'bid', $type => 'buy', tid => 1718857158 ),
        //             $array( date => 1624537147, amount => '0.0255', price => '34071.04', trade_type => 'bid', $type => 'buy', tid => 1718857159 ),
        //             $array( date => 1624537147, amount => '0.0153', price => '34071.29', trade_type => 'bid', $type => 'buy', tid => 1718857160 )
        //         ),
        //         dataType => 'trades',
        //         $channel => 'btcusdt_trades'
        //     }
        //
        $channel = $this->safe_value($message, 'channel');
        $symbol = $this->safe_string($subscription, 'symbol');
        $market = $this->market($symbol);
        $data = $this->safe_value($message, 'data');
        $type = $this->safe_string($message, 'type');
        $trades = $array();
        if ($type === 'Whole') {
            // contract $trades
            for ($i = 0; $i < count($data); $i++) {
                $trade = $data[$i];
                $parsed = $this->parse_ws_trade($trade, $market);
                $trades[] = $parsed;
            }
        } else {
            // spot $trades
            $trades = $this->parse_trades($data, $market);
        }
        $array = $this->safe_value($this->trades, $symbol);
        if ($array === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $array = new ArrayCache ($limit);
        }
        for ($i = 0; $i < count($trades); $i++) {
            $array->append ($trades[$i]);
        }
        $this->trades[$symbol] = $array;
        $client->resolve ($array, $channel);
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            if ($limit !== null) {
                if (($limit !== 5) && ($limit !== 10)) {
                    throw new ExchangeError($this->id . ' watchOrderBook $limit argument must be null, 5, or 10');
                }
            } else {
                $limit = 5; // default
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $type = $market['spot'] ? 'spot' : 'contract';
            $messageHash = null;
            $url = $this->implode_hostname($this->urls['api']['ws'][$type]);
            if ($type === 'spot') {
                $url .= '/' . $market['baseId'];
                $messageHash = $market['baseId'] . $market['quoteId'] . '_' . 'quick_depth';
            } else {
                $messageHash = $market['id'] . '.' . 'Depth';
            }
            $orderbook = Async\await($this->watch_public($url, $messageHash, $symbol, array($this, 'handle_order_book'), $limit, $params));
            return $orderbook->limit ();
        }) ();
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        //    array(
        //       40768.07, // $price
        //       0.01, // quantity
        //       1, // buy or -1 sell
        //       1647442757 // time
        //    ),
        //
        $timestamp = $this->safe_timestamp($trade, 3);
        $price = $this->safe_string($trade, 0);
        $amount = $this->safe_string($trade, 1);
        $market = $this->safe_market(null, $market);
        $sideNumber = $this->safe_integer($trade, 2);
        $side = ($sideNumber === 1) ? 'buy' : 'sell';
        return $this->safe_trade(array(
            'id' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'order' => null,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
            'info' => $trade,
        ), $market);
    }

    public function handle_order_book(Client $client, $message, $subscription) {
        // spot $snapshot
        //
        //     {
        //         lastTime => 1624524640066,
        //         dataType => 'quickDepth',
        //         $channel => 'btcusdt_quick_depth',
        //         currentPrice => 33183.79,
        //         listDown => array(
        //             array( 33166.87, 0.2331 ),
        //             array( 33166.86, 0.15 ),
        //             array( 33166.76, 0.15 ),
        //             array( 33161.02, 0.212 ),
        //             array( 33146.35, 0.6066 )
        //         ),
        //         market => 'btcusdt',
        //         listUp => array(
        //             array( 33186.88, 0.15 ),
        //             array( 33190.1, 0.15 ),
        //             array( 33193.03, 0.2518 ),
        //             array( 33195.05, 0.2031 ),
        //             array( 33199.99, 0.6066 )
        //         ),
        //         high => 34816.8,
        //         rate => '6.484',
        //         low => 32312.41,
        //         currentIsBuy => true,
        //         dayNumber => 26988.5536,
        //         totalBtc => 26988.5536,
        //         showMarket => 'btcusdt'
        //     }
        //
        // contract $snapshot
        // {
        //     $channel => 'BTC_USDT.Depth',
        //     $type => 'Whole',
        //     $data => {
        //       asks => [ [Array], [Array], [Array], [Array], [Array] ],
        //       bids => [ [Array], [Array], [Array], [Array], [Array] ],
        //       time => '1647359998198'
        //     }
        //   }
        //
        // contract deltas
        // {
        //     $channel => 'BTC_USDT.Depth',
        //     $data => {
        //       bids => [ [Array], [Array], [Array], [Array] ],
        //       asks => [ [Array], [Array], [Array] ],
        //       time => '1647360038079'
        //     }
        //  }
        //
        // For contract markets zb will:
        // 1 => send $snapshot
        // 2 => send deltas
        // 3 => repeat 1-2
        // So we have a guarentee that deltas
        // are always updated and arrive after
        // the $snapshot
        //
        $type = $this->safe_string_2($message, 'type', 'dataType');
        $channel = $this->safe_string($message, 'channel');
        $symbol = $this->safe_string($subscription, 'symbol');
        $orderbook = $this->safe_value($this->orderbooks, $symbol);
        if ($type !== null) {
            // handle $orderbook $snapshot
            $isContractSnapshot = ($type === 'Whole');
            $data = $isContractSnapshot ? $this->safe_value($message, 'data') : $message;
            $timestamp = $this->safe_integer_2($data, 'lastTime', 'time');
            $asksKey = $isContractSnapshot ? 'asks' : 'listUp';
            $bidsKey = $isContractSnapshot ? 'bids' : 'listDown';
            $snapshot = $this->parse_order_book($data, $symbol, $timestamp, $bidsKey, $asksKey);
            if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
                $defaultLimit = $this->safe_integer($this->options, 'watchOrderBookLimit', 1000);
                $limit = $this->safe_integer($subscription, 'limit', $defaultLimit);
                $orderbook = $this->order_book($snapshot, $limit);
                $this->orderbooks[$symbol] = $orderbook;
            } else {
                $orderbook = $this->orderbooks[$symbol];
                $orderbook->reset ($snapshot);
            }
            $orderbook['symbol'] = $symbol;
            $client->resolve ($orderbook, $channel);
        } else {
            $this->handle_order_book_message($client, $message, $orderbook);
            $client->resolve ($orderbook, $channel);
        }
    }

    public function handle_order_book_message(Client $client, $message, $orderbook) {
        //
        // {
        //     channel => 'BTC_USDT.Depth',
        //     $data => {
        //       $bids => [ [Array], [Array], [Array], [Array] ],
        //       $asks => [ [Array], [Array], [Array] ],
        //       time => '1647360038079'
        //     }
        //  }
        //
        $data = $this->safe_value($message, 'data', array());
        $timestamp = $this->safe_integer($data, 'time');
        $asks = $this->safe_value($data, 'asks', array());
        $bids = $this->safe_value($data, 'bids', array());
        $this->handle_deltas($orderbook['asks'], $asks);
        $this->handle_deltas($orderbook['bids'], $bids);
        $orderbook['timestamp'] = $timestamp;
        $orderbook['datetime'] = $this->iso8601($timestamp);
        return $orderbook;
    }

    public function handle_delta($bookside, $delta) {
        $price = $this->safe_float($delta, 0);
        $amount = $this->safe_float($delta, 1);
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function handle_message(Client $client, $message) {
        //
        //
        //     {
        //         no => '0',
        //         code => 1007,
        //         success => false,
        //         $channel => 'btc_usdt_ticker',
        //         $message => 'Channel is empty'
        //     }
        //
        //     {
        //         date => '1624398991255',
        //         ticker => array(
        //             high => '33298.38',
        //             vol => '56375.9469',
        //             last => '32396.95',
        //             low => '28808.19',
        //             buy => '32395.81',
        //             sell => '32409.3',
        //             turnover => '1771122527.0000',
        //             open => '31652.44',
        //             riseRate => '2.36'
        //         ),
        //         dataType => 'ticker',
        //         $channel => 'btcusdt_ticker'
        //     }
        //
        //     {
        //         data => array(
        //             array( date => 1624537147, amount => '0.0357', price => '34066.11', trade_type => 'bid', type => 'buy', tid => 1718857158 ),
        //             array( date => 1624537147, amount => '0.0255', price => '34071.04', trade_type => 'bid', type => 'buy', tid => 1718857159 ),
        //             array( date => 1624537147, amount => '0.0153', price => '34071.29', trade_type => 'bid', type => 'buy', tid => 1718857160 )
        //         ),
        //         dataType => 'trades',
        //         $channel => 'btcusdt_trades'
        //     }
        //
        // contract snapshot
        //
        // {
        //     $channel => 'BTC_USDT.Depth',
        //     type => 'Whole',
        //     data => {
        //       asks => [ [Array], [Array], [Array], [Array], [Array] ],
        //       bids => [ [Array], [Array], [Array], [Array], [Array] ],
        //       time => '1647359998198'
        //     }
        //   }
        //
        // contract deltas update
        // {
        //     $channel => 'BTC_USDT.Depth',
        //     data => {
        //       bids => [ [Array], [Array], [Array], [Array] ],
        //       asks => [ [Array], [Array], [Array] ],
        //       time => '1647360038079'
        //     }
        //   }
        //
        $channel = $this->safe_string($message, 'channel');
        $subscription = $this->safe_value($client->subscriptions, $channel);
        if ($subscription !== null) {
            $method = $this->safe_value($subscription, 'method');
            if ($method !== null) {
                return $method($client, $message, $subscription);
            }
        }
        return $message;
    }

    public function handle_error_message(Client $client, $message) {
        //
        // array( $errorCode => 10020, errorMsg => "action param can't be empty" )
        // array( $errorCode => 10015, errorMsg => '无效的签名(1002)' )
        //
        $errorCode = $this->safe_string($message, 'errorCode');
        try {
            if ($errorCode !== null) {
                $feedback = $this->id . ' ' . $this->json($message);
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
                $messageString = $this->safe_value($message, 'message');
                if ($messageString !== null) {
                    $this->throw_broadly_matched_exception($this->exceptions['broad'], $messageString, $feedback);
                }
            }
        } catch (Exception $e) {
            if ($e instanceof AuthenticationError) {
                $client->reject ($e, 'authenticated');
                $method = 'login';
                if (is_array($client->subscriptions) && array_key_exists($method, $client->subscriptions)) {
                    unset($client->subscriptions[$method]);
                }
                return false;
            }
        }
        return $message;
    }
}
