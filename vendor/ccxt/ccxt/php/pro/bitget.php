<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ArgumentsRequired;
use ccxt\NotSupported;
use ccxt\InvalidNonce;
use ccxt\AuthenticationError;
use ccxt\Precise;
use React\Async;

class bitget extends \ccxt\async\bitget {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchTrades' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://ws.bitget.com/spot/v1/stream',
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'OHLCVLimit' => 1000,
                // WS timeframes differ from REST timeframes
                'timeframes' => array(
                    '1m' => '1m',
                    '5m' => '5m',
                    '15m' => '15m',
                    '30m' => '30m',
                    '1h' => '1H',
                    '4h' => '4H',
                    '6h' => '6H',
                    '12h' => '12H',
                    '1d' => '1D',
                    '1w' => '1W',
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        '30001' => '\\ccxt\\BadRequest', // array("event":"error","code":30001,"msg":"instType:sp,channel:candlenull,instId:BTCUSDT doesn't exist")
                        '30015' => '\\ccxt\\AuthenticationError', // array( event => 'error', code => 30015, msg => 'Invalid sign' )
                    ),
                ),
            ),
        ));
    }

    public function get_ws_market_id($market) {
        // WS don't use the same 'id'
        // rest version
        $sandboxMode = $this->safe_value($this->options, 'sandboxMode', false);
        if ($market['spot']) {
            return $market['info']['symbolName'];
        } else {
            if (!$sandboxMode) {
                return str_replace('_UMCBL', '', $market['id']);
            } else {
                return str_replace('_SUMCBL', '', $market['id']);
            }
        }
    }

    public function get_market_id_from_arg($arg) {
        //
        // array( $arg => { $instType => 'sp', channel => 'ticker', instId => 'BTCUSDT' )
        //
        $instType = $this->safe_string($arg, 'instType');
        $sandboxMode = $this->safe_value($this->options, 'sandboxMode', false);
        $marketId = $this->safe_string($arg, 'instId');
        if ($instType === 'sp') {
            $marketId .= '_SPBL';
        } else {
            if (!$sandboxMode) {
                $marketId .= '_UMCBL';
            } else {
                $marketId .= '_SUMCBL';
            }
        }
        return $marketId;
    }

    public function watch_ticker(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} $params extra parameters specific to the bitget api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $messageHash = 'ticker:' . $symbol;
            $instType = $market['spot'] ? 'sp' : 'mc';
            $args = array(
                'instType' => $instType,
                'channel' => 'ticker',
                'instId' => $this->get_ws_market_id($market),
            );
            return Async\await($this->watch_public($messageHash, $args, $params));
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        //   {
        //       action => 'snapshot',
        //       arg => array( instType => 'sp', channel => 'ticker', instId => 'BTCUSDT' ),
        //       data => array(
        //         {
        //           instId => 'BTCUSDT',
        //           last => '21150.53',
        //           open24h => '20759.65',
        //           high24h => '21202.29',
        //           low24h => '20518.82',
        //           bestBid => '21150.500000',
        //           bestAsk => '21150.600000',
        //           baseVolume => '25402.1961',
        //           quoteVolume => '530452554.2156',
        //           ts => 1656408934044,
        //           labeId => 0
        //         }
        //       )
        //   }
        //
        $ticker = $this->parse_ws_ticker($message);
        $symbol = $ticker['symbol'];
        $this->tickers[$symbol] = $ticker;
        $messageHash = 'ticker:' . $symbol;
        $client->resolve ($ticker, $messageHash);
        return $message;
    }

    public function parse_ws_ticker($message, $market = null) {
        //
        // spot
        //     {
        //         action => 'snapshot',
        //         $arg => array( instType => 'sp', channel => 'ticker', instId => 'BTCUSDT' ),
        //         $data => array(
        //           {
        //             instId => 'BTCUSDT',
        //             last => '21150.53',
        //             open24h => '20759.65',
        //             high24h => '21202.29',
        //             low24h => '20518.82',
        //             bestBid => '21150.500000',
        //             bestAsk => '21150.600000',
        //             $baseVolume => '25402.1961',
        //             $quoteVolume => '530452554.2156',
        //             ts => 1656408934044,
        //             labeId => 0
        //           }
        //         )
        //     }
        //
        // contract
        //
        //     {
        //         "action":"snapshot",
        //         "arg":array(
        //            "instType":"mc",
        //            "channel":"ticker",
        //            "instId":"LTCUSDT"
        //         ),
        //         "data":array(
        //            {
        //               "instId":"LTCUSDT",
        //               "last":"52.77",
        //               "bestAsk":"52.78",
        //               "bestBid":"52.75",
        //               "high24h":"54.83",
        //               "low24h":"51.32",
        //               "priceChangePercent":"-0.02",
        //               "capitalRate":"-0.000100",
        //               "nextSettleTime":1656514800000,
        //               "systemTime":1656513146169,
        //               "markPrice":"52.77",
        //               "indexPrice":"52.80",
        //               "holding":"269813.9",
        //               "baseVolume":"75422.0",
        //               "quoteVolume":"3986579.8"
        //            }
        //         )
        //     }
        //
        $arg = $this->safe_value($message, 'arg', array());
        $data = $this->safe_value($message, 'data', array());
        $ticker = $this->safe_value($data, 0, array());
        $timestamp = $this->safe_integer_2($ticker, 'ts', 'systemTime');
        $marketId = $this->get_market_id_from_arg($arg);
        $market = $this->safe_market($marketId, $market);
        $close = $this->safe_string($ticker, 'last');
        $open = $this->safe_string($ticker, 'open24h');
        $high = $this->safe_string($ticker, 'high24h');
        $low = $this->safe_string($ticker, 'low24h');
        $baseVolume = $this->safe_string($ticker, 'baseVolume');
        $quoteVolume = $this->safe_string($ticker, 'quoteVolume');
        $bid = $this->safe_string($ticker, 'bestBid');
        $ask = $this->safe_string($ticker, 'bestAsk');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => $bid,
            'bidVolume' => null,
            'ask' => $ask,
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $close,
            'last' => $close,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the bitget api endpoint
             * @return {[[int]]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $timeframes = $this->safe_value($this->options, 'timeframes');
            $interval = $this->safe_string($timeframes, $timeframe);
            $messageHash = 'candles:' . $timeframe . ':' . $symbol;
            $instType = $market['spot'] ? 'sp' : 'mc';
            $args = array(
                'instType' => $instType,
                'channel' => 'candle' . $interval,
                'instId' => $this->get_ws_market_id($market),
            );
            $ohlcv = Async\await($this->watch_public($messageHash, $args, $params));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        //   {
        //       "action":"snapshot",
        //       "arg":array(
        //          "instType":"sp",
        //          "channel":"candle1W",
        //          "instId":"BTCUSDT"
        //       ),
        //       "data":array(
        //          array(
        //             "1595779200000",
        //             "9960.05",
        //             "12099.95",
        //             "9839.7",
        //             "11088.68",
        //             "462484.9738"
        //          ),
        //          array(
        //             "1596384000000",
        //             "11088.68",
        //             "11909.89",
        //             "10937.54",
        //             "11571.88",
        //             "547596.6484"
        //          )
        //       )
        //   }
        //
        $arg = $this->safe_value($message, 'arg', array());
        $marketId = $this->get_market_id_from_arg($arg);
        $channel = $this->safe_string($arg, 'channel');
        $interval = str_replace('candle', '', $channel);
        $timeframes = $this->safe_value($this->options, 'timeframes');
        $timeframe = $this->find_timeframe($interval, $timeframes);
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        $data = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $parsed = $this->parse_ws_ohlcv($data[$i]);
            $stored->append ($parsed);
        }
        $messageHash = 'candles:' . $timeframe . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_ohlcv($ohlcv, $market = null) {
        //
        //   array(
        //      "1595779200000", // timestamp
        //      "9960.05", // open
        //      "12099.95", // high
        //      "9839.7", // low
        //      "11088.68", // close
        //      "462484.9738" // volume
        //   )
        //
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the bitget api endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $messageHash = 'orderbook' . ':' . $symbol;
            $instType = $market['spot'] ? 'sp' : 'mc';
            $channel = 'books';
            $incrementalFeed = true;
            if (($limit === 5) || ($limit === 15)) {
                $channel .= (string) $limit;
                $incrementalFeed = false;
            }
            $args = array(
                'instType' => $instType,
                'channel' => $channel,
                'instId' => $this->get_ws_market_id($market),
            );
            $orderbook = Async\await($this->watch_public($messageHash, $args, $params));
            if ($incrementalFeed) {
                return $orderbook->limit ();
            } else {
                return $orderbook;
            }
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        //   {
        //       "action":"snapshot",
        //       "arg":array(
        //          "instType":"sp",
        //          "channel":"books5",
        //          "instId":"BTCUSDT"
        //       ),
        //       "data":[
        //          {
        //             "asks":[
        //                ["21041.11","0.0445"],
        //                ["21041.16","0.0411"],
        //                ["21041.21","0.0421"],
        //                ["21041.26","0.0811"],
        //                ["21041.65","1.9465"]
        //             ],
        //             "bids":[
        //                ["21040.76","0.0417"],
        //                ["21040.71","0.0434"],
        //                ["21040.66","0.1141"],
        //                ["21040.61","0.3004"],
        //                ["21040.60","1.3357"]
        //             ],
        //             "ts":"1656413855484"
        //          }
        //       ]
        //   }
        //
        $arg = $this->safe_value($message, 'arg');
        $channel = $this->safe_string($arg, 'channel');
        $marketId = $this->get_market_id_from_arg($arg);
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $messageHash = 'orderbook:' . $symbol;
        $data = $this->safe_value($message, 'data');
        $rawOrderBook = $this->safe_value($data, 0);
        $timestamp = $this->safe_integer($rawOrderBook, 'ts');
        $incrementalBook = $channel === 'books';
        $storedOrderBook = null;
        if ($incrementalBook) {
            $storedOrderBook = $this->safe_value($this->orderbooks, $symbol);
            if ($storedOrderBook === null) {
                $storedOrderBook = $this->counted_order_book(array());
            }
            $asks = $this->safe_value($rawOrderBook, 'asks', array());
            $bids = $this->safe_value($rawOrderBook, 'bids', array());
            $this->handle_deltas($storedOrderBook['asks'], $asks);
            $this->handle_deltas($storedOrderBook['bids'], $bids);
            $storedOrderBook['timestamp'] = $timestamp;
            $storedOrderBook['datetime'] = $this->iso8601($timestamp);
            $checksum = $this->safe_value($this->options, 'checksum', true);
            if ($checksum) {
                $storedAsks = $storedOrderBook['asks'];
                $storedBids = $storedOrderBook['bids'];
                $asksLength = count($storedAsks);
                $bidsLength = count($storedBids);
                $payloadArray = array();
                for ($i = 0; $i < 25; $i++) {
                    if ($i < $bidsLength) {
                        $payloadArray[] = $storedBids[$i][2][0];
                        $payloadArray[] = $storedBids[$i][2][1];
                    }
                    if ($i < $asksLength) {
                        $payloadArray[] = $storedAsks[$i][2][0];
                        $payloadArray[] = $storedAsks[$i][2][1];
                    }
                }
                $payload = implode(':', $payloadArray);
                $calculatedChecksum = $this->crc32($payload, true);
                $responseChecksum = $this->safe_integer($rawOrderBook, 'checksum');
                if ($calculatedChecksum !== $responseChecksum) {
                    $error = new InvalidNonce ($this->id . ' invalid checksum');
                    $client->reject ($error, $messageHash);
                }
            }
        } else {
            $storedOrderBook = $this->parse_order_book($rawOrderBook, $symbol, $timestamp);
        }
        $this->orderbooks[$symbol] = $storedOrderBook;
        $client->resolve ($storedOrderBook, $messageHash);
    }

    public function handle_delta($bookside, $delta) {
        $bidAsk = $this->parse_bid_ask($delta, 0, 1);
        // we store the string representations in the orderbook for checksum calculation
        // this simplifies the code for generating checksums do not need to do any complex number transformations
        $bidAsk[] = $delta;
        $bookside->storeArray ($bidAsk);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the bitget api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $messageHash = 'trade:' . $symbol;
            $instType = $market['spot'] ? 'sp' : 'mc';
            $args = array(
                'instType' => $instType,
                'channel' => 'trade',
                'instId' => $this->get_ws_market_id($market),
            );
            $trades = Async\await($this->watch_public($messageHash, $args, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        //    {
        //        action => 'snapshot',
        //        $arg => array( instType => 'sp', channel => 'trade', instId => 'BTCUSDT' ),
        //        $data => array(
        //          array( '1656411148032', '21047.78', '2.2294', 'buy' ),
        //          array( '1656411142030', '21047.85', '2.1225', 'buy' ),
        //          array( '1656411133064', '21045.88', '1.7704', 'sell' ),
        //          array( '1656411126037', '21052.39', '2.6905', 'buy' ),
        //          array( '1656411118029', '21056.87', '1.2308', 'sell' ),
        //          array( '1656411108028', '21060.01', '1.7186', 'sell' ),
        //          array( '1656411100027', '21060.4', '1.3641', 'buy' ),
        //          array( '1656411093030', '21058.76', '1.5049', 'sell' )
        //        )
        //    }
        //
        $arg = $this->safe_value($message, 'arg', array());
        $marketId = $this->get_market_id_from_arg($arg);
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $data = $this->safe_value($message, 'data', array());
        for ($j = 0; $j < count($data); $j++) {
            $rawTrade = $data[$j];
            $parsed = $this->parse_ws_trade($rawTrade, $market);
            $stored->append ($parsed);
        }
        $messageHash = 'trade:' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        // public $trade
        //
        //   array(
        //       '1656411148032', // $timestamp
        //       '21047.78', // $price
        //       '2.2294', // size
        //       'buy', // $side
        //   )
        //
        $market = $this->safe_market(null, $market);
        $timestamp = $this->safe_integer($trade, 0);
        $side = $this->safe_string($trade, 3);
        $price = $this->safe_string($trade, 1);
        $amount = $this->safe_string($trade, 2);
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => null,
            'order' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'type' => null,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bitget api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            Async\await($this->load_markets());
            $market = null;
            $marketId = null;
            $messageHash = 'order';
            $subscriptionHash = 'order:trades';
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $marketId = $market['id'];
                $messageHash = $messageHash . ':' . $symbol;
            }
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            if (($type === 'spot') && ($symbol === null)) {
                throw new ArgumentsRequired($this->id . ' watchOrders requires a $symbol argument for ' . $type . ' markets.');
            }
            $sandboxMode = $this->safe_value($this->options, 'sandboxMode', false);
            $instType = null;
            if ($type === 'spot') {
                $instType = 'spbl';
            } else {
                if (!$sandboxMode) {
                    $instType = 'UMCBL';
                } else {
                    $instType = 'SUMCBL';
                }
            }
            $instId = ($type === 'spot') ? $marketId : 'default'; // different from other streams here the 'rest' id is required for spot markets, contract markets require default here
            $args = array(
                'instType' => $instType,
                'channel' => 'orders',
                'instId' => $instId,
            );
            $orders = Async\await($this->watch_private($messageHash, $subscriptionHash, $args, $params));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_order(Client $client, $message, $subscription = null) {
        //
        //
        // spot $order
        //    {
        //        action => 'snapshot',
        //        $arg => array( $instType => 'spbl', channel => 'orders', instId => 'LTCUSDT_SPBL' // instId='default' for contracts ),
        //        $data => array(
        //          {
        //            instId => 'LTCUSDT_SPBL',
        //            ordId => '925999649898545152',
        //            clOrdId => '8b2aa69a-6a09-46c0-a50d-7ed50277394c',
        //            px => '20.00',
        //            sz => '0.3000',
        //            notional => '6.000000',
        //            ordType => 'limit',
        //            force => 'normal',
        //            side => 'buy',
        //            accFillSz => '0.0000',
        //            avgPx => '0.00',
        //            status => 'new',
        //            cTime => 1656501441454,
        //            uTime => 1656501441454,
        //            orderFee => array()
        //          }
        //        )
        //    }
        //
        $arg = $this->safe_value($message, 'arg', array());
        $instType = $this->safe_string($arg, 'instType');
        $sandboxMode = $this->safe_value($this->options, 'sandboxMode', false);
        $isContractUpdate = (!$sandboxMode) ? ($instType === 'umcbl') : ($instType === 'sumcbl');
        $data = $this->safe_value($message, 'data', array());
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $stored = $this->orders;
        $marketSymbols = array();
        for ($i = 0; $i < count($data); $i++) {
            $order = $data[$i];
            $execType = $this->safe_string($order, 'execType');
            if (($execType === 'T') && $isContractUpdate) {
                // partial $order updates have the trade info inside
                $this->handle_my_trades($client, $order);
            }
            $parsed = $this->parse_ws_order($order);
            $stored->append ($parsed);
            $symbol = $parsed['symbol'];
            $marketSymbols[$symbol] = true;
        }
        $keys = is_array($marketSymbols) ? array_keys($marketSymbols) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $symbol = $keys[$i];
            $messageHash = 'order:' . $symbol;
            $client->resolve ($stored, $messageHash);
        }
        $client->resolve ($stored, 'order');
    }

    public function parse_ws_order($order, $market = null) {
        //
        // spot $order
        //     {
        //         instId => 'LTCUSDT_SPBL',
        //         ordId => '925999649898545152',
        //         clOrdId => '8b2aa69a-6a09-46c0-a50d-7ed50277394c',
        //         px => '20.00',
        //         sz => '0.3000',
        //         notional => '6.000000',
        //         ordType => 'limit',
        //         force => 'normal',
        //         $side => 'buy',
        //         accFillSz => '0.0000',
        //         avgPx => '0.00',
        //         $status => 'new',
        //         cTime => 1656501441454,
        //         uTime => 1656501441454,
        //         $orderFee => array()
        //     }
        // partial fill
        //
        //    {
        //        instId => 'LTCUSDT_SPBL',
        //        ordId => '926006174213914625',
        //        clOrdId => '7ce28714-0016-46d0-a971-9a713a9923c5',
        //        notional => '5.000000',
        //        ordType => 'market',
        //        force => 'normal',
        //        $side => 'buy',
        //        fillPx => '52.11',
        //        tradeId => '926006174514073601',
        //        fillSz => '0.0959',
        //        fillTime => '1656502997043',
        //        fillFee => '-0.0000959',
        //        fillFeeCcy => 'LTC',
        //        execType => 'T',
        //        accFillSz => '0.0959',
        //        avgPx => '52.11',
        //        $status => 'partial-fill',
        //        cTime => 1656502996972,
        //        uTime => 1656502997119,
        //        $orderFee => [Array]
        //    }
        //
        // contract $order
        //    {
        //        accFillSz => '0',
        //        cTime => 1656510642518,
        //        clOrdId => '926038241960431617',
        //        force => 'normal',
        //        instId => 'LTCUSDT_UMCBL',
        //        lever => '20',
        //        notionalUsd => '7.5',
        //        ordId => '926038241859768320',
        //        ordType => 'limit',
        //        $orderFee => array(
        //             array(feeCcy => 'USDT', $fee => '0')
        //        )
        //        posSide => 'long',
        //        px => '25',
        //        $side => 'buy',
        //        $status => 'new',
        //        sz => '0.3',
        //        tdMode => 'cross',
        //        tgtCcy => 'USDT',
        //        uTime => 1656510642518
        //    }
        //
        $marketId = $this->safe_string($order, 'instId');
        $market = $this->safe_market($marketId, $market);
        $id = $this->safe_string($order, 'ordId');
        $clientOrderId = $this->safe_string($order, 'clOrdId');
        $price = $this->safe_string($order, 'px');
        $filled = $this->safe_string($order, 'fillSz');
        $amount = $this->safe_string($order, 'sz');
        $cost = $this->safe_string_2($order, 'notional', 'notionalUsd');
        $average = $this->omit_zero($this->safe_string($order, 'avgPx'));
        $type = $this->safe_string($order, 'ordType');
        $timestamp = $this->safe_integer($order, 'cTime');
        $symbol = $market['symbol'];
        $side = $this->safe_string_2($order, 'side', 'posSide');
        if (($side === 'open_long') || ($side === 'close_short')) {
            $side = 'buy';
        } elseif (($side === 'close_long') || ($side === 'open_short')) {
            $side = 'sell';
        }
        $rawStatus = $this->safe_string($order, 'status', 'state');
        $timeInForce = $this->safe_string($order, 'force');
        $status = $this->parse_ws_order_status($rawStatus);
        $orderFee = $this->safe_value($order, 'orderFee', array());
        $fee = $this->safe_value($orderFee, 0);
        $feeAmount = $this->safe_string($fee, 'fee');
        $feeObject = null;
        if ($feeAmount !== null) {
            $feeCurrency = $this->safe_string($fee, 'feeCcy');
            $feeObject = array(
                'cost' => Precise::string_abs($feeAmount),
                'currency' => $this->safe_currency_code($feeCurrency),
            );
        }
        return $this->safe_order(array(
            'info' => $order,
            'symbol' => $symbol,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'triggerPrice' => null,
            'amount' => $amount,
            'cost' => $cost,
            'average' => $average,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $feeObject,
            'trades' => null,
        ), $market);
    }

    public function parse_ws_order_status($status) {
        $statuses = array(
            'new' => 'open',
            'partial-fill' => 'open',
            'full-fill' => 'closed',
            'filled' => 'closed',
            'cancelled' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches $trades made by the user
             * @param {str|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch $trades for
             * @param {int|null} $limit the maximum number of $trades structures to retrieve
             * @param {array} $params extra parameters specific to the bitget api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            // only contracts stream provides the trade info consistently in between order updates
            // the spot stream only provides on $limit orders updates so we can't support it for spot
            Async\await($this->load_markets());
            $market = null;
            $messageHash = 'myTrades';
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash = $messageHash . ':' . $symbol;
            }
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchMyTrades', $market, $params);
            if ($type === 'spot') {
                throw new NotSupported($this->id . ' watchMyTrades is not supported for ' . $type . ' markets.');
            }
            $sandboxMode = $this->safe_value($this->options, 'sandboxMode', false);
            $subscriptionHash = 'order:trades';
            $args = array(
                'instType' => (!$sandboxMode) ? 'umcbl' : 'sumcbl',
                'channel' => 'orders',
                'instId' => 'default',
            );
            $trades = Async\await($this->watch_private($messageHash, $subscriptionHash, $args, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_my_trades(Client $client, $message) {
        //
        // order and trade mixin (contract)
        //
        //   {
        //       accFillSz => '0.1',
        //       avgPx => '52.81',
        //       cTime => 1656511777208,
        //       clOrdId => '926043001195237376',
        //       execType => 'T',
        //       fillFee => '-0.0031686',
        //       fillFeeCcy => 'USDT',
        //       fillNotionalUsd => '5.281',
        //       fillPx => '52.81',
        //       fillSz => '0.1',
        //       fillTime => '1656511777266',
        //       force => 'normal',
        //       instId => 'LTCUSDT_UMCBL',
        //       lever => '1',
        //       notionalUsd => '5.281',
        //       ordId => '926043001132322816',
        //       ordType => 'market',
        //       orderFee => [Array],
        //       pnl => '0.004',
        //       posSide => 'long',
        //       px => '0',
        //       side => 'sell',
        //       status => 'full-fill',
        //       sz => '0.1',
        //       tdMode => 'cross',
        //       tgtCcy => 'USDT',
        //       tradeId => '926043001438552105',
        //       uTime => 1656511777266
        //   }
        //
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCache ($limit);
        }
        $stored = $this->myTrades;
        $parsed = $this->parse_ws_my_trade($message);
        $stored->append ($parsed);
        $symbol = $parsed['symbol'];
        $messageHash = 'myTrades';
        $client->resolve ($stored, $messageHash);
        $symbolSpecificMessageHash = 'myTrades:' . $symbol;
        $client->resolve ($stored, $symbolSpecificMessageHash);
    }

    public function parse_ws_my_trade($trade, $market = null) {
        //
        // order and $trade mixin (contract)
        //
        //   {
        //       accFillSz => '0.1',
        //       avgPx => '52.81',
        //       cTime => 1656511777208,
        //       clOrdId => '926043001195237376',
        //       execType => 'T',
        //       fillFee => '-0.0031686',
        //       fillFeeCcy => 'USDT',
        //       fillNotionalUsd => '5.281',
        //       fillPx => '52.81',
        //       fillSz => '0.1',
        //       fillTime => '1656511777266',
        //       force => 'normal',
        //       instId => 'LTCUSDT_UMCBL',
        //       lever => '1',
        //       notionalUsd => '5.281',
        //       ordId => '926043001132322816',
        //       ordType => 'market',
        //       orderFee => [Array],
        //       pnl => '0.004',
        //       posSide => 'long',
        //       px => '0',
        //       $side => 'sell',
        //       status => 'full-fill',
        //       sz => '0.1',
        //       tdMode => 'cross',
        //       tgtCcy => 'USDT',
        //       tradeId => '926043001438552105',
        //       uTime => 1656511777266
        //   }
        //
        $id = $this->safe_string($trade, 'tradeId');
        $orderId = $this->safe_string($trade, 'ordId');
        $marketId = $this->safe_string($trade, 'instId');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer($trade, 'fillTime');
        $side = $this->safe_string($trade, 'side');
        $price = $this->safe_string($trade, 'fillPx');
        $amount = $this->safe_string($trade, 'fillSz');
        $type = $this->safe_string($trade, 'ordType');
        $cost = $this->safe_string($trade, 'notional');
        $feeCurrency = $this->safe_string($trade, 'fillFeeCcy');
        $feeAmount = Precise::string_abs($this->safe_string($trade, 'fillFee'));
        $fee = array(
            'code' => $this->safe_currency_code($feeCurrency),
            'cost' => $feeAmount,
        );
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        ), $market);
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the bitget api endpoint
             * @param {str|null} $params->type spot or contract if not provided $this->options['defaultType'] is used
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchOrders', null, $params);
            $sandboxMode = $this->safe_value($this->options, 'sandboxMode', false);
            $instType = 'spbl';
            if ($type === 'swap') {
                $instType = 'UMCBL';
                if ($sandboxMode) {
                    $instType = 'S' . $instType;
                }
            }
            $args = array(
                'instType' => $instType,
                'channel' => 'account',
                'instId' => 'default',
            );
            $messageHash = 'balance:' . strtolower($instType);
            return Async\await($this->watch_private($messageHash, $messageHash, $args, $params));
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        // spot
        //
        //    {
        //        action => 'snapshot',
        //        $arg => array( $instType => 'spbl', channel => 'account', instId => 'default' ),
        //        $data => array(
        //          array( coinId => '5', coinName => 'LTC', available => '0.1060938000000000' ),
        //          array( coinId => '2', coinName => 'USDT', available => '13.4498240000000000' )
        //        )
        //    }
        //
        // swap
        //    {
        //      "action" => "snapshot",
        //      "arg" => array(
        //        "instType" => "umcbl",
        //        "channel" => "account",
        //        "instId" => "default"
        //      ),
        //      "data" => array(
        //        {
        //          "marginCoin" => "USDT",
        //          "locked" => "0.00000000",
        //          "available" => "3384.58046492",
        //          "maxOpenPosAvailable" => "3384.58046492",
        //          "maxTransferOut" => "3384.58046492",
        //          "equity" => "3384.58046492",
        //          "usdtEquity" => "3384.580464925690"
        //        }
        //      )
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $rawBalance = $data[$i];
            $currencyId = $this->safe_string_2($rawBalance, 'coinName', 'marginCoin');
            $code = $this->safe_currency_code($currencyId);
            $account = (is_array($this->balance) && array_key_exists($code, $this->balance)) ? $this->balance[$code] : $this->account();
            $account['free'] = $this->safe_string($rawBalance, 'available');
            $account['total'] = $this->safe_string($rawBalance, 'equity');
            $this->balance[$code] = $account;
        }
        $this->balance = $this->safe_balance($this->balance);
        $arg = $this->safe_value($message, 'arg');
        $instType = $this->safe_string_lower($arg, 'instType');
        $messageHash = 'balance:' . $instType;
        $client->resolve ($this->balance, $messageHash);
    }

    public function watch_public($messageHash, $args, $params = array ()) {
        return Async\async(function () use ($messageHash, $args, $params) {
            $url = $this->urls['api']['ws'];
            $request = array(
                'op' => 'subscribe',
                'args' => array( $args ),
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }

    public function authenticate($params = array ()) {
        $this->check_required_credentials();
        $url = $this->urls['api']['ws'];
        $client = $this->client($url);
        $messageHash = 'authenticated';
        $future = $this->safe_value($client->subscriptions, $messageHash);
        if ($future === null) {
            $timestamp = (string) $this->seconds();
            $auth = $timestamp . 'GET' . '/user/verify';
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256', 'base64');
            $operation = 'login';
            $request = array(
                'op' => $operation,
                'args' => array(
                    array(
                        'apiKey' => $this->apiKey,
                        'passphrase' => $this->password,
                        'timestamp' => $timestamp,
                        'sign' => $signature,
                    ),
                ),
            );
            $message = array_merge($request, $params);
            $future = $this->watch($url, $messageHash, $message);
            $client->subscriptions[$messageHash] = $future;
        }
        return $future;
    }

    public function watch_private($messageHash, $subscriptionHash, $args, $params = array ()) {
        return Async\async(function () use ($messageHash, $subscriptionHash, $args, $params) {
            Async\await($this->authenticate());
            $url = $this->urls['api']['ws'];
            $request = array(
                'op' => 'subscribe',
                'args' => array( $args ),
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $subscriptionHash));
        }) ();
    }

    public function handle_authenticate(Client $client, $message) {
        //
        //  array( event => 'login', code => 0 )
        //
        $messageHash = 'authenticated';
        $client->resolve ($message, $messageHash);
    }

    public function handle_error_message(Client $client, $message) {
        //
        //    array( $event => 'error', $code => 30015, msg => 'Invalid sign' )
        //
        $event = $this->safe_string($message, 'event');
        try {
            if ($event === 'error') {
                $code = $this->safe_string($message, 'code');
                $feedback = $this->id . ' ' . $this->json($message);
                $this->throw_exactly_matched_exception($this->exceptions['ws']['exact'], $code, $feedback);
            }
            return false;
        } catch (Exception $e) {
            if ($e instanceof AuthenticationError) {
                $messageHash = 'authenticated';
                $client->reject ($e, $messageHash);
                if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                    unset($client->subscriptions[$messageHash]);
                }
            }
            return true;
        }
    }

    public function handle_message(Client $client, $message) {
        //
        //   {
        //       action => 'snapshot',
        //       $arg => array( instType => 'sp', channel => 'ticker', instId => 'BTCUSDT' ),
        //       data => array(
        //         {
        //           instId => 'BTCUSDT',
        //           last => '21150.53',
        //           open24h => '20759.65',
        //           high24h => '21202.29',
        //           low24h => '20518.82',
        //           bestBid => '21150.500000',
        //           bestAsk => '21150.600000',
        //           baseVolume => '25402.1961',
        //           quoteVolume => '530452554.2156',
        //           ts => 1656408934044,
        //           labeId => 0
        //         }
        //       )
        //   }
        // pong $message
        //    'pong'
        //
        // login
        //
        //     array( $event => 'login', code => 0 )
        //
        // subscribe
        //
        //    {
        //        $event => 'subscribe',
        //        $arg => array( instType => 'spbl', channel => 'account', instId => 'default' )
        //    }
        //
        if ($this->handle_error_message($client, $message)) {
            return;
        }
        $content = $this->safe_string($message, 'message');
        if ($content === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        if ($message === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        $event = $this->safe_string($message, 'event');
        if ($event === 'login') {
            $this->handle_authenticate($client, $message);
            return;
        }
        if ($event === 'subscribe') {
            $this->handle_subscription_status($client, $message);
            return;
        }
        $methods = array(
            'ticker' => array($this, 'handle_ticker'),
            'trade' => array($this, 'handle_trades'),
            'orders' => array($this, 'handle_order'),
            'account' => array($this, 'handle_balance'),
        );
        $arg = $this->safe_value($message, 'arg', array());
        $topic = $this->safe_value($arg, 'channel', '');
        $method = $this->safe_value($methods, $topic);
        if ($method !== null) {
            $method($client, $message);
        }
        if (mb_strpos($topic, 'candle') !== false) {
            $this->handle_ohlcv($client, $message);
        }
        if (mb_strpos($topic, 'books') !== false) {
            $this->handle_order_book($client, $message);
        }
    }

    public function ping($client) {
        return 'ping';
    }

    public function handle_pong(Client $client, $message) {
        $client->lastPong = $this->milliseconds();
        return $message;
    }

    public function handle_subscription_status(Client $client, $message) {
        //
        //    {
        //        event => 'subscribe',
        //        arg => array( instType => 'spbl', channel => 'account', instId => 'default' )
        //    }
        //
        return $message;
    }
}
