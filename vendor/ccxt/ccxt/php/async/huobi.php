<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\huobi as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\BadRequest;
use ccxt\BadSymbol;
use ccxt\InvalidOrder;
use ccxt\NotSupported;
use ccxt\NetworkError;
use ccxt\Precise;
use React\Async;
use React\Promise;

class huobi extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'huobi',
            'name' => 'Huobi',
            'countries' => array( 'CN' ),
            'rateLimit' => 100,
            'userAgent' => $this->userAgents['chrome100'],
            'certified' => true,
            'version' => 'v1',
            'hostname' => 'api.huobi.pro', // api.testnet.huobi.pro
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => true,
                'swap' => true,
                'future' => true,
                'option' => null,
                'addMargin' => null,
                'borrowMargin' => true,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'createDepositAddress' => null,
                'createOrder' => true,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => true,
                'createStopMarketOrder' => true,
                'createStopOrder' => true,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => null,
                'fetchBorrowInterest' => true,
                'fetchBorrowRate' => null,
                'fetchBorrowRateHistories' => null,
                'fetchBorrowRateHistory' => null,
                'fetchBorrowRates' => true,
                'fetchBorrowRatesPerSymbol' => true,
                'fetchCanceledOrders' => null,
                'fetchClosedOrder' => null,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDeposit' => null,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => null,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchDepositWithdrawFee' => 'emulated',
                'fetchDepositWithdrawFees' => true,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => true,
                'fetchIndexOHLCV' => true,
                'fetchL3OrderBook' => null,
                'fetchLedger' => true,
                'fetchLedgerEntry' => null,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => true,
                'fetchMarketLeverageTiers' => true,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterest' => true,
                'fetchOpenInterestHistory' => true,
                'fetchOpenOrder' => null,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => null,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositions' => true,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => true,
                'fetchSettlementHistory' => true,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => true,
                'fetchTradingFees' => false,
                'fetchTradingLimits' => true,
                'fetchTransactionFee' => null,
                'fetchTransactionFees' => null,
                'fetchTransactions' => null,
                'fetchTransfers' => null,
                'fetchWithdrawAddresses' => true,
                'fetchWithdrawal' => null,
                'fetchWithdrawals' => true,
                'fetchWithdrawalWhitelist' => null,
                'reduceMargin' => null,
                'repayMargin' => true,
                'setLeverage' => true,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'signIn' => null,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1min',
                '5m' => '5min',
                '15m' => '15min',
                '30m' => '30min',
                '1h' => '60min',
                '4h' => '4hour',
                '1d' => '1day',
                '1w' => '1week',
                '1M' => '1mon',
                '1y' => '1year',
            ),
            'urls' => array(
                // 'test' => array(
                //     'market' => 'https://api.testnet.huobi.pro',
                //     'public' => 'https://api.testnet.huobi.pro',
                //     'private' => 'https://api.testnet.huobi.pro',
                // ),
                'logo' => 'https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg',
                'hostnames' => array(
                    'contract' => 'api.hbdm.com',
                    'spot' => 'api.huobi.pro',
                    'status' => array(
                        'spot' => 'status.huobigroup.com',
                        'future' => array(
                            'inverse' => 'status-dm.huobigroup.com',
                            'linear' => 'status-linear-swap.huobigroup.com', // USDT-Margined Contracts
                        ),
                        'swap' => array(
                            'inverse' => 'status-swap.huobigroup.com',
                            'linear' => 'status-linear-swap.huobigroup.com', // USDT-Margined Contracts
                        ),
                    ),
                    // recommended for AWS
                    // 'contract' => 'api.hbdm.vn',
                    // 'spot' => 'api-aws.huobi.pro',
                ),
                'api' => array(
                    'status' => 'https://{hostname}',
                    'contract' => 'https://{hostname}',
                    'spot' => 'https://{hostname}',
                    'public' => 'https://{hostname}',
                    'private' => 'https://{hostname}',
                    'v2Public' => 'https://{hostname}',
                    'v2Private' => 'https://{hostname}',
                ),
                'www' => 'https://www.huobi.com',
                'referral' => array(
                    'url' => 'https://www.huobi.com/en-us/v/register/double-invite/?inviter_id=11343840&invite_code=6rmm2223',
                    'discount' => 0.15,
                ),
                'doc' => array(
                    'https://huobiapi.github.io/docs/spot/v1/en/',
                    'https://huobiapi.github.io/docs/dm/v1/en/',
                    'https://huobiapi.github.io/docs/coin_margined_swap/v1/en/',
                    'https://huobiapi.github.io/docs/usdt_swap/v1/en/',
                ),
                'fees' => 'https://www.huobi.com/about/fee/',
            ),
            'api' => array(
                // ------------------------------------------------------------
                // old api definitions
                'v2Public' => array(
                    'get' => array(
                        'reference/currencies' => 1, // 币链参考信息
                        'market-status' => 1, // 获取当前市场状态
                    ),
                ),
                'v2Private' => array(
                    'get' => array(
                        'account/ledger' => 1,
                        'account/withdraw/quota' => 1,
                        'account/withdraw/address' => 1, // 提币地址查询(限母用户可用)
                        'account/deposit/address' => 1,
                        'account/repayment' => 5, // 还币交易记录查询
                        'reference/transact-fee-rate' => 1,
                        'account/asset-valuation' => 0.2, // 获取账户资产估值
                        'point/account' => 5, // 点卡余额查询
                        'sub-user/user-list' => 1, // 获取子用户列表
                        'sub-user/user-state' => 1, // 获取特定子用户的用户状态
                        'sub-user/account-list' => 1, // 获取特定子用户的账户列表
                        'sub-user/deposit-address' => 1, // 子用户充币地址查询
                        'sub-user/query-deposit' => 1, // 子用户充币记录查询
                        'user/api-key' => 1, // 母子用户API key信息查询
                        'user/uid' => 1, // 母子用户获取用户UID
                        'algo-orders/opening' => 1, // 查询未触发OPEN策略委托
                        'algo-orders/history' => 1, // 查询策略委托历史
                        'algo-orders/specific' => 1, // 查询特定策略委托
                        'c2c/offers' => 1, // 查询借入借出订单
                        'c2c/offer' => 1, // 查询特定借入借出订单及其交易记录
                        'c2c/transactions' => 1, // 查询借入借出交易记录
                        'c2c/repayment' => 1, // 查询还币交易记录
                        'c2c/account' => 1, // 查询账户余额
                        'etp/reference' => 1, // 基础参考信息
                        'etp/transactions' => 5, // 获取杠杆ETP申赎记录
                        'etp/transaction' => 5, // 获取特定杠杆ETP申赎记录
                        'etp/rebalance' => 1, // 获取杠杆ETP调仓记录
                        'etp/limit' => 1, // 获取ETP持仓限额
                    ),
                    'post' => array(
                        'account/transfer' => 1,
                        'account/repayment' => 5, // 归还借币（全仓逐仓通用）
                        'point/transfer' => 5, // 点卡划转
                        'sub-user/management' => 1, // 冻结/解冻子用户
                        'sub-user/creation' => 1, // 子用户创建
                        'sub-user/tradable-market' => 1, // 设置子用户交易权限
                        'sub-user/transferability' => 1, // 设置子用户资产转出权限
                        'sub-user/api-key-generation' => 1, // 子用户API key创建
                        'sub-user/api-key-modification' => 1, // 修改子用户API key
                        'sub-user/api-key-deletion' => 1, // 删除子用户API key
                        'sub-user/deduct-mode' => 1, // 设置子用户手续费抵扣模式
                        'algo-orders' => 1, // 策略委托下单
                        'algo-orders/cancel-all-after' => 1, // 自动撤销订单
                        'algo-orders/cancellation' => 1, // 策略委托（触发前）撤单
                        'c2c/offer' => 1, // 借入借出下单
                        'c2c/cancellation' => 1, // 借入借出撤单
                        'c2c/cancel-all' => 1, // 撤销所有借入借出订单
                        'c2c/repayment' => 1, // 还币
                        'c2c/transfer' => 1, // 资产划转
                        'etp/creation' => 5, // 杠杆ETP换入
                        'etp/redemption' => 5, // 杠杆ETP换出
                        'etp/{transactId}/cancel' => 10, // 杠杆ETP单个撤单
                        'etp/batch-cancel' => 50, // 杠杆ETP批量撤单
                    ),
                ),
                'public' => array(
                    'get' => array(
                        'common/symbols' => 1, // 查询系统支持的所有交易对
                        'common/currencys' => 1, // 查询系统支持的所有币种
                        'common/timestamp' => 1, // 查询系统当前时间
                        'common/exchange' => 1, // order limits
                        'settings/currencys' => 1, // ?language=en-US
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'account/accounts' => 0.2, // 查询当前用户的所有账户(即account-id)
                        'account/accounts/{id}/balance' => 0.2, // 查询指定账户的余额
                        'account/accounts/{sub-uid}' => 1,
                        'account/history' => 4,
                        'cross-margin/loan-info' => 1,
                        'margin/loan-info' => 1, // 查询借币币息率及额度
                        'fee/fee-rate/get' => 1,
                        'order/openOrders' => 0.4,
                        'order/orders' => 0.4,
                        'order/orders/{id}' => 0.4, // 查询某个订单详情
                        'order/orders/{id}/matchresults' => 0.4, // 查询某个订单的成交明细
                        'order/orders/getClientOrder' => 0.4,
                        'order/history' => 1, // 查询当前委托、历史委托
                        'order/matchresults' => 1, // 查询当前成交、历史成交
                        // 'dw/withdraw-virtual/addresses', // 查询虚拟币提现地址（Deprecated）
                        'query/deposit-withdraw' => 1,
                        // 'margin/loan-info', // duplicate
                        'margin/loan-orders' => 0.2, // 借贷订单
                        'margin/accounts/balance' => 0.2, // 借贷账户详情
                        'cross-margin/loan-orders' => 1, // 查询借币订单
                        'cross-margin/accounts/balance' => 1, // 借币账户详情
                        'points/actions' => 1,
                        'points/orders' => 1,
                        'subuser/aggregate-balance' => 10,
                        'stable-coin/exchange_rate' => 1,
                        'stable-coin/quote' => 1,
                    ),
                    'post' => array(
                        'account/transfer' => 1, // 资产划转(该节点为母用户和子用户进行资产划转的通用接口。)
                        'futures/transfer' => 1,
                        'order/batch-orders' => 0.4,
                        'order/orders/place' => 0.2, // 创建并执行一个新订单 (一步下单， 推荐使用)
                        'order/orders/submitCancelClientOrder' => 0.2,
                        'order/orders/batchCancelOpenOrders' => 0.4,
                        // 'order/orders', // 创建一个新的订单请求 （仅创建订单，不执行下单）
                        // 'order/orders/{id}/place', // 执行一个订单 （仅执行已创建的订单）
                        'order/orders/{id}/submitcancel' => 0.2, // 申请撤销一个订单请求
                        'order/orders/batchcancel' => 0.4, // 批量撤销订单
                        // 'dw/balance/transfer', // 资产划转
                        'dw/withdraw/api/create' => 1, // 申请提现虚拟币
                        // 'dw/withdraw-virtual/create', // 申请提现虚拟币
                        // 'dw/withdraw-virtual/{id}/place', // 确认申请虚拟币提现（Deprecated）
                        'dw/withdraw-virtual/{id}/cancel' => 1, // 申请取消提现虚拟币
                        'dw/transfer-in/margin' => 10, // 现货账户划入至借贷账户
                        'dw/transfer-out/margin' => 10, // 借贷账户划出至现货账户
                        'margin/orders' => 10, // 申请借贷
                        'margin/orders/{id}/repay' => 10, // 归还借贷
                        'cross-margin/transfer-in' => 1, // 资产划转
                        'cross-margin/transfer-out' => 1, // 资产划转
                        'cross-margin/orders' => 1, // 申请借币
                        'cross-margin/orders/{id}/repay' => 1, // 归还借币
                        'stable-coin/exchange' => 1,
                        'subuser/transfer' => 10,
                    ),
                ),
                // ------------------------------------------------------------
                // new api definitions
                // 'https://status.huobigroup.com/api/v2/summary.json' => 1,
                // 'https://status-dm.huobigroup.com/api/v2/summary.json' => 1,
                // 'https://status-swap.huobigroup.com/api/v2/summary.json' => 1,
                // 'https://status-linear-swap.huobigroup.com/api/v2/summary.json' => 1,
                'status' => array(
                    'public' => array(
                        'spot' => array(
                            'get' => array(
                                'api/v2/summary.json' => 1,
                            ),
                        ),
                        'future' => array(
                            'inverse' => array(
                                'get' => array(
                                    'api/v2/summary.json' => 1,
                                ),
                            ),
                            'linear' => array(
                                'get' => array(
                                    'api/v2/summary.json' => 1,
                                ),
                            ),
                        ),
                        'swap' => array(
                            'inverse' => array(
                                'get' => array(
                                    'api/v2/summary.json' => 1,
                                ),
                            ),
                            'linear' => array(
                                'get' => array(
                                    'api/v2/summary.json' => 1,
                                ),
                            ),
                        ),
                    ),
                ),
                'spot' => array(
                    'public' => array(
                        'get' => array(
                            'v2/market-status' => 1,
                            'v1/common/symbols' => 1,
                            'v1/common/currencys' => 1,
                            'v2/settings/common/currencies' => 1,
                            'v2/reference/currencies' => 1,
                            'v1/common/timestamp' => 1,
                            'v1/common/exchange' => 1, // order limits
                            'v1/settings/common/chains' => 1,
                            'v1/settings/common/currencys' => 1,
                            'v1/settings/common/symbols' => 1,
                            'v2/settings/common/symbols' => 1,
                            'v1/settings/common/market-symbols' => 1,
                            // Market Data
                            'market/history/candles' => 1,
                            'market/history/kline' => 1,
                            'market/detail/merged' => 1,
                            'market/tickers' => 1,
                            'market/detail' => 1,
                            'market/depth' => 1,
                            'market/trade' => 1,
                            'market/history/trade' => 1,
                            'market/etp' => 1, // Get real-time equity of leveraged ETP
                            // ETP
                            'v2/etp/reference' => 1,
                            'v2/etp/rebalance' => 1,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            // Account
                            'v1/account/accounts' => 0.2,
                            'v1/account/accounts/{account-id}/balance' => 0.2,
                            'v2/account/valuation' => 1,
                            'v2/account/asset-valuation' => 0.2,
                            'v1/account/history' => 4,
                            'v2/account/ledger' => 1,
                            'v2/point/account' => 5,
                            // Wallet (Deposit and Withdraw)
                            'v2/account/deposit/address' => 1,
                            'v2/account/withdraw/quota' => 1,
                            'v2/account/withdraw/address' => 1,
                            'v2/reference/currencies' => 1,
                            'v1/query/deposit-withdraw' => 1,
                            'v1/query/withdraw/client-order-id' => 1,
                            // Sub user management
                            'v2/user/api-key' => 1,
                            'v2/user/uid' => 1,
                            'v2/sub-user/user-list' => 1,
                            'v2/sub-user/user-state' => 1,
                            'v2/sub-user/account-list' => 1,
                            'v2/sub-user/deposit-address' => 1,
                            'v2/sub-user/query-deposit' => 1,
                            'v1/subuser/aggregate-balance' => 10,
                            'v1/account/accounts/{sub-uid}' => 1,
                            // Trading
                            'v1/order/openOrders' => 0.4,
                            'v1/order/orders/{order-id}' => 0.4,
                            'v1/order/orders/getClientOrder' => 0.4,
                            'v1/order/orders/{order-id}/matchresult' => 0.4,
                            'v1/order/orders/{order-id}/matchresults' => 0.4,
                            'v1/order/orders' => 0.4,
                            'v1/order/history' => 1,
                            'v1/order/matchresults' => 1,
                            'v2/reference/transact-fee-rate' => 1,
                            // Conditional Order
                            'v2/algo-orders/opening' => 1,
                            'v2/algo-orders/history' => 1,
                            'v2/algo-orders/specific' => 1,
                            // Margin Loan (Cross/Isolated)
                            'v1/margin/loan-info' => 1,
                            'v1/margin/loan-orders' => 0.2,
                            'v1/margin/accounts/balance' => 0.2,
                            'v1/cross-margin/loan-info' => 1,
                            'v1/cross-margin/loan-orders' => 1,
                            'v1/cross-margin/accounts/balance' => 1,
                            'v2/account/repayment' => 5,
                            // Stable Coin Exchange
                            'v1/stable-coin/quote' => 1,
                            'v1/stable_coin/exchange_rate' => 1,
                            // ETP
                            'v2/etp/transactions' => 5,
                            'v2/etp/transaction' => 5,
                            'v2/etp/limit' => 1,
                        ),
                        'post' => array(
                            // Account
                            'v1/account/transfer' => 1,
                            'v1/futures/transfer' => 1, // future transfers
                            'v2/point/transfer' => 5,
                            'v2/account/transfer' => 1, // swap transfers
                            // Wallet (Deposit and Withdraw)
                            'v1/dw/withdraw/api/create' => 1,
                            'v1/dw/withdraw-virtual/{withdraw-id}/cancel' => 1,
                            // Sub user management
                            'v2/sub-user/deduct-mode' => 1,
                            'v2/sub-user/creation' => 1,
                            'v2/sub-user/management' => 1,
                            'v2/sub-user/tradable-market' => 1,
                            'v2/sub-user/transferability' => 1,
                            'v2/sub-user/api-key-generation' => 1,
                            'v2/sub-user/api-key-modification' => 1,
                            'v2/sub-user/api-key-deletion' => 1,
                            'v1/subuser/transfer' => 10,
                            // Trading
                            'v1/order/orders/place' => 0.2,
                            'v1/order/batch-orders' => 0.4,
                            'v1/order/orders/{order-id}/submitcancel' => 0.2,
                            'v1/order/orders/submitCancelClientOrder' => 0.2,
                            'v1/order/orders/batchCancelOpenOrders' => 0.4,
                            'v1/order/orders/batchcancel' => 0.4,
                            'v2/algo-orders/cancel-all-after' => 1,
                            // Conditional Order
                            'v2/algo-orders' => 1,
                            'v2/algo-orders/cancellation' => 1,
                            // Margin Loan (Cross/Isolated)
                            'v2/account/repayment' => 5,
                            'v1/dw/transfer-in/margin' => 10,
                            'v1/dw/transfer-out/margin' => 10,
                            'v1/margin/orders' => 10,
                            'v1/margin/orders/{order-id}/repay' => 10,
                            'v1/cross-margin/transfer-in' => 1,
                            'v1/cross-margin/transfer-out' => 1,
                            'v1/cross-margin/orders' => 1,
                            'v1/cross-margin/orders/{order-id}/repay' => 1,
                            // Stable Coin Exchange
                            'v1/stable-coin/exchange' => 1,
                            // ETP
                            'v2/etp/creation' => 5,
                            'v2/etp/redemption' => 5,
                            'v2/etp/{transactId}/cancel' => 10,
                            'v2/etp/batch-cancel' => 50,
                        ),
                    ),
                ),
                'contract' => array(
                    'public' => array(
                        'get' => array(
                            'api/v1/timestamp' => 1,
                            'heartbeat/' => 1, // backslash is not a typo
                            // Future Market Data interface
                            'api/v1/contract_contract_info' => 1,
                            'api/v1/contract_index' => 1,
                            'api/v1/contract_price_limit' => 1,
                            'api/v1/contract_open_interest' => 1,
                            'api/v1/contract_delivery_price' => 1,
                            'market/depth' => 1,
                            'market/bbo' => 1,
                            'market/history/kline' => 1,
                            'index/market/history/mark_price_kline' => 1,
                            'market/detail/merged' => 1,
                            'market/detail/batch_merged' => 1,
                            'v2/market/detail/batch_merged' => 1,
                            'market/trade' => 1,
                            'market/history/trade' => 1,
                            'api/v1/contract_risk_info' => 1,
                            'api/v1/contract_insurance_fund' => 1,
                            'api/v1/contract_adjustfactor' => 1,
                            'api/v1/contract_his_open_interest' => 1,
                            'api/v1/contract_ladder_margin' => 1,
                            'api/v1/contract_api_state' => 1,
                            'api/v1/contract_elite_account_ratio' => 1,
                            'api/v1/contract_elite_position_ratio' => 1,
                            'api/v1/contract_liquidation_orders' => 1,
                            'api/v1/contract_settlement_records' => 1,
                            'index/market/history/index' => 1,
                            'index/market/history/basis' => 1,
                            'api/v1/contract_estimated_settlement_price' => 1,
                            'api/v3/contract_liquidation_orders' => 1,
                            // Swap Market Data interface
                            'swap-api/v1/swap_contract_info' => 1,
                            'swap-api/v1/swap_index' => 1,
                            'swap-api/v1/swap_price_limit' => 1,
                            'swap-api/v1/swap_open_interest' => 1,
                            'swap-ex/market/depth' => 1,
                            'swap-ex/market/bbo' => 1,
                            'swap-ex/market/history/kline' => 1,
                            'index/market/history/swap_mark_price_kline' => 1,
                            'swap-ex/market/detail/merged' => 1,
                            'v2/swap-ex/market/detail/batch_merged' => 1,
                            'index/market/history/swap_premium_index_kline' => 1,
                            'swap-ex/market/detail/batch_merged' => 1,
                            'swap-ex/market/trade' => 1,
                            'swap-ex/market/history/trade' => 1,
                            'swap-api/v1/swap_risk_info' => 1,
                            'swap-api/v1/swap_insurance_fund' => 1,
                            'swap-api/v1/swap_adjustfactor' => 1,
                            'swap-api/v1/swap_his_open_interest' => 1,
                            'swap-api/v1/swap_ladder_margin' => 1,
                            'swap-api/v1/swap_api_state' => 1,
                            'swap-api/v1/swap_elite_account_ratio' => 1,
                            'swap-api/v1/swap_elite_position_ratio' => 1,
                            'swap-api/v1/swap_estimated_settlement_price' => 1,
                            'swap-api/v1/swap_liquidation_orders' => 1,
                            'swap-api/v1/swap_settlement_records' => 1,
                            'swap-api/v1/swap_funding_rate' => 1,
                            'swap-api/v1/swap_batch_funding_rate' => 1,
                            'swap-api/v1/swap_historical_funding_rate' => 1,
                            'swap-api/v3/swap_liquidation_orders' => 1,
                            'index/market/history/swap_estimated_rate_kline' => 1,
                            'index/market/history/swap_basis' => 1,
                            // Swap Market Data interface
                            'linear-swap-api/v1/swap_contract_info' => 1,
                            'linear-swap-api/v1/swap_index' => 1,
                            'linear-swap-api/v1/swap_price_limit' => 1,
                            'linear-swap-api/v1/swap_open_interest' => 1,
                            'linear-swap-ex/market/depth' => 1,
                            'linear-swap-ex/market/bbo' => 1,
                            'linear-swap-ex/market/history/kline' => 1,
                            'index/market/history/linear_swap_mark_price_kline' => 1,
                            'linear-swap-ex/market/detail/merged' => 1,
                            'linear-swap-ex/market/detail/batch_merged' => 1,
                            'v2/linear-swap-ex/market/detail/batch_merged' => 1,
                            'linear-swap-ex/market/trade' => 1,
                            'linear-swap-ex/market/history/trade' => 1,
                            'linear-swap-api/v1/swap_risk_info' => 1,
                            'swap-api/v1/linear-swap-api/v1/swap_insurance_fund' => 1,
                            'linear-swap-api/v1/swap_adjustfactor' => 1,
                            'linear-swap-api/v1/swap_cross_adjustfactor' => 1,
                            'linear-swap-api/v1/swap_his_open_interest' => 1,
                            'linear-swap-api/v1/swap_ladder_margin' => 1,
                            'linear-swap-api/v1/swap_cross_ladder_margin' => 1,
                            'linear-swap-api/v1/swap_api_state' => 1,
                            'linear-swap-api/v1/swap_cross_transfer_state' => 1,
                            'linear-swap-api/v1/swap_cross_trade_state' => 1,
                            'linear-swap-api/v1/swap_elite_account_ratio' => 1,
                            'linear-swap-api/v1/swap_elite_position_ratio' => 1,
                            'linear-swap-api/v1/swap_liquidation_orders' => 1,
                            'linear-swap-api/v1/swap_settlement_records' => 1,
                            'linear-swap-api/v1/swap_funding_rate' => 1,
                            'linear-swap-api/v1/swap_batch_funding_rate' => 1,
                            'linear-swap-api/v1/swap_historical_funding_rate' => 1,
                            'linear-swap-api/v3/swap_liquidation_orders' => 1,
                            'index/market/history/linear_swap_premium_index_kline' => 1,
                            'index/market/history/linear_swap_estimated_rate_kline' => 1,
                            'index/market/history/linear_swap_basis' => 1,
                            'linear-swap-api/v1/swap_estimated_settlement_price' => 1,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            // Future Account Interface
                            'api/v1/contract_api_trading_status' => 1,
                            // Swap Account Interface
                            'swap-api/v1/swap_api_trading_status' => 1,
                            // Swap Account Interface
                            'linear-swap-api/v1/swap_api_trading_status' => 1,
                            'linear-swap-api/v3/unified_account_info' => 1,
                            'linear-swap-api/v3/swap_unified_account_type' => 1,
                        ),
                        'post' => array(
                            // Future Account Interface
                            'api/v1/contract_balance_valuation' => 1,
                            'api/v1/contract_account_info' => 1,
                            'api/v1/contract_position_info' => 1,
                            'api/v1/contract_sub_auth' => 1,
                            'api/v1/contract_sub_account_list' => 1,
                            'api/v1/contract_sub_account_info_list' => 1,
                            'api/v1/contract_sub_account_info' => 1,
                            'api/v1/contract_sub_position_info' => 1,
                            'api/v1/contract_financial_record' => 1,
                            'api/v1/contract_financial_record_exact' => 1,
                            'api/v1/contract_user_settlement_records' => 1,
                            'api/v1/contract_order_limit' => 1,
                            'api/v1/contract_fee' => 1,
                            'api/v1/contract_transfer_limit' => 1,
                            'api/v1/contract_position_limit' => 1,
                            'api/v1/contract_account_position_info' => 1,
                            'api/v1/contract_master_sub_transfer' => 1,
                            'api/v1/contract_master_sub_transfer_record' => 1,
                            'api/v1/contract_available_level_rate' => 1,
                            'api/v3/contract_financial_record' => 1,
                            'api/v3/contract_financial_record_exact' => 1,
                            // Future Trade Interface
                            'api/v1/contract_order' => 1,
                            'v1/contract_batchorder' => 1,
                            'api/v1/contract_cancel' => 1,
                            'api/v1/contract_cancelall' => 1,
                            'api/v1/contract_switch_lever_rate' => 1,
                            'api/v1/lightning_close_position' => 1,
                            'api/v1/contract_order_info' => 1,
                            'api/v1/contract_order_detail' => 1,
                            'api/v1/contract_openorders' => 1,
                            'api/v1/contract_hisorders' => 1,
                            'api/v1/contract_hisorders_exact' => 1,
                            'api/v1/contract_matchresults' => 1,
                            'api/v1/contract_matchresults_exact' => 1,
                            'api/v3/contract_hisorders' => 1,
                            'api/v3/contract_hisorders_exact' => 1,
                            'api/v3/contract_matchresults' => 1,
                            'api/v3/contract_matchresults_exact' => 1,
                            // Contract Strategy Order Interface
                            'api/v1/contract_trigger_order' => 1,
                            'api/v1/contract_trigger_cancel' => 1,
                            'api/v1/contract_trigger_cancelall' => 1,
                            'api/v1/contract_trigger_openorders' => 1,
                            'api/v1/contract_trigger_hisorders' => 1,
                            'api/v1/contract_tpsl_order' => 1,
                            'api/v1/contract_tpsl_cancel' => 1,
                            'api/v1/contract_tpsl_cancelall' => 1,
                            'api/v1/contract_tpsl_openorders' => 1,
                            'api/v1/contract_tpsl_hisorders' => 1,
                            'api/v1/contract_relation_tpsl_order' => 1,
                            'api/v1/contract_track_order' => 1,
                            'api/v1/contract_track_cancel' => 1,
                            'api/v1/contract_track_cancelall' => 1,
                            'api/v1/contract_track_openorders' => 1,
                            'api/v1/contract_track_hisorders' => 1,
                            // Swap Account Interface
                            'swap-api/v1/swap_balance_valuation' => 1,
                            'swap-api/v1/swap_account_info' => 1,
                            'swap-api/v1/swap_position_info' => 1,
                            'swap-api/v1/swap_account_position_info' => 1,
                            'swap-api/v1/swap_sub_auth' => 1,
                            'swap-api/v1/swap_sub_account_list' => 1,
                            'swap-api/v1/swap_sub_account_info_list' => 1,
                            'swap-api/v1/swap_sub_account_info' => 1,
                            'swap-api/v1/swap_sub_position_info' => 1,
                            'swap-api/v1/swap_financial_record' => 1,
                            'swap-api/v1/swap_financial_record_exact' => 1,
                            'swap-api/v1/swap_user_settlement_records' => 1,
                            'swap-api/v1/swap_available_level_rate' => 1,
                            'swap-api/v1/swap_order_limit' => 1,
                            'swap-api/v1/swap_fee' => 1,
                            'swap-api/v1/swap_transfer_limit' => 1,
                            'swap-api/v1/swap_position_limit' => 1,
                            'swap-api/v1/swap_master_sub_transfer' => 1,
                            'swap-api/v1/swap_master_sub_transfer_record' => 1,
                            'swap-api/v3/swap_financial_record' => 1,
                            'swap-api/v3/swap_financial_record_exact' => 1,
                            // Swap Trade Interface
                            'swap-api/v1/swap_order' => 1,
                            'swap-api/v1/swap_batchorder' => 1,
                            'swap-api/v1/swap_cancel' => 1,
                            'swap-api/v1/swap_cancelall' => 1,
                            'swap-api/v1/swap_lightning_close_position' => 1,
                            'swap-api/v1/swap_switch_lever_rate' => 1,
                            'swap-api/v1/swap_order_info' => 1,
                            'swap-api/v1/swap_order_detail' => 1,
                            'swap-api/v1/swap_openorders' => 1,
                            'swap-api/v1/swap_hisorders' => 1,
                            'swap-api/v1/swap_hisorders_exact' => 1,
                            'swap-api/v1/swap_matchresults' => 1,
                            'swap-api/v1/swap_matchresults_exact' => 1,
                            'swap-api/v3/swap_matchresults' => 1,
                            'swap-api/v3/swap_matchresults_exact' => 1,
                            'swap-api/v3/swap_hisorders' => 1,
                            'swap-api/v3/swap_hisorders_exact' => 1,
                            // Swap Strategy Order Interface
                            'swap-api/v1/swap_trigger_order' => 1,
                            'swap-api/v1/swap_trigger_cancel' => 1,
                            'swap-api/v1/swap_trigger_cancelall' => 1,
                            'swap-api/v1/swap_trigger_openorders' => 1,
                            'swap-api/v1/swap_trigger_hisorders' => 1,
                            'swap-api/v1/swap_tpsl_order' => 1,
                            'swap-api/v1/swap_tpsl_cancel' => 1,
                            'swap-api/v1/swap_tpsl_cancelall' => 1,
                            'swap-api/v1/swap_tpsl_openorders' => 1,
                            'swap-api/v1/swap_tpsl_hisorders' => 1,
                            'swap-api/v1/swap_relation_tpsl_order' => 1,
                            'swap-api/v1/swap_track_order' => 1,
                            'swap-api/v1/swap_track_cancel' => 1,
                            'swap-api/v1/swap_track_cancelall' => 1,
                            'swap-api/v1/swap_track_openorders' => 1,
                            'swap-api/v1/swap_track_hisorders' => 1,
                            // Swap Account Interface
                            'linear-swap-api/v1/swap_lever_position_limit' => 1,
                            'linear-swap-api/v1/swap_cross_lever_position_limit' => 1,
                            'linear-swap-api/v1/swap_balance_valuation' => 1,
                            'linear-swap-api/v1/swap_account_info' => 1,
                            'linear-swap-api/v1/swap_cross_account_info' => 1,
                            'linear-swap-api/v1/swap_position_info' => 1,
                            'linear-swap-api/v1/swap_cross_position_info' => 1,
                            'linear-swap-api/v1/swap_account_position_info' => 1,
                            'linear-swap-api/v1/swap_cross_account_position_info' => 1,
                            'linear-swap-api/v1/swap_sub_auth' => 1,
                            'linear-swap-api/v1/swap_sub_account_list' => 1,
                            'linear-swap-api/v1/swap_cross_sub_account_list' => 1,
                            'linear-swap-api/v1/swap_sub_account_info_list' => 1,
                            'linear-swap-api/v1/swap_cross_sub_account_info_list' => 1,
                            'linear-swap-api/v1/swap_sub_account_info' => 1,
                            'linear-swap-api/v1/swap_cross_sub_account_info' => 1,
                            'linear-swap-api/v1/swap_sub_position_info' => 1,
                            'linear-swap-api/v1/swap_cross_sub_position_info' => 1,
                            'linear-swap-api/v1/swap_financial_record' => 1,
                            'linear-swap-api/v1/swap_financial_record_exact' => 1,
                            'linear-swap-api/v1/swap_user_settlement_records' => 1,
                            'linear-swap-api/v1/swap_cross_user_settlement_records' => 1,
                            'linear-swap-api/v1/swap_available_level_rate' => 1,
                            'linear-swap-api/v1/swap_cross_available_level_rate' => 1,
                            'linear-swap-api/v1/swap_order_limit' => 1,
                            'linear-swap-api/v1/swap_fee' => 1,
                            'linear-swap-api/v1/swap_transfer_limit' => 1,
                            'linear-swap-api/v1/swap_cross_transfer_limit' => 1,
                            'linear-swap-api/v1/swap_position_limit' => 1,
                            'linear-swap-api/v1/swap_cross_position_limit' => 1,
                            'linear-swap-api/v1/swap_master_sub_transfer' => 1,
                            'linear-swap-api/v1/swap_master_sub_transfer_record' => 1,
                            'linear-swap-api/v1/swap_transfer_inner' => 1,
                            'linear-swap-api/v3/swap_financial_record' => 1,
                            'linear-swap-api/v3/swap_financial_record_exact' => 1,
                            // Swap Trade Interface
                            'linear-swap-api/v1/swap_order' => 1,
                            'linear-swap-api/v1/swap_cross_order' => 1,
                            'linear-swap-api/v1/swap_batchorder' => 1,
                            'linear-swap-api/v1/swap_cross_batchorder' => 1,
                            'linear-swap-api/v1/swap_cancel' => 1,
                            'linear-swap-api/v1/swap_cross_cancel' => 1,
                            'linear-swap-api/v1/swap_cancelall' => 1,
                            'linear-swap-api/v1/swap_cross_cancelall' => 1,
                            'linear-swap-api/v1/swap_switch_lever_rate' => 1,
                            'linear-swap-api/v1/swap_cross_switch_lever_rate' => 1,
                            'linear-swap-api/v1/swap_lightning_close_position' => 1,
                            'linear-swap-api/v1/swap_cross_lightning_close_position' => 1,
                            'linear-swap-api/v1/swap_order_info' => 1,
                            'linear-swap-api/v1/swap_cross_order_info' => 1,
                            'linear-swap-api/v1/swap_order_detail' => 1,
                            'linear-swap-api/v1/swap_cross_order_detail' => 1,
                            'linear-swap-api/v1/swap_openorders' => 1,
                            'linear-swap-api/v1/swap_cross_openorders' => 1,
                            'linear-swap-api/v1/swap_hisorders' => 1,
                            'linear-swap-api/v1/swap_cross_hisorders' => 1,
                            'linear-swap-api/v1/swap_hisorders_exact' => 1,
                            'linear-swap-api/v1/swap_cross_hisorders_exact' => 1,
                            'linear-swap-api/v1/swap_matchresults' => 1,
                            'linear-swap-api/v1/swap_cross_matchresults' => 1,
                            'linear-swap-api/v1/swap_matchresults_exact' => 1,
                            'linear-swap-api/v1/swap_cross_matchresults_exact' => 1,
                            'linear-swap-api/v1/swap_switch_position_mode' => 1,
                            'linear-swap-api/v1/swap_cross_switch_position_mode' => 1,
                            'linear-swap-api/v3/swap_matchresults' => 1,
                            'linear-swap-api/v3/swap_cross_matchresults' => 1,
                            'linear-swap-api/v3/swap_matchresults_exact' => 1,
                            'linear-swap-api/v3/swap_cross_matchresults_exact' => 1,
                            'linear-swap-api/v3/swap_hisorders' => 1,
                            'linear-swap-api/v3/swap_cross_hisorders' => 1,
                            'linear-swap-api/v3/swap_hisorders_exact' => 1,
                            'linear-swap-api/v3/swap_cross_hisorders_exact' => 1,
                            'linear-swap-api/v3/swap_switch_account_type' => 1,
                            // Swap Strategy Order Interface
                            'linear-swap-api/v1/swap_trigger_order' => 1,
                            'linear-swap-api/v1/swap_cross_trigger_order' => 1,
                            'linear-swap-api/v1/swap_trigger_cancel' => 1,
                            'linear-swap-api/v1/swap_cross_trigger_cancel' => 1,
                            'linear-swap-api/v1/swap_trigger_cancelall' => 1,
                            'linear-swap-api/v1/swap_cross_trigger_cancelall' => 1,
                            'linear-swap-api/v1/swap_trigger_openorders' => 1,
                            'linear-swap-api/v1/swap_cross_trigger_openorders' => 1,
                            'linear-swap-api/v1/swap_trigger_hisorders' => 1,
                            'linear-swap-api/v1/swap_cross_trigger_hisorders' => 1,
                            'linear-swap-api/v1/swap_tpsl_order' => 1,
                            'linear-swap-api/v1/swap_cross_tpsl_order' => 1,
                            'linear-swap-api/v1/swap_tpsl_cancel' => 1,
                            'linear-swap-api/v1/swap_cross_tpsl_cancel' => 1,
                            'linear-swap-api/v1/swap_tpsl_cancelall' => 1,
                            'linear-swap-api/v1/swap_cross_tpsl_cancelall' => 1,
                            'linear-swap-api/v1/swap_tpsl_openorders' => 1,
                            'linear-swap-api/v1/swap_cross_tpsl_openorders' => 1,
                            'linear-swap-api/v1/swap_tpsl_hisorders' => 1,
                            'linear-swap-api/v1/swap_cross_tpsl_hisorders' => 1,
                            'linear-swap-api/v1/swap_relation_tpsl_order' => 1,
                            'linear-swap-api/v1/swap_cross_relation_tpsl_order' => 1,
                            'linear-swap-api/v1/swap_track_order' => 1,
                            'linear-swap-api/v1/swap_cross_track_order' => 1,
                            'linear-swap-api/v1/swap_track_cancel' => 1,
                            'linear-swap-api/v1/swap_cross_track_cancel' => 1,
                            'linear-swap-api/v1/swap_track_cancelall' => 1,
                            'linear-swap-api/v1/swap_cross_track_cancelall' => 1,
                            'linear-swap-api/v1/swap_track_openorders' => 1,
                            'linear-swap-api/v1/swap_cross_track_openorders' => 1,
                            'linear-swap-api/v1/swap_track_hisorders' => 1,
                            'linear-swap-api/v1/swap_cross_track_hisorders' => 1,
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'feeSide' => 'get',
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.002'),
                    'taker' => $this->parse_number('0.002'),
                ),
            ),
            'exceptions' => array(
                'broad' => array(
                    'contract is restricted of closing positions on API.  Please contact customer service' => '\\ccxt\\OnMaintenance',
                    'maintain' => '\\ccxt\\OnMaintenance',
                ),
                'exact' => array(
                    // err-code
                    '403' => '\\ccxt\\AuthenticationError',  // array("status":"error","err_code":403,"err_msg":"Incorrect Access key [Access key错误]","ts":1652774224344)
                    '1010' => '\\ccxt\\AccountNotEnabled', // array("status":"error","err_code":1010,"err_msg":"Account doesnt exist.","ts":1648137970490)
                    '1003' => '\\ccxt\\AuthenticationError', // array(code => '1003', message => 'invalid signature')
                    '1013' => '\\ccxt\\BadSymbol', // array("status":"error","err_code":1013,"err_msg":"This contract symbol doesnt exist.","ts":1640550459583)
                    '1017' => '\\ccxt\\OrderNotFound', // array("status":"error","err_code":1017,"err_msg":"Order doesnt exist.","ts":1640550859242)
                    '1034' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1034,"err_msg":"Incorrect field of order price type.","ts":1643802870182)
                    '1036' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1036,"err_msg":"Incorrect field of open long form.","ts":1643802518986)
                    '1039' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1039,"err_msg":"Buy price must be lower than 39270.9USDT. Sell price must exceed 37731USDT.","ts":1643802374403)
                    '1041' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1041,"err_msg":"The order amount exceeds the limit (170000Cont), please modify and order again.","ts":1643802784940)
                    '1047' => '\\ccxt\\InsufficientFunds', // array("status":"error","err_code":1047,"err_msg":"Insufficient margin available.","ts":1643802672652)
                    '1048' => '\\ccxt\\InsufficientFunds',  // array("status":"error","err_code":1048,"err_msg":"Insufficient close amount available.","ts":1652772408864)
                    '1051' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1051,"err_msg":"No orders to cancel.","ts":1652552125876)
                    '1066' => '\\ccxt\\BadSymbol', // array("status":"error","err_code":1066,"err_msg":"The symbol field cannot be empty. Please re-enter.","ts":1640550819147)
                    '1067' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1067,"err_msg":"The client_order_id field is invalid. Please re-enter.","ts":1643802119413)
                    '1094' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1094,"err_msg":"The leverage cannot be empty, please switch the leverage or contact customer service","ts":1640496946243)
                    '1220' => '\\ccxt\\AccountNotEnabled', // array("status":"error","err_code":1220,"err_msg":"You don’t have access permission have not opened contracts trading.","ts":1645096660718)
                    '1303' => '\\ccxt\\BadRequest', // array("code":1303,"data":null,"message":"Each transfer-out cannot be less than 5USDT.","success":false,"print-log":true)
                    '1461' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1461,"err_msg":"Current positions have triggered position limits (5000USDT). Please modify.","ts":1652554651234)
                    'bad-request' => '\\ccxt\\BadRequest',
                    'validation-format-error' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"validation-format-error","err-msg":"Format Error => order-id.","data":null)
                    'validation-constraints-required' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"validation-constraints-required","err-msg":"Field is missing => client-order-id.","data":null)
                    'base-date-limit-error' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"base-date-limit-error","err-msg":"date less than system limit","data":null)
                    'api-not-support-temp-addr' => '\\ccxt\\PermissionDenied', // array("status":"error","err-code":"api-not-support-temp-addr","err-msg":"API withdrawal does not support temporary addresses","data":null)
                    'timeout' => '\\ccxt\\RequestTimeout', // array("ts":1571653730865,"status":"error","err-code":"timeout","err-msg":"Request Timeout")
                    'gateway-internal-error' => '\\ccxt\\ExchangeNotAvailable', // array("status":"error","err-code":"gateway-internal-error","err-msg":"Failed to load data. Try again later.","data":null)
                    'account-frozen-balance-insufficient-error' => '\\ccxt\\InsufficientFunds', // array("status":"error","err-code":"account-frozen-balance-insufficient-error","err-msg":"trade account balance is not enough, left => `0.0027`","data":null)
                    'invalid-amount' => '\\ccxt\\InvalidOrder', // eg "Paramemter `amount` is invalid."
                    'order-limitorder-amount-min-error' => '\\ccxt\\InvalidOrder', // limit order amount error, min => `0.001`
                    'order-limitorder-amount-max-error' => '\\ccxt\\InvalidOrder', // market order amount error, max => `1000000`
                    'order-marketorder-amount-min-error' => '\\ccxt\\InvalidOrder', // market order amount error, min => `0.01`
                    'order-limitorder-price-min-error' => '\\ccxt\\InvalidOrder', // limit order price error
                    'order-limitorder-price-max-error' => '\\ccxt\\InvalidOrder', // limit order price error
                    'order-stop-order-hit-trigger' => '\\ccxt\\InvalidOrder', // array("status":"error","err-code":"order-stop-order-hit-trigger","err-msg":"Orders that are triggered immediately are not supported.","data":null)
                    'order-value-min-error' => '\\ccxt\\InvalidOrder', // array("status":"error","err-code":"order-value-min-error","err-msg":"Order total cannot be lower than => 1 USDT","data":null)
                    'order-invalid-price' => '\\ccxt\\InvalidOrder', // array("status":"error","err-code":"order-invalid-price","err-msg":"invalid price","data":null)
                    'order-holding-limit-failed' => '\\ccxt\\InvalidOrder', // array("status":"error","err-code":"order-holding-limit-failed","err-msg":"Order failed, exceeded the holding limit of this currency","data":null)
                    'order-orderprice-precision-error' => '\\ccxt\\InvalidOrder', // array("status":"error","err-code":"order-orderprice-precision-error","err-msg":"order price precision error, scale => `4`","data":null)
                    'order-etp-nav-price-max-error' => '\\ccxt\\InvalidOrder', // array("status":"error","err-code":"order-etp-nav-price-max-error","err-msg":"Order price cannot be higher than 5% of NAV","data":null)
                    'order-orderstate-error' => '\\ccxt\\OrderNotFound', // canceling an already canceled order
                    'order-queryorder-invalid' => '\\ccxt\\OrderNotFound', // querying a non-existent order
                    'order-update-error' => '\\ccxt\\ExchangeNotAvailable', // undocumented error
                    'api-signature-check-failed' => '\\ccxt\\AuthenticationError',
                    'api-signature-not-valid' => '\\ccxt\\AuthenticationError', // array("status":"error","err-code":"api-signature-not-valid","err-msg":"Signature not valid => Incorrect Access key [Access key错误]","data":null)
                    'base-record-invalid' => '\\ccxt\\OrderNotFound', // https://github.com/ccxt/ccxt/issues/5750
                    'base-symbol-trade-disabled' => '\\ccxt\\BadSymbol', // array("status":"error","err-code":"base-symbol-trade-disabled","err-msg":"Trading is disabled for this symbol","data":null)
                    'base-symbol-error' => '\\ccxt\\BadSymbol', // array("status":"error","err-code":"base-symbol-error","err-msg":"The symbol is invalid","data":null)
                    'system-maintenance' => '\\ccxt\\OnMaintenance', // array("status" => "error", "err-code" => "system-maintenance", "err-msg" => "System is in maintenance!", "data" => null)
                    'base-request-exceed-frequency-limit' => '\\ccxt\\RateLimitExceeded', // array("status":"error","err-code":"base-request-exceed-frequency-limit","err-msg":"Frequency of requests has exceeded the limit, please try again later","data":null)
                    // err-msg
                    'invalid symbol' => '\\ccxt\\BadSymbol', // array("ts":1568813334794,"status":"error","err-code":"invalid-parameter","err-msg":"invalid symbol")
                    'symbol trade not open now' => '\\ccxt\\BadSymbol', // array("ts":1576210479343,"status":"error","err-code":"invalid-parameter","err-msg":"symbol trade not open now")
                    'require-symbol' => '\\ccxt\\BadSymbol', // array("status":"error","err-code":"require-symbol","err-msg":"Parameter `symbol` is required.","data":null),
                    'invalid-address' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"invalid-address","err-msg":"Invalid address.","data":null),
                    'base-currency-chain-error' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"base-currency-chain-error","err-msg":"The current currency chain does not exist","data":null),
                    'dw-insufficient-balance' => '\\ccxt\\InsufficientFunds', // array("status":"error","err-code":"dw-insufficient-balance","err-msg":"Insufficient balance. You can only transfer `12.3456` at most.","data":null)
                    'base-withdraw-fee-error' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"base-withdraw-fee-error","err-msg":"withdrawal fee is not within limits","data":null)
                    'dw-withdraw-min-limit' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"dw-withdraw-min-limit","err-msg":"The withdrawal amount is less than the minimum limit.","data":null)
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'options' => array(
                'fetchMarkets' => array(
                    'types' => array(
                        'spot' => true,
                        'future' => array(
                            'linear' => true,
                            'inverse' => true,
                        ),
                        'swap' => array(
                            'linear' => true,
                            'inverse' => true,
                        ),
                    ),
                ),
                'withdraw' => array(
                    'includeFee' => false,
                ),
                'defaultType' => 'spot', // spot, future, swap
                'defaultSubType' => 'linear', // inverse, linear
                'defaultNetwork' => 'ERC20',
                'defaultNetworks' => array(
                    'ETH' => 'ERC20',
                    'BTC' => 'BTC',
                    'USDT' => 'TRC20',
                ),
                'networks' => array(
                    // by displaynames
                    'ALGO' => 'ALGO',
                    'ALGORAND' => 'ALGO',
                    'BEP20' => 'BEP20',
                    'BSC' => 'BEP20',
                    'ERC20' => 'ERC20',
                    'ETH' => 'ERC20',
                    'AVALANCHE' => 'AVAXCCHAIN',
                    'AVAX' => 'AVAXCCHAIN',
                    'HRC20' => 'HECO',
                    'HECO' => 'HECO',
                    // 'HT' => 'HECO', // HT is not acceptable networkcode for unification
                    'TRC20' => 'TRC20',
                    'TRX' => 'TRC20',
                    'BTC' => 'BTC',
                    'BITCOIN' => 'BTC',
                    'ARBITRUM' => 'ARB',
                    'ARB' => 'ARB',
                    'SOLANA' => 'SOL',
                    'SOL' => 'SOL',
                    'SPL' => 'SOL',
                    'PRC20' => 'PRC20',
                    'POLYGON' => 'PRC20',
                    'MATIC' => 'PRC20',
                ),
                'networksById' => array(
                    'ALGO' => 'ALGO',
                    'BEP20' => 'BEP20',
                    'ERC20' => 'ERC20',
                    'AVAXCCHAIN' => 'AVALANCHE',
                    'HECO' => 'HRC20',
                    'TRC20' => 'TRC20',
                    'BTC' => 'BTC',
                    'ARB' => 'ARBITRUM',
                    'SOL' => 'SOLANA',
                    'PRC20' => 'POLYGON',
                ),
                // https://github.com/ccxt/ccxt/issues/5376
                'fetchOrdersByStatesMethod' => 'spot_private_get_v1_order_orders', // 'spot_private_get_v1_order_history' // https://github.com/ccxt/ccxt/pull/5392
                'createMarketBuyOrderRequiresPrice' => true,
                'language' => 'en-US',
                'broker' => array(
                    'id' => 'AA03022abc',
                ),
                'accountsByType' => array(
                    'spot' => 'pro',
                    'funding' => 'pro',
                    'future' => 'futures',
                ),
                'accountsById' => array(
                    'spot' => 'spot',
                    'margin' => 'margin',
                    'otc' => 'otc',
                    'point' => 'point',
                    'super-margin' => 'super-margin',
                    'investment' => 'investment',
                    'borrow' => 'borrow',
                    'grid-trading' => 'grid-trading',
                    'deposit-earning' => 'deposit-earning',
                    'otc-options' => 'otc-options',
                ),
                'marginAccounts' => array(
                    'cross' => 'super-margin',
                    'isolated' => 'margin',
                ),
                'typesByAccount' => array(
                    'pro' => 'spot',
                    'futures' => 'future',
                ),
                'spot' => array(
                    'stopOrderTypes' => array(
                        'stop-limit' => true,
                        'buy-stop-limit' => true,
                        'sell-stop-limit' => true,
                        'stop-limit-fok' => true,
                        'buy-stop-limit-fok' => true,
                        'sell-stop-limit-fok' => true,
                    ),
                    'limitOrderTypes' => array(
                        'limit' => true,
                        'buy-limit' => true,
                        'sell-limit' => true,
                        'ioc' => true,
                        'buy-ioc' => true,
                        'sell-ioc' => true,
                        'limit-maker' => true,
                        'buy-limit-maker' => true,
                        'sell-limit-maker' => true,
                        'stop-limit' => true,
                        'buy-stop-limit' => true,
                        'sell-stop-limit' => true,
                        'limit-fok' => true,
                        'buy-limit-fok' => true,
                        'sell-limit-fok' => true,
                        'stop-limit-fok' => true,
                        'buy-stop-limit-fok' => true,
                        'sell-stop-limit-fok' => true,
                    ),
                ),
            ),
            'commonCurrencies' => array(
                // https://github.com/ccxt/ccxt/issues/6081
                // https://github.com/ccxt/ccxt/issues/3365
                // https://github.com/ccxt/ccxt/issues/2873
                'GET' => 'Themis', // conflict with GET (Guaranteed Entrance Token, GET Protocol)
                'GTC' => 'Game.com', // conflict with Gitcoin and Gastrocoin
                'HIT' => 'HitChain',
                'HOT' => 'Hydro Protocol', // conflict with HOT (Holo) https://github.com/ccxt/ccxt/issues/4929
                // https://github.com/ccxt/ccxt/issues/7399
                // https://coinmarketcap.com/currencies/pnetwork/
                // https://coinmarketcap.com/currencies/penta/markets/
                // https://en.cryptonomist.ch/blog/eidoo/the-edo-to-pnt-upgrade-what-you-need-to-know-updated/
                'PNT' => 'Penta',
                'SBTC' => 'Super Bitcoin',
                'SOUL' => 'Soulsaver',
                'BIFI' => 'Bitcoin File', // conflict with Beefy.Finance https://github.com/ccxt/ccxt/issues/8706
            ),
        ));
    }

    public function fetch_status($params = array ()) {
        return Async\async(function () use ($params) {
            Async\await($this->load_markets());
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('fetchMyTrades', null, $params);
            $method = 'statusPublicSpotGetApiV2SummaryJson';
            if ($marketType !== 'spot') {
                $subType = $this->safe_string($params, 'subType', $this->options['defaultSubType']);
                if ($marketType === 'swap') {
                    if ($subType === 'linear') {
                        $method = 'statusPublicSwapLinearGetApiV2SummaryJson';
                    } elseif ($subType === 'inverse') {
                        $method = 'statusPublicSwapInverseGetApiV2SummaryJson';
                    }
                } elseif ($marketType === 'future') {
                    if ($subType === 'linear') {
                        $method = 'statusPublicFutureLinearGetApiV2SummaryJson';
                    } elseif ($subType === 'inverse') {
                        $method = 'statusPublicFutureInverseGetApiV2SummaryJson';
                    }
                } elseif ($marketType === 'contract') {
                    $method = 'contractPublicGetHeartbeat';
                }
            }
            $response = Async\await($this->$method ());
            //
            // statusPublicSpotGetApiV2SummaryJson, statusPublicSwapInverseGetApiV2SummaryJson, statusPublicFutureLinearGetApiV2SummaryJson, statusPublicFutureInverseGetApiV2SummaryJson
            //
            //      {
            //          "page" => array(
            //              "id":"mn7l2lw8pz4p",
            //              "name":"Huobi Futures-USDT-margined Swaps",
            //              "url":"https://status-linear-swap.huobigroup.com",
            //              "time_zone":"Asia/Singapore",
            //              "updated_at":"2022-04-29T12:47:21.319+08:00"),
            //              "components" => array(
            //                  array(
            //                      "id":"lrv093qk3yp5",
            //                      "name":"market data",
            //                      "status":"operational",
            //                      "created_at":"2020-10-29T14:08:59.427+08:00",
            //                      "updated_at":"2020-10-29T14:08:59.427+08:00",
            //                      "position":1,"description":null,
            //                      "showcase":false,
            //                      "start_date":null,
            //                      "group_id":null,
            //                      "page_id":"mn7l2lw8pz4p",
            //                      "group":true,
            //                      "only_show_if_degraded":false,
            //                      "components" => array(
            //                          "82k5jxg7ltxd" // list of related components
            //                      )
            //                  ),
            //              ),
            //              "incidents" => array( // empty array if there are no issues
            //                  {
            //                      "id" => "rclfxz2g21ly",  // incident id
            //                      "name" => "Market data is delayed",  // incident name
            //                      "status" => "investigating",  // incident $status
            //                      "created_at" => "2020-02-11T03:15:01.913Z",  // incident create time
            //                      "updated_at" => "2020-02-11T03:15:02.003Z",   // incident update time
            //                      "monitoring_at" => null,
            //                      "resolved_at" => null,
            //                      "impact" => "minor",  // incident impact
            //                      "shortlink" => "http://stspg.io/pkvbwp8jppf9",
            //                      "started_at" => "2020-02-11T03:15:01.906Z",
            //                      "page_id" => "p0qjfl24znv5",
            //                      "incident_updates" => array(
            //                          {
            //                              "id" => "dwfsk5ttyvtb",
            //                              "status" => "investigating",
            //                              "body" => "Market data is delayed",
            //                              "incident_id" => "rclfxz2g21ly",
            //                              "created_at" => "2020-02-11T03:15:02.000Z",
            //                              "updated_at" => "2020-02-11T03:15:02.000Z",
            //                              "display_at" => "2020-02-11T03:15:02.000Z",
            //                              "affected_components" => array(
            //                                  {
            //                                      "code" => "nctwm9tghxh6",
            //                                      "name" => "Market data",
            //                                      "old_status" => "operational",
            //                                      "new_status" => "degraded_performance"
            //                                  }
            //                              ),
            //                              "deliver_notifications" => true,
            //                              "custom_tweet" => null,
            //                              "tweet_id" => null
            //                          }
            //                      ),
            //                      "components" => array(
            //                          array(
            //                              "id" => "nctwm9tghxh6",
            //                              "name" => "Market data",
            //                              "status" => "degraded_performance",
            //                              "created_at" => "2020-01-13T09:34:48.284Z",
            //                              "updated_at" => "2020-02-11T03:15:01.951Z",
            //                              "position" => 8,
            //                              "description" => null,
            //                              "showcase" => false,
            //                              "group_id" => null,
            //                              "page_id" => "p0qjfl24znv5",
            //                              "group" => false,
            //                              "only_show_if_degraded" => false
            //                          }
            //                      )
            //                  ), ...
            //              ),
            //              "scheduled_maintenances":array( // empty array if there are no scheduled maintenances
            //                  {
            //                      "id" => "k7g299zl765l", // incident id
            //                      "name" => "Schedule maintenance", // incident name
            //                      "status" => "scheduled", // incident $status
            //                      "created_at" => "2020-02-11T03:16:31.481Z",  // incident create time
            //                      "updated_at" => "2020-02-11T03:16:31.530Z",  // incident update time
            //                      "monitoring_at" => null,
            //                      "resolved_at" => null,
            //                      "impact" => "maintenance",  // incident impact
            //                      "shortlink" => "http://stspg.io/md4t4ym7nytd",
            //                      "started_at" => "2020-02-11T03:16:31.474Z",
            //                      "page_id" => "p0qjfl24znv5",
            //                      "incident_updates" => array(
            //                          {
            //                              "id" => "8whgr3rlbld8",
            //                              "status" => "scheduled",
            //                              "body" => "We will be undergoing scheduled maintenance during this time.",
            //                              "incident_id" => "k7g299zl765l",
            //                              "created_at" => "2020-02-11T03:16:31.527Z",
            //                              "updated_at" => "2020-02-11T03:16:31.527Z",
            //                              "display_at" => "2020-02-11T03:16:31.527Z",
            //                              "affected_components" => array(
            //                                  {
            //                                      "code" => "h028tnzw1n5l",
            //                                      "name" => "Deposit And Withdraw - Deposit",
            //                                      "old_status" => "operational",
            //                                      "new_status" => "operational"
            //                                  }
            //                              ),
            //                              "deliver_notifications" => true,
            //                              "custom_tweet" => null,
            //                              "tweet_id" => null
            //                          }
            //                      ),
            //                      "components" => array(
            //                          {
            //                              "id" => "h028tnzw1n5l",
            //                              "name" => "Deposit",
            //                              "status" => "operational",
            //                              "created_at" => "2019-12-05T02:07:12.372Z",
            //                              "updated_at" => "2020-02-10T12:34:52.970Z",
            //                              "position" => 1,
            //                              "description" => null,
            //                              "showcase" => false,
            //                              "group_id" => "gtd0nyr3pf0k",
            //                              "page_id" => "p0qjfl24znv5",
            //                              "group" => false,
            //                              "only_show_if_degraded" => false
            //                          }
            //                      ),
            //                      "scheduled_for" => "2020-02-15T00:00:00.000Z",  // scheduled maintenance start time
            //                      "scheduled_until" => "2020-02-15T01:00:00.000Z"  // scheduled maintenance end time
            //                  }
            //              ),
            //              "status" => {
            //                  "indicator":"none", // none, minor, major, critical, maintenance
            //                  "description":"all systems operational" // All Systems Operational, Minor Service Outage, Partial System Outage, Partially Degraded Service, Service Under Maintenance
            //              }
            //          }
            //
            //
            // contractPublicGetHeartbeat
            //
            //      {
            //          "status" => "ok", // 'ok', 'error'
            //          "data" => array(
            //              "heartbeat" => 1, // future 1 => available, 0 => maintenance with service suspended
            //              "estimated_recovery_time" => null, // estimated recovery time in milliseconds
            //              "swap_heartbeat" => 1,
            //              "swap_estimated_recovery_time" => null,
            //              "option_heartbeat" => 1,
            //              "option_estimated_recovery_time" => null,
            //              "linear_swap_heartbeat" => 1,
            //              "linear_swap_estimated_recovery_time" => null
            //          ),
            //          "ts" => 1557714418033
            //      }
            //
            $status = null;
            $updated = null;
            $url = null;
            if ($method === 'contractPublicGetHeartbeat') {
                $statusRaw = $this->safe_string($response, 'status');
                $status = ($statusRaw === 'ok') ? 'ok' : 'maintenance'; // 'ok', 'error'
                $updated = $this->safe_string($response, 'ts');
            } else {
                $statusData = $this->safe_value($response, 'status', array());
                $statusRaw = $this->safe_string($statusData, 'indicator');
                $status = ($statusRaw === 'none') ? 'ok' : 'maintenance'; // none, minor, major, critical, maintenance
                $pageData = $this->safe_value($response, 'page', array());
                $datetime = $this->safe_string($pageData, 'updated_at');
                $updated = $this->parse8601($datetime);
                $url = $this->safe_string($pageData, 'url');
            }
            return array(
                'status' => $status,
                'updated' => $updated,
                'eta' => null,
                'url' => $url,
                'info' => $response,
            );
        }) ();
    }

    public function fetch_time($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches the current integer timestamp in milliseconds from the exchange server
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {int} the current integer timestamp in milliseconds from the exchange server
             */
            $options = $this->safe_value($this->options, 'fetchTime', array());
            $defaultType = $this->safe_string($this->options, 'defaultType', 'spot');
            $type = $this->safe_string($options, 'type', $defaultType);
            $type = $this->safe_string($params, 'type', $type);
            $method = 'spotPublicGetV1CommonTimestamp';
            if (($type === 'future') || ($type === 'swap')) {
                $method = 'contractPublicGetApiV1Timestamp';
            }
            $response = Async\await($this->$method ($params));
            //
            // spot
            //
            //     array("status":"ok","data":1637504261099)
            //
            // future, swap
            //
            //     array("status":"ok","ts":1637504164707)
            //
            return $this->safe_integer_2($response, 'data', 'ts');
        }) ();
    }

    public function parse_trading_fee($fee, $market = null) {
        //
        //     {
        //         "symbol":"btcusdt",
        //         "actualMakerRate":"0.002",
        //         "actualTakerRate":"0.002",
        //         "takerFeeRate":"0.002",
        //         "makerFeeRate":"0.002"
        //     }
        //
        $marketId = $this->safe_string($fee, 'symbol');
        return array(
            'info' => $fee,
            'symbol' => $this->safe_symbol($marketId, $market),
            'maker' => $this->safe_number($fee, 'actualMakerRate'),
            'taker' => $this->safe_number($fee, 'actualTakerRate'),
        );
    }

    public function fetch_trading_fee(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch the trading fees for a $market
             * @param {string} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=fee-structure fee structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbols' => $market['id'], // trading symbols comma-separated
            );
            $response = Async\await($this->spotPrivateGetV2ReferenceTransactFeeRate (array_merge($request, $params)));
            //
            //     {
            //         "code":200,
            //         "data":array(
            //             {
            //                 "symbol":"btcusdt",
            //                 "actualMakerRate":"0.002",
            //                 "actualTakerRate":"0.002",
            //                 "takerFeeRate":"0.002",
            //                 "makerFeeRate":"0.002"
            //             }
            //         ),
            //         "success":true
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $first = $this->safe_value($data, 0, array());
            return $this->parse_trading_fee($first, $market);
        }) ();
    }

    public function fetch_trading_limits(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            // this method should not be called directly, use loadTradingLimits () instead
            //  by default it will try load withdrawal fees of all currencies (with separate requests)
            //  however if you define $symbols = array( 'ETH/BTC', 'LTC/BTC' ) in args it will only load those
            Async\await($this->load_markets());
            if ($symbols === null) {
                $symbols = $this->symbols;
            }
            $result = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $result[$symbol] = Async\await($this->fetch_trading_limits_by_id($this->market_id($symbol), $params));
            }
            return $result;
        }) ();
    }

    public function fetch_trading_limits_by_id(string $id, $params = array ()) {
        return Async\async(function () use ($id, $params) {
            $request = array(
                'symbol' => $id,
            );
            $response = Async\await($this->spotPublicGetV1CommonExchange (array_merge($request, $params)));
            //
            //     { status =>   "ok",
            //         data => {                                  symbol => "aidocbtc",
            //                              'buy-limit-must-less-than' =>  1.1,
            //                          'sell-limit-must-greater-than' =>  0.9,
            //                         'limit-order-must-greater-than' =>  1,
            //                            'limit-order-must-less-than' =>  5000000,
            //                    'market-buy-order-must-greater-than' =>  0.0001,
            //                       'market-buy-order-must-less-than' =>  100,
            //                   'market-sell-order-must-greater-than' =>  1,
            //                      'market-sell-order-must-less-than' =>  500000,
            //                       'circuit-break-when-greater-than' =>  10000,
            //                          'circuit-break-when-less-than' =>  10,
            //                 'market-sell-order-rate-must-less-than' =>  0.1,
            //                  'market-buy-order-rate-must-less-than' =>  0.1        } }
            //
            return $this->parse_trading_limits($this->safe_value($response, 'data', array()));
        }) ();
    }

    public function parse_trading_limits($limits, ?string $symbol = null, $params = array ()) {
        //
        //   {                                  $symbol => "aidocbtc",
        //                  'buy-limit-must-less-than' =>  1.1,
        //              'sell-limit-must-greater-than' =>  0.9,
        //             'limit-order-must-greater-than' =>  1,
        //                'limit-order-must-less-than' =>  5000000,
        //        'market-buy-order-must-greater-than' =>  0.0001,
        //           'market-buy-order-must-less-than' =>  100,
        //       'market-sell-order-must-greater-than' =>  1,
        //          'market-sell-order-must-less-than' =>  500000,
        //           'circuit-break-when-greater-than' =>  10000,
        //              'circuit-break-when-less-than' =>  10,
        //     'market-sell-order-rate-must-less-than' =>  0.1,
        //      'market-buy-order-rate-must-less-than' =>  0.1        }
        //
        return array(
            'info' => $limits,
            'limits' => array(
                'amount' => array(
                    'min' => $this->safe_number($limits, 'limit-order-must-greater-than'),
                    'max' => $this->safe_number($limits, 'limit-order-must-less-than'),
                ),
            ),
        );
    }

    public function cost_to_precision($symbol, $cost) {
        return $this->decimal_to_precision($cost, TRUNCATE, $this->markets[$symbol]['precision']['cost'], $this->precisionMode);
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all markets for huobi
             * @param {array} $params extra parameters specific to the exchange api endpoint
             * @return {[array]} an array of objects representing market data
             */
            $options = $this->safe_value($this->options, 'fetchMarkets', array());
            $types = $this->safe_value($options, 'types', array());
            $allMarkets = array();
            $promises = array();
            $keys = is_array($types) ? array_keys($types) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $type = $keys[$i];
                $value = $this->safe_value($types, $type);
                if ($value === true) {
                    $promises[] = $this->fetch_markets_by_type_and_sub_type($type, null, $params);
                } elseif ($value) {
                    $subKeys = is_array($value) ? array_keys($value) : array();
                    for ($j = 0; $j < count($subKeys); $j++) {
                        $subType = $subKeys[$j];
                        $subValue = $this->safe_value($value, $subType);
                        if ($subValue) {
                            $promises[] = $this->fetch_markets_by_type_and_sub_type($type, $subType, $params);
                        }
                    }
                }
            }
            $promises = Async\await(Promise\all($promises));
            for ($i = 0; $i < count($promises); $i++) {
                $allMarkets = $this->array_concat($allMarkets, $promises[$i]);
            }
            return $allMarkets;
        }) ();
    }

    public function fetch_markets_by_type_and_sub_type($type, $subType, $params = array ()) {
        return Async\async(function () use ($type, $subType, $params) {
            $method = 'spotPublicGetV1CommonSymbols';
            $query = $this->omit($params, array( 'type', 'subType' ));
            $spot = ($type === 'spot');
            $contract = ($type !== 'spot');
            $future = ($type === 'future');
            $swap = ($type === 'swap');
            $linear = null;
            $inverse = null;
            $request = array();
            if ($contract) {
                $linear = ($subType === 'linear');
                $inverse = ($subType === 'inverse');
                if ($linear) {
                    $method = 'contractPublicGetLinearSwapApiV1SwapContractInfo';
                    if ($future) {
                        $request['business_type'] = 'futures';
                    }
                } elseif ($inverse) {
                    if ($future) {
                        $method = 'contractPublicGetApiV1ContractContractInfo';
                    } elseif ($swap) {
                        $method = 'contractPublicGetSwapApiV1SwapContractInfo';
                    }
                }
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            //
            // $spot
            //
            //     {
            //         "status":"ok",
            //         "data":array(
            //             array(
            //                 "base-currency":"xrp3s",
            //                 "quote-currency":"usdt",
            //                 "price-precision":4,
            //                 "amount-precision":4,
            //                 "symbol-partition":"innovation",
            //                 "symbol":"xrp3susdt",
            //                 "state":"online",
            //                 "value-precision":8,
            //                 "min-order-amt":0.01,
            //                 "max-order-amt":1616.4353,
            //                 "min-order-value":5,
            //                 "limit-order-min-order-amt":0.01,
            //                 "limit-order-max-order-amt":1616.4353,
            //                 "limit-order-max-buy-amt":1616.4353,
            //                 "limit-order-max-sell-amt":1616.4353,
            //                 "sell-$market-min-order-amt":0.01,
            //                 "sell-$market-max-order-amt":1616.4353,
            //                 "buy-$market-max-order-value":2500,
            //                 "max-order-value":2500,
            //                 "underlying":"xrpusdt",
            //                 "mgmt-fee-rate":0.035000000000000000,
            //                 "charge-time":"23:55:00",
            //                 "rebal-time":"00:00:00",
            //                 "rebal-threshold":-5,
            //                 "init-nav":10.000000000000000000,
            //                 "api-trading":"enabled",
            //                 "tags":"etp,nav,holdinglimit"
            //             ),
            //         )
            //     }
            //
            // $inverse $future
            //
            //     {
            //         "status":"ok",
            //         "data":array(
            //             array(
            //                 "symbol":"BTC",
            //                 "contract_code":"BTC211126",
            //                 "contract_type":"this_week",
            //                 "contract_size":100.000000000000000000,
            //                 "price_tick":0.010000000000000000,
            //                 "delivery_date":"20211126",
            //                 "delivery_time":"1637913600000",
            //                 "create_date":"20211112",
            //                 "contract_status":1,
            //                 "settlement_time":"1637481600000"
            //             ),
            //         ),
            //         "ts":1637474595140
            //     }
            //
            // $linear futures
            //
            //     {
            //         "status":"ok",
            //         "data":array(
            //             array(
            //                 "symbol":"BTC",
            //                 "contract_code":"BTC-USDT-211231",
            //                 "contract_size":0.001000000000000000,
            //                 "price_tick":0.100000000000000000,
            //                 "delivery_date":"20211231",
            //                 "delivery_time":"1640937600000",
            //                 "create_date":"20211228",
            //                 "contract_status":1,
            //                 "settlement_date":"1640764800000",
            //                 "support_margin_mode":"cross",
            //                 "business_type":"futures",
            //                 "pair":"BTC-USDT",
            //                 "contract_type":"this_week" // next_week, quarter
            //             ),
            //         ),
            //         "ts":1640736207263
            //     }
            //
            // swaps
            //
            //     {
            //         "status":"ok",
            //         "data":array(
            //             array(
            //                 "symbol":"BTC",
            //                 "contract_code":"BTC-USDT",
            //                 "contract_size":0.001000000000000000,
            //                 "price_tick":0.100000000000000000,
            //                 "delivery_time":"",
            //                 "create_date":"20201021",
            //                 "contract_status":1,
            //                 "settlement_date":"1637481600000",
            //                 "support_margin_mode":"all", // isolated
            //             ),
            //         ),
            //         "ts":1637474774467
            //     }
            //
            $markets = $this->safe_value($response, 'data', array());
            $numMarkets = count($markets);
            if ($numMarkets < 1) {
                throw new NetworkError($this->id . ' fetchMarkets() returned an empty $response => ' . $this->json($markets));
            }
            $result = array();
            for ($i = 0; $i < count($markets); $i++) {
                $market = $markets[$i];
                $baseId = null;
                $quoteId = null;
                $settleId = null;
                $id = null;
                $lowercaseId = null;
                $lowercaseBaseId = null;
                if ($contract) {
                    $id = $this->safe_string($market, 'contract_code');
                    $lowercaseId = strtolower($id);
                    if ($swap) {
                        $parts = explode('-', $id);
                        $baseId = $this->safe_string($market, 'symbol');
                        $lowercaseBaseId = strtolower($baseId);
                        $quoteId = $this->safe_string_lower($parts, 1);
                        $settleId = $inverse ? $baseId : $quoteId;
                    } elseif ($future) {
                        $baseId = $this->safe_string($market, 'symbol');
                        $lowercaseBaseId = strtolower($baseId);
                        if ($inverse) {
                            $quoteId = 'USD';
                            $settleId = $baseId;
                        } else {
                            $pair = $this->safe_string($market, 'pair');
                            $parts = explode('-', $pair);
                            $quoteId = $this->safe_string($parts, 1);
                            $settleId = $quoteId;
                        }
                    }
                } else {
                    $baseId = $this->safe_string($market, 'base-currency');
                    $lowercaseBaseId = strtolower($baseId);
                    $quoteId = $this->safe_string($market, 'quote-currency');
                    $id = $baseId . $quoteId;
                    $lowercaseId = strtolower($id);
                }
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $settle = $this->safe_currency_code($settleId);
                $symbol = $base . '/' . $quote;
                $expiry = null;
                if ($contract) {
                    if ($inverse) {
                        $symbol .= ':' . $base;
                    } elseif ($linear) {
                        $symbol .= ':' . $quote;
                    }
                    if ($future) {
                        $expiry = $this->safe_integer($market, 'delivery_time');
                        $symbol .= '-' . $this->yymmdd($expiry);
                    }
                }
                $contractSize = $this->safe_number($market, 'contract_size');
                $minCost = $this->safe_number($market, 'min-order-value');
                $maxAmount = $this->safe_number($market, 'max-order-amt');
                $minAmount = $this->safe_number($market, 'min-order-amt');
                if ($contract) {
                    if ($linear) {
                        $minAmount = $contractSize;
                    } elseif ($inverse) {
                        $minCost = $contractSize;
                    }
                }
                $pricePrecision = null;
                $amountPrecision = null;
                $costPrecision = null;
                if ($spot) {
                    $pricePrecision = $this->parse_number($this->parse_precision($this->safe_string($market, 'price-precision')));
                    $amountPrecision = $this->parse_number($this->parse_precision($this->safe_string($market, 'amount-precision')));
                    $costPrecision = $this->parse_number($this->parse_precision($this->safe_string($market, 'value-precision')));
                } else {
                    $pricePrecision = $this->safe_number($market, 'price_tick');
                    $amountPrecision = $this->parse_number('1'); // other $markets have step size of 1 $contract
                }
                $maker = null;
                $taker = null;
                if ($spot) {
                    $maker = ($base === 'OMG') ? $this->parse_number('0') : $this->parse_number('0.002');
                    $taker = ($base === 'OMG') ? $this->parse_number('0') : $this->parse_number('0.002');
                }
                $active = null;
                if ($spot) {
                    $state = $this->safe_string($market, 'state');
                    $active = ($state === 'online');
                } elseif ($contract) {
                    $contractStatus = $this->safe_integer($market, 'contract_status');
                    $active = ($contractStatus === 1);
                }
                $leverageRatio = $this->safe_string($market, 'leverage-ratio', '1');
                $superLeverageRatio = $this->safe_string($market, 'super-margin-leverage-ratio', '1');
                $hasLeverage = Precise::string_gt($leverageRatio, '1') || Precise::string_gt($superLeverageRatio, '1');
                // 0 Delisting
                // 1 Listing
                // 2 Pending Listing
                // 3 Suspension
                // 4 Suspending of Listing
                // 5 In Settlement
                // 6 Delivering
                // 7 Settlement Completed
                // 8 Delivered
                // 9 Suspending of Trade
                $result[] = array(
                    'id' => $id,
                    'lowercaseId' => $lowercaseId,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => $settle,
                    'baseId' => $baseId,
                    'lowercaseBaseId' => $lowercaseBaseId,
                    'quoteId' => $quoteId,
                    'settleId' => $settleId,
                    'type' => $type,
                    'spot' => $spot,
                    'margin' => ($spot && $hasLeverage),
                    'swap' => $swap,
                    'future' => $future,
                    'option' => false,
                    'active' => $active,
                    'contract' => $contract,
                    'linear' => $linear,
                    'inverse' => $inverse,
                    'taker' => $taker,
                    'maker' => $maker,
                    'contractSize' => $contractSize,
                    'expiry' => $expiry,
                    'expiryDatetime' => $this->iso8601($expiry),
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $amountPrecision,
                        'price' => $pricePrecision,
                        'cost' => $costPrecision,
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => $this->parse_number('1'),
                            'max' => $this->parse_number($leverageRatio),
                            'superMax' => $this->parse_number($superLeverageRatio),
                        ),
                        'amount' => array(
                            'min' => $minAmount,
                            'max' => $maxAmount,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => $minCost,
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function parse_ticker($ticker, $market = null) {
        //
        // fetchTicker
        //
        //     {
        //         "amount" => 26228.672978342216,
        //         "open" => 9078.95,
        //         "close" => 9146.86,
        //         "high" => 9155.41,
        //         "id" => 209988544334,
        //         "count" => 265846,
        //         "low" => 8988.0,
        //         "version" => 209988544334,
        //         "ask" => array( 9146.87, 0.156134 ),
        //         "vol" => 2.3822168242201668E8,
        //         "bid" => array( 9146.86, 0.080758 ),
        //     }
        //
        // fetchTickers
        //
        //     {
        //         $symbol => "bhdht",
        //         $open =>  2.3938,
        //         high =>  2.4151,
        //         low =>  2.3323,
        //         $close =>  2.3909,
        //         amount =>  628.992,
        //         vol =>  1493.71841095,
        //         count =>  2088,
        //         $bid =>  2.3643,
        //         bidSize =>  0.7136,
        //         $ask =>  2.4061,
        //         askSize =>  0.4156
        //     }
        //
        // watchTikcer - bbo
        //     {
        //         seqId => 161499562790,
        //         $ask => 16829.51,
        //         askSize => 0.707776,
        //         $bid => 16829.5,
        //         bidSize => 1.685945,
        //         quoteTime => 1671941599612,
        //         $symbol => 'btcusdt'
        //     }
        //
        $marketId = $this->safe_string_2($ticker, 'symbol', 'contract_code');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer_2($ticker, 'ts', 'quoteTime');
        $bid = null;
        $bidVolume = null;
        $ask = null;
        $askVolume = null;
        if (is_array($ticker) && array_key_exists('bid', $ticker)) {
            if (gettype($ticker['bid']) === 'array' && array_keys($ticker['bid']) === array_keys(array_keys($ticker['bid']))) {
                $bid = $this->safe_string($ticker['bid'], 0);
                $bidVolume = $this->safe_string($ticker['bid'], 1);
            } else {
                $bid = $this->safe_string($ticker, 'bid');
                $bidVolume = $this->safe_string($ticker, 'bidSize');
            }
        }
        if (is_array($ticker) && array_key_exists('ask', $ticker)) {
            if (gettype($ticker['ask']) === 'array' && array_keys($ticker['ask']) === array_keys(array_keys($ticker['ask']))) {
                $ask = $this->safe_string($ticker['ask'], 0);
                $askVolume = $this->safe_string($ticker['ask'], 1);
            } else {
                $ask = $this->safe_string($ticker, 'ask');
                $askVolume = $this->safe_string($ticker, 'askSize');
            }
        }
        $open = $this->safe_string($ticker, 'open');
        $close = $this->safe_string($ticker, 'close');
        $baseVolume = $this->safe_string($ticker, 'amount');
        $quoteVolume = $this->safe_string($ticker, 'vol');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => $bid,
            'bidVolume' => $bidVolume,
            'ask' => $ask,
            'askVolume' => $askVolume,
            'vwap' => null,
            'open' => $open,
            'close' => $close,
            'last' => $close,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ticker(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array();
            $fieldName = 'symbol';
            $method = 'spotPublicGetMarketDetailMerged';
            if ($market['linear']) {
                $method = 'contractPublicGetLinearSwapExMarketDetailMerged';
                $fieldName = 'contract_code';
            } elseif ($market['inverse']) {
                if ($market['future']) {
                    $method = 'contractPublicGetMarketDetailMerged';
                } elseif ($market['swap']) {
                    $method = 'contractPublicGetSwapExMarketDetailMerged';
                    $fieldName = 'contract_code';
                }
            }
            $request[$fieldName] = $market['id'];
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "status" => "ok",
            //         "ch" => "market.btcusdt.detail.merged",
            //         "ts" => 1583494336669,
            //         "tick" => {
            //             "amount" => 26228.672978342216,
            //             "open" => 9078.95,
            //             "close" => 9146.86,
            //             "high" => 9155.41,
            //             "id" => 209988544334,
            //             "count" => 265846,
            //             "low" => 8988.0,
            //             "version" => 209988544334,
            //             "ask" => array( 9146.87, 0.156134 ),
            //             "vol" => 2.3822168242201668E8,
            //             "bid" => array( 9146.86, 0.080758 ),
            //         }
            //     }
            //
            // future, swap
            //
            //     {
            //         "ch":"market.BTC211126.detail.merged",
            //         "status":"ok",
            //         "tick":array(
            //             "amount":"669.3385682049668320322569544150680718474",
            //             "ask":[59117.44,48],
            //             "bid":[59082,48],
            //             "close":"59087.97",
            //             "count":5947,
            //             "high":"59892.62",
            //             "id":1637502670,
            //             "low":"57402.87",
            //             "open":"57638",
            //             "ts":1637502670059,
            //             "vol":"394598"
            //         ),
            //         "ts":1637502670059
            //     }
            //
            $tick = $this->safe_value($response, 'tick', array());
            $ticker = $this->parse_ticker($tick, $market);
            $timestamp = $this->safe_integer($response, 'ts');
            $ticker['timestamp'] = $timestamp;
            $ticker['datetime'] = $this->iso8601($timestamp);
            return $ticker;
        }) ();
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price $tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each $market
             * @see https://huobiapi.github.io/docs/spot/v1/en/#get-latest-$tickers-for-all-pairs
             * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-a-batch-of-$market-data-overview
             * @see https://huobiapi.github.io/docs/dm/v1/en/#get-a-batch-of-$market-data-overview
             * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-a-batch-of-$market-data-overview-v2
             * @param {[string]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all $market $tickers are returned if not assigned
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $first = $this->safe_string($symbols, 0);
            $market = null;
            if ($first !== null) {
                $market = $this->market($first);
            }
            $type = null;
            $subType = null;
            $method = 'spotPublicGetMarketTickers';
            list($type, $params) = $this->handle_market_type_and_params('fetchTickers', $market, $params);
            list($subType, $params) = $this->handle_sub_type_and_params('fetchTickers', $market, $params);
            $request = array();
            $future = ($type === 'future');
            $swap = ($type === 'swap');
            $linear = ($subType === 'linear');
            $inverse = ($subType === 'inverse');
            if ($future || $swap) {
                if ($linear) {
                    $method = 'contractPublicGetLinearSwapExMarketDetailBatchMerged';
                    if ($future) {
                        $request['business_type'] = 'futures';
                    }
                } elseif ($inverse) {
                    if ($future) {
                        $method = 'contractPublicGetMarketDetailBatchMerged';
                    } elseif ($swap) {
                        $method = 'contractPublicGetSwapExMarketDetailBatchMerged';
                    }
                }
            }
            $params = $this->omit($params, array( 'type', 'subType' ));
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "data":array(
            //             array(
            //                 "symbol":"hbcbtc",
            //                 "open":5.313E-5,
            //                 "high":5.34E-5,
            //                 "low":5.112E-5,
            //                 "close":5.175E-5,
            //                 "amount":1183.87,
            //                 "vol":0.0618599229,
            //                 "count":205,
            //                 "bid":5.126E-5,
            //                 "bidSize":5.25,
            //                 "ask":5.214E-5,
            //                 "askSize":150.0
            //             ),
            //         ),
            //         "status":"ok",
            //         "ts":1639547261293
            //     }
            //
            // $inverse swaps, $linear swaps, $inverse futures
            //
            //     {
            //         "status":"ok",
            //         "ticks":[
            //             {
            //                 "id":1637504679,
            //                 "ts":1637504679372,
            //                 "ask":[0.10644,100],
            //                 "bid":[0.10624,26],
            //                 "symbol":"TRX_CW",
            //                 "open":"0.10233",
            //                 "close":"0.10644",
            //                 "low":"0.1017",
            //                 "high":"0.10725",
            //                 "amount":"2340267.415144052378486261756692535687481566",
            //                 "count":882,
            //                 "vol":"24706"
            //             }
            //         ],
            //         "ts":1637504679376
            //     }
            //
            // $linear futures
            //
            //     {
            //         "status":"ok",
            //         "ticks":[
            //             {
            //                 "id":1640745627,
            //                 "ts":1640745627957,
            //                 "ask":[48079.1,20],
            //                 "bid":[47713.8,125],
            //                 "business_type":"futures",
            //                 "contract_code":"BTC-USDT-CW",
            //                 "open":"49011.8",
            //                 "close":"47934",
            //                 "low":"47292.3",
            //                 "high":"49011.8",
            //                 "amount":"17.398",
            //                 "count":1515,
            //                 "vol":"17398",
            //                 "trade_turnover":"840726.5048"
            //             }
            //         ],
            //         "ts":1640745627988
            //     }
            //
            $tickers = $this->safe_value_2($response, 'data', 'ticks', array());
            $timestamp = $this->safe_integer($response, 'ts');
            $result = array();
            for ($i = 0; $i < count($tickers); $i++) {
                $ticker = $this->parse_ticker($tickers[$i]);
                // the $market ids for $linear futures are non-standard and differ from all the other endpoints
                // we are doing a $linear-matching here
                if ($future && $linear) {
                    for ($j = 0; $j < count($this->symbols); $j++) {
                        $symbol = $this->symbols[$j];
                        $market = $this->market($symbol);
                        $contractType = $this->safe_string($market['info'], 'contract_type');
                        if (($contractType === 'this_week') && ($ticker['symbol'] === ($market['baseId'] . '-' . $market['quoteId'] . '-CW'))) {
                            $ticker['symbol'] = $market['symbol'];
                            break;
                        } elseif (($contractType === 'next_week') && ($ticker['symbol'] === ($market['baseId'] . '-' . $market['quoteId'] . '-NW'))) {
                            $ticker['symbol'] = $market['symbol'];
                            break;
                        } elseif (($contractType === 'this_quarter') && ($ticker['symbol'] === ($market['baseId'] . '-' . $market['quoteId'] . '-CQ'))) {
                            $ticker['symbol'] = $market['symbol'];
                            break;
                        } elseif (($contractType === 'next_quarter') && ($ticker['symbol'] === ($market['baseId'] . '-' . $market['quoteId'] . '-NQ'))) {
                            $ticker['symbol'] = $market['symbol'];
                            break;
                        }
                    }
                }
                $symbol = $ticker['symbol'];
                $ticker['timestamp'] = $timestamp;
                $ticker['datetime'] = $this->iso8601($timestamp);
                $result[$symbol] = $ticker;
            }
            return $this->filter_by_array($result, 'symbol', $symbols);
        }) ();
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                //
                // from the API docs
                //
                //     to get depth data within step 150, use step0, step1, step2, step3, step4, step5, step14, step15（merged depth data 0-5,14-15, when step is 0，depth data will not be merged
                //     to get depth data within step 20, use step6, step7, step8, step9, step10, step11, step12, step13(merged depth data 7-13), when step is 6, depth data will not be merged
                //
                'type' => 'step0',
                // 'symbol' => $market['id'], // spot, future
                // 'contract_code' => $market['id'], // swap
            );
            $fieldName = 'symbol';
            $method = 'spotPublicGetMarketDepth';
            if ($market['linear']) {
                $method = 'contractPublicGetLinearSwapExMarketDepth';
                $fieldName = 'contract_code';
            } elseif ($market['inverse']) {
                if ($market['future']) {
                    $method = 'contractPublicGetMarketDepth';
                } elseif ($market['swap']) {
                    $method = 'contractPublicGetSwapExMarketDepth';
                    $fieldName = 'contract_code';
                }
            } else {
                if ($limit !== null) {
                    // Valid depths are 5, 10, 20 or empty https://huobiapi.github.io/docs/spot/v1/en/#get-$market-depth
                    if (($limit !== 5) && ($limit !== 10) && ($limit !== 20) && ($limit !== 150)) {
                        throw new BadRequest($this->id . ' fetchOrderBook() $limit argument must be null, 5, 10, 20, or 150, default is 150');
                    }
                    // only set the depth if it is not 150
                    // 150 is the implicit default on the exchange side for step0 and no orderbook aggregation
                    // it is not accepted by the exchange if you set it explicitly
                    if ($limit !== 150) {
                        $request['depth'] = $limit;
                    }
                }
            }
            $request[$fieldName] = $market['id'];
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot, future, swap
            //
            //     {
            //         "status" => "ok",
            //         "ch" => "market.btcusdt.depth.step0",
            //         "ts" => 1583474832790,
            //         "tick" => {
            //             "bids" => array(
            //                 array( 9100.290000000000000000, 0.200000000000000000 ),
            //                 array( 9099.820000000000000000, 0.200000000000000000 ),
            //                 array( 9099.610000000000000000, 0.205000000000000000 ),
            //             ),
            //             "asks" => array(
            //                 array( 9100.640000000000000000, 0.005904000000000000 ),
            //                 array( 9101.010000000000000000, 0.287311000000000000 ),
            //                 array( 9101.030000000000000000, 0.012121000000000000 ),
            //             ),
            //             "ch":"market.BTC-USD.depth.step0",
            //             "ts":1583474832008,
            //             "id":1637554816,
            //             "mrid":121654491624,
            //             "version":104999698781
            //         }
            //     }
            //
            if (is_array($response) && array_key_exists('tick', $response)) {
                if (!$response['tick']) {
                    throw new BadSymbol($this->id . ' fetchOrderBook() returned empty $response => ' . $this->json($response));
                }
                $tick = $this->safe_value($response, 'tick');
                $timestamp = $this->safe_integer($tick, 'ts', $this->safe_integer($response, 'ts'));
                $result = $this->parse_order_book($tick, $symbol, $timestamp);
                $result['nonce'] = $this->safe_integer($tick, 'version');
                return $result;
            }
            throw new ExchangeError($this->id . ' fetchOrderBook() returned unrecognized $response => ' . $this->json($response));
        }) ();
    }

    public function parse_trade($trade, $market = null) {
        //
        // spot fetchTrades (public)
        //
        //     {
        //         "amount" => 0.010411000000000000,
        //         "trade-$id" => 102090736910,
        //         "ts" => 1583497692182,
        //         "id" => 10500517034273194594947,
        //         "price" => 9096.050000000000000000,
        //         "direction" => "sell"
        //     }
        //
        // spot fetchMyTrades (private)
        //
        //     {
        //          'symbol' => 'swftcbtc',
        //          'fee-currency' => 'swftc',
        //          'filled-fees' => '0',
        //          'source' => 'spot-api',
        //          'id' => 83789509854000,
        //          'type' => 'buy-limit',
        //          'order-id' => 83711103204909,
        //          'filled-points' => '0.005826843283532154',
        //          'fee-deduct-currency' => 'ht',
        //          'filled-amount' => '45941.53',
        //          'price' => '0.0000001401',
        //          'created-at' => 1597933260729,
        //          'match-id' => 100087455560,
        //          'role' => 'maker',
        //          'trade-id' => 100050305348
        //     }
        //
        // linear swap isolated margin fetchOrder details
        //
        //     {
        //         "trade_id" => 131560927,
        //         "trade_price" => 13059.800000000000000000,
        //         "trade_volume" => 1.000000000000000000,
        //         "trade_turnover" => 13.059800000000000000,
        //         "trade_fee" => -0.005223920000000000,
        //         "created_at" => 1603703614715,
        //         "role" => "taker",
        //         "fee_asset" => "USDT",
        //         "profit" => 0,
        //         "real_profit" => 0,
        //         "id" => "131560927-770334322963152896-1"
        //     }
        //
        // inverse swap cross margin fetchMyTrades
        //
        //     {
        //         "contract_type":"swap",
        //         "pair":"O3-USDT",
        //         "business_type":"swap",
        //         "query_id":652123190,
        //         "match_id":28306009409,
        //         "order_id":941137865226903553,
        //         "symbol":"O3",
        //         "contract_code":"O3-USDT",
        //         "direction":"sell",
        //         "offset":"open",
        //         "trade_volume":100.000000000000000000,
        //         "trade_price":0.398500000000000000,
        //         "trade_turnover":39.850000000000000000,
        //         "trade_fee":-0.007970000000000000,
        //         "offset_profitloss":0E-18,
        //         "create_date":1644426352999,
        //         "role":"Maker",
        //         "order_source":"api",
        //         "order_id_str":"941137865226903553",
        //         "id":"28306009409-941137865226903553-1",
        //         "fee_asset":"USDT",
        //         "margin_mode":"cross",
        //         "margin_account":"USDT",
        //         "real_profit":0E-18,
        //         "trade_partition":"USDT"
        //     }
        //
        $marketId = $this->safe_string_2($trade, 'contract_code', 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer_2($trade, 'ts', 'created-at');
        $timestamp = $this->safe_integer_2($trade, 'created_at', 'create_date', $timestamp);
        $order = $this->safe_string_2($trade, 'order-id', 'order_id');
        $side = $this->safe_string($trade, 'direction');
        $type = $this->safe_string($trade, 'type');
        if ($type !== null) {
            $typeParts = explode('-', $type);
            $side = $typeParts[0];
            $type = $typeParts[1];
        }
        $takerOrMaker = $this->safe_string_lower($trade, 'role');
        $priceString = $this->safe_string_2($trade, 'price', 'trade_price');
        $amountString = $this->safe_string_2($trade, 'filled-amount', 'amount');
        $amountString = $this->safe_string($trade, 'trade_volume', $amountString);
        $costString = $this->safe_string($trade, 'trade_turnover');
        $fee = null;
        $feeCost = $this->safe_string_2($trade, 'filled-fees', 'trade_fee');
        $feeCurrencyId = $this->safe_string_2($trade, 'fee-currency', 'fee_asset');
        $feeCurrency = $this->safe_currency_code($feeCurrencyId);
        $filledPoints = $this->safe_string($trade, 'filled-points');
        if ($filledPoints !== null) {
            if (($feeCost === null) || Precise::string_equals($feeCost, '0')) {
                $feeDeductCurrency = $this->safe_string($trade, 'fee-deduct-currency');
                if ($feeDeductCurrency !== null) {
                    $feeCost = $filledPoints;
                    $feeCurrency = $this->safe_currency_code($feeDeductCurrency);
                }
            }
        }
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrency,
            );
        }
        $tradeId = $this->safe_string_2($trade, 'trade-id', 'tradeId');
        $id = $this->safe_string_2($trade, 'trade_id', 'id', $tradeId);
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'order' => $order,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $costString,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_order_trades(string $id, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $since, $limit, $params) {
            /**
             * fetch all the trades made from a single order
             * @param {string} $id order $id
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch trades for
             * @param {int|null} $limit the maximum number of trades to retrieve
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?$id=trade-structure trade structures~
             */
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('fetchOrderTrades', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'fetchSpotOrderTrades',
                // 'swap' => 'fetchContractOrderTrades',
                // 'future' => 'fetchContractOrderTrades',
            ));
            return Async\await($this->$method ($id, $symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_spot_order_trades(string $id, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $request = array(
                'order-id' => $id,
            );
            $response = Async\await($this->spotPrivateGetV1OrderOrdersOrderIdMatchresults (array_merge($request, $params)));
            return $this->parse_trades($response['data'], null, $since, $limit);
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all $trades made by the user
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch $trades for
             * @param {int|null} $limit the maximum number of $trades structures to retrieve
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('fetchMyTrades', $market, $params);
            $request = array(
                // spot -----------------------------------------------------------
                // 'symbol' => $market['id'],
                // 'types' => 'buy-$market,sell-$market,buy-$limit,sell-$limit,buy-ioc,sell-ioc,buy-$limit-maker,sell-$limit-maker,buy-stop-$limit,sell-stop-limit',
                // 'start-time' => $since, // max 48 hours within 120 days
                // 'end-time' => $this->milliseconds(), // max 48 hours within 120 days
                // 'from' => 'id', // tring false N/A Search internal id to begin with if search next page, then this should be the last id (not trade-id) of last page; if search previous page, then this should be the first id (not trade-id) of last page
                // 'direct' => 'next', // next, prev
                // 'size' => $limit, // default 100, max 500 The number of orders to return [1-500]
                // contracts ------------------------------------------------------
                // 'symbol' => $market['settleId'], // required
                // 'trade_type' => 0, // required, 0 all, 1 open long, 2 open short, 3 close short, 4 close long, 5 liquidate long positions, 6 liquidate short positions
                // 'contract_code' => $market['id'],
                // 'start_time' => $since, // max 48 hours within 120 days
                // 'end_time' => $this->milliseconds(), // max 48 hours within 120 days
                // 'from_id' => 'id', // tring false N/A Search internal id to begin with if search next page, then this should be the last id (not trade-id) of last page; if search previous page, then this should be the first id (not trade-id) of last page
                // 'direct' => 'prev', // next, prev
                // 'size' => $limit, // default 20, max 50
            );
            $method = null;
            if ($marketType === 'spot') {
                if ($symbol !== null) {
                    $market = $this->market($symbol);
                    $request['symbol'] = $market['id'];
                }
                if ($limit !== null) {
                    $request['size'] = $limit; // default 100, max 500
                }
                if ($since !== null) {
                    $request['start-time'] = $since; // a date within 120 days from today
                    // $request['end-time'] = $this->sum($since, 172800000); // 48 hours window
                }
                $method = 'spotPrivateGetV1OrderMatchresults';
            } else {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol for ' . $marketType . ' orders');
                }
                $request['contract'] = $market['id'];
                $request['trade_type'] = 0; // 0 all, 1 open long, 2 open short, 3 close short, 4 close long, 5 liquidate long positions, 6 liquidate short positions
                if ($since !== null) {
                    $request['start_time'] = $since; // a date within 120 days from today
                    // $request['end_time'] = $this->sum($request['start_time'], 172800000); // 48 hours window
                }
                if ($limit !== null) {
                    $request['page_size'] = $limit; // default 100, max 500
                }
                if ($market['linear']) {
                    $marginMode = null;
                    list($marginMode, $params) = $this->handle_margin_mode_and_params('fetchMyTrades', $params);
                    $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
                    if ($marginMode === 'isolated') {
                        $method = 'contractPrivatePostLinearSwapApiV3SwapMatchresultsExact';
                    } elseif ($marginMode === 'cross') {
                        $method = 'contractPrivatePostLinearSwapApiV3SwapCrossMatchresultsExact';
                    }
                } elseif ($market['inverse']) {
                    if ($marketType === 'future') {
                        $method = 'contractPrivatePostApiV3ContractMatchresultsExact';
                        $request['symbol'] = $market['settleId'];
                    } elseif ($marketType === 'swap') {
                        $method = 'contractPrivatePostSwapApiV3SwapMatchresultsExact';
                    } else {
                        throw new NotSupported($this->id . ' fetchMyTrades() does not support ' . $marketType . ' markets');
                    }
                }
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             {
            //                 "symbol" => "polyusdt",
            //                 "fee-currency" => "poly",
            //                 "source" => "spot-web",
            //                 "price" => "0.338",
            //                 "created-at" => 1629443051839,
            //                 "role" => "taker",
            //                 "order-id" => 345487249132375,
            //                 "match-id" => 5014,
            //                 "trade-id" => 1085,
            //                 "filled-amount" => "147.928994082840236",
            //                 "filled-fees" => "0",
            //                 "filled-points" => "0.1",
            //                 "fee-deduct-currency" => "hbpoint",
            //                 "fee-deduct-state" => "done",
            //                 "id" => 313288753120940,
            //                 "type" => "buy-$market"
            //             }
            //         )
            //     }
            //
            // contracts
            //
            //     {
            //         "status" => "ok",
            //         "data" => {
            //             "trades" => array(
            //                 array(
            //                     "query_id" => 2424420723,
            //                     "match_id" => 113891764710,
            //                     "order_id" => 773135295142658048,
            //                     "symbol" => "ADA",
            //                     "contract_type" => "quarter", // swap
            //                     "business_type" => "futures", // swap
            //                     "contract_code" => "ADA201225",
            //                     "direction" => "buy",
            //                     "offset" => "open",
            //                     "trade_volume" => 1,
            //                     "trade_price" => 0.092,
            //                     "trade_turnover" => 10,
            //                     "trade_fee" => -0.021739130434782608,
            //                     "offset_profitloss" => 0,
            //                     "create_date" => 1604371703183,
            //                     "role" => "Maker",
            //                     "order_source" => "web",
            //                     "order_id_str" => "773135295142658048",
            //                     "fee_asset" => "ADA",
            //                     "margin_mode" => "isolated", // cross
            //                     "margin_account" => "BTC-USDT",
            //                     "real_profit" => 0,
            //                     "id" => "113891764710-773135295142658048-1",
            //                     "trade_partition":"USDT",
            //                 }
            //             ),
            //             "remain_size" => 15,
            //             "next_id" => 2424413094
            //         ),
            //         "ts" => 1604372202243
            //     }
            //
            $trades = $this->safe_value($response, 'data');
            if (gettype($trades) !== 'array' || array_keys($trades) !== array_keys(array_keys($trades))) {
                $trades = $this->safe_value($trades, 'trades');
            }
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function fetch_trades(string $symbol, ?int $since = null, $limit = 1000, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest $trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades $trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                // 'symbol' => $market['id'], // spot, future
                // 'contract_code' => $market['id'], // swap
            );
            $fieldName = 'symbol';
            $method = 'spotPublicGetMarketHistoryTrade';
            if ($market['future']) {
                if ($market['inverse']) {
                    $method = 'contractPublicGetMarketHistoryTrade';
                } elseif ($market['linear']) {
                    $method = 'contractPublicGetLinearSwapExMarketHistoryTrade';
                    $fieldName = 'contract_code';
                }
            } elseif ($market['swap']) {
                if ($market['inverse']) {
                    $method = 'contractPublicGetSwapExMarketHistoryTrade';
                } elseif ($market['linear']) {
                    $method = 'contractPublicGetLinearSwapExMarketHistoryTrade';
                }
                $fieldName = 'contract_code';
            }
            $request[$fieldName] = $market['id'];
            if ($limit !== null) {
                $request['size'] = $limit; // max 2000
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            //     {
            //         "status" => "ok",
            //         "ch" => "market.btcusdt.trade.detail",
            //         "ts" => 1583497692365,
            //         "data" => array(
            //             {
            //                 "id" => 105005170342,
            //                 "ts" => 1583497692182,
            //                 "data" => array(
            //                     array(
            //                         "amount" => 0.010411000000000000,
            //                         "trade-id" => 102090736910,
            //                         "ts" => 1583497692182,
            //                         "id" => 10500517034273194594947,
            //                         "price" => 9096.050000000000000000,
            //                         "direction" => "sell"
            //                     }
            //                 )
            //             ),
            //             // ...
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $result = array();
            for ($i = 0; $i < count($data); $i++) {
                $trades = $this->safe_value($data[$i], 'data', array());
                for ($j = 0; $j < count($trades); $j++) {
                    $trade = $this->parse_trade($trades[$j], $market);
                    $result[] = $trade;
                }
            }
            $result = $this->sort_by($result, 'timestamp');
            return $this->filter_by_symbol_since_limit($result, $market['symbol'], $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //     {
        //         "amount":1.2082,
        //         "open":0.025096,
        //         "close":0.025095,
        //         "high":0.025096,
        //         "id":1591515300,
        //         "count":6,
        //         "low":0.025095,
        //         "vol":0.0303205097
        //     }
        //
        return array(
            $this->safe_timestamp($ohlcv, 'id'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'amount'),
        );
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick $data containing the open, high, low, and close $price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[[int]]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'period' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
                // 'symbol' => $market['id'], // spot, future
                // 'contract_code' => $market['id'], // swap
                // 'size' => 1000, // max 1000 for spot, 2000 for contracts
                // 'from' => intval(($since / (string) 1000)), spot only
                // 'to' => $this->seconds(), spot only
            );
            $fieldName = 'symbol';
            $price = $this->safe_string($params, 'price');
            $params = $this->omit($params, 'price');
            $method = 'spotPublicGetMarketHistoryCandles';
            if ($market['spot']) {
                if ($since !== null) {
                    $request['from'] = $this->parse_to_int($since / 1000);
                }
                if ($limit !== null) {
                    $request['size'] = $limit; // max 2000
                }
            } elseif ($market['future']) {
                if ($market['inverse']) {
                    if ($price === 'mark') {
                        $method = 'contractPublicGetIndexMarketHistoryMarkPriceKline';
                    } elseif ($price === 'index') {
                        $method = 'contractPublicGetIndexMarketHistoryIndex';
                    } elseif ($price === 'premiumIndex') {
                        throw new BadRequest($this->id . ' ' . $market['type'] . ' has no api endpoint for ' . $price . ' kline data');
                    } else {
                        $method = 'contractPublicGetMarketHistoryKline';
                    }
                } elseif ($market['linear']) {
                    if ($price === 'mark') {
                        $method = 'contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline';
                    } elseif ($price === 'index') {
                        throw new BadRequest($this->id . ' ' . $market['type'] . ' has no api endpoint for ' . $price . ' kline data');
                    } elseif ($price === 'premiumIndex') {
                        $method = 'contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline';
                    } else {
                        $method = 'contractPublicGetLinearSwapExMarketHistoryKline';
                    }
                    $fieldName = 'contract_code';
                }
            } elseif ($market['swap']) {
                if ($market['inverse']) {
                    if ($price === 'mark') {
                        $method = 'contractPublicGetIndexMarketHistorySwapMarkPriceKline';
                    } elseif ($price === 'index') {
                        throw new BadRequest($this->id . ' ' . $market['type'] . ' has no api endpoint for ' . $price . ' kline data');
                    } elseif ($price === 'premiumIndex') {
                        $method = 'contractPublicGetIndexMarketHistorySwapPremiumIndexKline';
                    } else {
                        $method = 'contractPublicGetSwapExMarketHistoryKline';
                    }
                } elseif ($market['linear']) {
                    if ($price === 'mark') {
                        $method = 'contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline';
                    } elseif ($price === 'index') {
                        throw new BadRequest($this->id . ' ' . $market['type'] . ' has no api endpoint for ' . $price . ' kline data');
                    } elseif ($price === 'premiumIndex') {
                        $method = 'contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline';
                    } else {
                        $method = 'contractPublicGetLinearSwapExMarketHistoryKline';
                    }
                }
                $fieldName = 'contract_code';
            }
            if ($market['contract']) {
                if ($limit === null) {
                    $limit = 2000;
                }
                $request['size'] = $limit;
                if ($price === null) {
                    $duration = $this->parse_timeframe($timeframe);
                    if ($since === null) {
                        $now = $this->seconds();
                        $request['from'] = $now - $duration * ($limit - 1);
                        $request['to'] = $now;
                    } else {
                        $start = $this->parse_to_int($since / 1000);
                        $request['from'] = $start;
                        $request['to'] = $this->sum($start, $duration * ($limit - 1));
                    }
                }
            }
            $request[$fieldName] = $market['id'];
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            //     {
            //         "status":"ok",
            //         "ch":"market.ethbtc.kline.1min",
            //         "ts":1591515374371,
            //         "data":array(
            //             array("amount":0.0,"open":0.025095,"close":0.025095,"high":0.025095,"id":1591515360,"count":0,"low":0.025095,"vol":0.0),
            //             array("amount":1.2082,"open":0.025096,"close":0.025095,"high":0.025096,"id":1591515300,"count":6,"low":0.025095,"vol":0.0303205097),
            //             array("amount":0.0648,"open":0.025096,"close":0.025096,"high":0.025096,"id":1591515240,"count":2,"low":0.025096,"vol":0.0016262208),
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function fetch_accounts($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetch all the accounts associated with a profile
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=account-structure account structures~ indexed by the account type
             */
            Async\await($this->load_markets());
            $response = Async\await($this->spotPrivateGetV1AccountAccounts ($params));
            //
            //     {
            //         "status":"ok",
            //         "data":array(
            //             array("id":5202591,"type":"point","subtype":"","state":"working"),
            //             array("id":1528640,"type":"spot","subtype":"","state":"working"),
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data');
            return $this->parse_accounts($data);
        }) ();
    }

    public function parse_account($account) {
        //
        //     {
        //         "id" => 5202591,
        //         "type" => "point",   // spot, margin, otc, point, super-margin, investment, borrow, grid-trading, deposit-earning, otc-options
        //         "subtype" => "",     // The corresponding trading symbol (currency pair) the isolated margin is based on, e.g. btcusdt
        //         "state" => "working" // working, lock
        //     }
        //
        $typeId = $this->safe_string($account, 'type');
        $accountsById = $this->safe_value($this->options, 'accountsById', array());
        $type = $this->safe_value($accountsById, $typeId, $typeId);
        return array(
            'info' => $account,
            'id' => $this->safe_string($account, 'id'),
            'type' => $type,
            'code' => null,
        );
    }

    public function fetch_account_id_by_type($type, $params = array ()) {
        return Async\async(function () use ($type, $params) {
            $accounts = Async\await($this->load_accounts());
            $accountId = $this->safe_value($params, 'account-id');
            if ($accountId !== null) {
                return $accountId;
            }
            $indexedAccounts = $this->index_by($accounts, 'type');
            $defaultAccount = $this->safe_value($accounts, 0, array());
            $account = $this->safe_value($indexedAccounts, $type, $defaultAccount);
            return $this->safe_string($account, 'id');
        }) ();
    }

    public function fetch_currencies($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches all available currencies on an exchange
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} an associative dictionary of currencies
             */
            $response = Async\await($this->spotPublicGetV2ReferenceCurrencies ($params));
            //
            //    {
            //        "code" => 200,
            //        "data" => array(
            //            {
            //                "currency" => "sxp",
            //                "assetType" => "1",
            //                "chains" => array(
            //                    {
            //                        "chain" => "sxp",
            //                        "displayName" => "ERC20",
            //                        "baseChain" => "ETH",
            //                        "baseChainProtocol" => "ERC20",
            //                        "isDynamic" => true,
            //                        "numOfConfirmations" => "12",
            //                        "numOfFastConfirmations" => "12",
            //                        "depositStatus" => "allowed",
            //                        "minDepositAmt" => "0.23",
            //                        "withdrawStatus" => "allowed",
            //                        "minWithdrawAmt" => "0.23",
            //                        "withdrawPrecision" => "8",
            //                        "maxWithdrawAmt" => "227000.000000000000000000",
            //                        "withdrawQuotaPerDay" => "227000.000000000000000000",
            //                        "withdrawQuotaPerYear" => null,
            //                        "withdrawQuotaTotal" => null,
            //                        "withdrawFeeType" => "fixed",
            //                        "transactFeeWithdraw" => "11.1653",
            //                        "addrWithTag" => false,
            //                        "addrDepositTag" => false
            //                    }
            //                ),
            //                "instStatus" => "normal"
            //            }
            //        )
            //    }
            //    }
            //
            $data = $this->safe_value($response, 'data', array());
            $result = array();
            $this->options['networkChainIdsByNames'] = array();
            $this->options['networkNamesByChainIds'] = array();
            for ($i = 0; $i < count($data); $i++) {
                $entry = $data[$i];
                $currencyId = $this->safe_string($entry, 'currency');
                $code = $this->safe_currency_code($currencyId);
                $this->options['networkChainIdsByNames'][$code] = array();
                $chains = $this->safe_value($entry, 'chains', array());
                $networks = array();
                $instStatus = $this->safe_string($entry, 'instStatus');
                $currencyActive = $instStatus === 'normal';
                $minPrecision = null;
                $minWithdraw = null;
                $maxWithdraw = null;
                $deposit = null;
                $withdraw = null;
                for ($j = 0; $j < count($chains); $j++) {
                    $chainEntry = $chains[$j];
                    $uniqueChainId = $this->safe_string($chainEntry, 'chain'); // $i->e. usdterc20, trc20usdt ...
                    $title = $this->safe_string($chainEntry, 'displayName');
                    $this->options['networkChainIdsByNames'][$code][$title] = $uniqueChainId;
                    $this->options['networkNamesByChainIds'][$uniqueChainId] = $title;
                    $networkCode = $this->network_id_to_code($title, $code);
                    $minWithdraw = $this->safe_number($chainEntry, 'minWithdrawAmt');
                    $maxWithdraw = $this->safe_number($chainEntry, 'maxWithdrawAmt');
                    $withdrawStatus = $this->safe_string($chainEntry, 'withdrawStatus');
                    $depositStatus = $this->safe_string($chainEntry, 'depositStatus');
                    $withdrawEnabled = ($withdrawStatus === 'allowed');
                    $depositEnabled = ($depositStatus === 'allowed');
                    $active = $withdrawEnabled && $depositEnabled;
                    $precision = $this->parse_precision($this->safe_string($chainEntry, 'withdrawPrecision'));
                    if ($precision !== null) {
                        $minPrecision = ($minPrecision === null) ? $precision : Precise::string_min($precision, $minPrecision);
                    }
                    if ($withdrawEnabled && !$withdraw) {
                        $withdraw = true;
                    } elseif (!$withdrawEnabled) {
                        $withdraw = false;
                    }
                    if ($depositEnabled && !$deposit) {
                        $deposit = true;
                    } elseif (!$depositEnabled) {
                        $deposit = false;
                    }
                    $fee = $this->safe_number($chainEntry, 'transactFeeWithdraw');
                    $networks[$networkCode] = array(
                        'info' => $chainEntry,
                        'id' => $uniqueChainId,
                        'network' => $networkCode,
                        'limits' => array(
                            'withdraw' => array(
                                'min' => $minWithdraw,
                                'max' => $maxWithdraw,
                            ),
                        ),
                        'active' => $active,
                        'deposit' => $depositEnabled,
                        'withdraw' => $withdrawEnabled,
                        'fee' => $fee,
                        'precision' => $this->parse_number($precision),
                    );
                }
                $result[$code] = array(
                    'info' => $entry,
                    'code' => $code,
                    'id' => $currencyId,
                    'active' => $currencyActive,
                    'deposit' => $deposit,
                    'withdraw' => $withdraw,
                    'fee' => null,
                    'name' => null,
                    'limits' => array(
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'withdraw' => array(
                            'min' => $minWithdraw,
                            'max' => $maxWithdraw,
                        ),
                    ),
                    'precision' => $this->parse_number($minPrecision),
                    'networks' => $networks,
                );
            }
            return $result;
        }) ();
    }

    public function network_id_to_code($networkId, $currencyCode = null) {
        // here network-id is provided pair of currency & chain (i.e. trc20usdt)
        $keys = is_array($this->options['networkNamesByChainIds']) ? array_keys($this->options['networkNamesByChainIds']) : array();
        $keysLength = count($keys);
        if ($keysLength === 0) {
            throw new ExchangeError($this->id . ' networkIdToCode() - markets need to be loaded at first');
        }
        $networkTitle = $this->safe_value($this->options['networkNamesByChainIds'], $networkId, $networkId);
        return parent::network_id_to_code($networkTitle);
    }

    public function network_code_to_id($networkCode, $currencyCode = null) {
        if ($currencyCode === null) {
            throw new ArgumentsRequired($this->id . ' networkCodeToId() requires a $currencyCode argument');
        }
        $keys = is_array($this->options['networkChainIdsByNames']) ? array_keys($this->options['networkChainIdsByNames']) : array();
        $keysLength = count($keys);
        if ($keysLength === 0) {
            throw new ExchangeError($this->id . ' networkCodeToId() - markets need to be loaded at first');
        }
        $uniqueNetworkIds = $this->safe_value($this->options['networkChainIdsByNames'], $currencyCode, array());
        $networkTitle = parent::network_code_to_id($networkCode);
        return $this->safe_value($uniqueNetworkIds, $networkTitle, $networkTitle);
    }

    public function fetch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for $balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#$balance-structure $balance structure~
             */
            Async\await($this->load_markets());
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('fetchBalance', null, $params);
            $options = $this->safe_value($this->options, 'fetchBalance', array());
            $request = array();
            $method = null;
            $spot = ($type === 'spot');
            $future = ($type === 'future');
            $swap = ($type === 'swap');
            $defaultSubType = $this->safe_string_2($this->options, 'defaultSubType', 'subType', 'linear');
            $subType = $this->safe_string_2($options, 'defaultSubType', 'subType', $defaultSubType);
            $subType = $this->safe_string_2($params, 'defaultSubType', 'subType', $subType);
            $inverse = ($subType === 'inverse');
            $linear = ($subType === 'linear');
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('fetchBalance', $params);
            $params = $this->omit($params, array( 'defaultSubType', 'subType' ));
            $isolated = ($marginMode === 'isolated');
            $cross = ($marginMode === 'cross');
            $margin = ($type === 'margin') || ($spot && ($cross || $isolated));
            if ($spot || $margin) {
                if ($margin) {
                    if ($isolated) {
                        $method = 'spotPrivateGetV1MarginAccountsBalance';
                    } else {
                        $method = 'spotPrivateGetV1CrossMarginAccountsBalance';
                    }
                } else {
                    Async\await($this->load_accounts());
                    $accountId = Async\await($this->fetch_account_id_by_type($type, $params));
                    $request['account-id'] = $accountId;
                    $method = 'spotPrivateGetV1AccountAccountsAccountIdBalance';
                }
            } elseif ($linear) {
                if ($isolated) {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapAccountInfo';
                } else {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo';
                }
            } elseif ($inverse) {
                if ($future) {
                    $method = 'contractPrivatePostApiV1ContractAccountInfo';
                } elseif ($swap) {
                    $method = 'contractPrivatePostSwapApiV1SwapAccountInfo';
                }
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // $spot
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             "id" => 1528640,
            //             "type" => "spot",
            //             "state" => "working",
            //             "list" => array(
            //                 array( "currency" => "lun", "type" => "trade", "balance" => "0", "seq-num" => "0" ),
            //                 array( "currency" => "lun", "type" => "frozen", "balance" => "0", "seq-num" => "0" ),
            //                 array( "currency" => "ht", "type" => "frozen", "balance" => "0", "seq-num" => "145" ),
            //             )
            //         ),
            //         "ts":1637644827566
            //     }
            //
            // $cross $margin
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             "id" => 51015302,
            //             "type" => "cross-$margin",
            //             "state" => "working",
            //             "risk-rate" => "2",
            //             "acct-$balance-sum" => "100",
            //             "debt-$balance-sum" => "0",
            //             "list" => array(
            //                 array( "currency" => "usdt", "type" => "trade", "balance" => "100" ),
            //                 array( "currency" => "usdt", "type" => "frozen", "balance" => "0" ),
            //                 array( "currency" => "usdt", "type" => "loan-available", "balance" => "200" ),
            //                 array( "currency" => "usdt", "type" => "transfer-out-available", "balance" => "-1" ),
            //                 array( "currency" => "ht", "type" => "loan-available", "balance" => "36.60724091" ),
            //                 array( "currency" => "ht", "type" => "transfer-out-available", "balance" => "-1" ),
            //                 array( "currency" => "btc", "type" => "trade", "balance" => "1168.533000000000000000" ),
            //                 array( "currency" => "btc", "type" => "frozen", "balance" => "0.000000000000000000" ),
            //                 array( "currency" => "btc", "type" => "loan", "balance" => "-2.433000000000000000" ),
            //                 array( "currency" => "btc", "type" => "interest", "balance" => "-0.000533000000000000" ),
            //                 array( "currency" => "btc", "type" => "transfer-out-available", "balance" => "1163.872174670000000000" ),
            //                 array( "currency" => "btc", "type" => "loan-available", "balance" => "8161.876538350676000000" )
            //             )
            //         ),
            //         "code" => 200
            //     }
            //
            // $isolated $margin
            //
            //     {
            //         "data" => array(
            //             {
            //                 "id" => 18264,
            //                 "type" => "margin",
            //                 "state" => "working",
            //                 "symbol" => "btcusdt",
            //                 "fl-price" => "0",
            //                 "fl-$type" => "safe",
            //                 "risk-rate" => "475.952571086994250554",
            //                 "list" => array(
            //                     array( "currency" => "btc","type" => "trade","balance" => "1168.533000000000000000" ),
            //                     array( "currency" => "btc","type" => "frozen","balance" => "0.000000000000000000" ),
            //                     array( "currency" => "btc","type" => "loan","balance" => "-2.433000000000000000" ),
            //                     array( "currency" => "btc","type" => "interest","balance" => "-0.000533000000000000" ),
            //                     array( "currency" => "btc","type" => "transfer-out-available", "balance" => "1163.872174670000000000" ),
            //                     array( "currency" => "btc","type" => "loan-available", "balance" => "8161.876538350676000000" )
            //                 )
            //             }
            //         )
            //     }
            //
            // $future, $swap $isolated
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             array(
            //                 "symbol" => "BTC",
            //                 "margin_balance" => 0,
            //                 "margin_position" => 0E-18,
            //                 "margin_frozen" => 0,
            //                 "margin_available" => 0E-18,
            //                 "profit_real" => 0,
            //                 "profit_unreal" => 0,
            //                 "risk_rate" => null,
            //                 "withdraw_available" => 0,
            //                 "liquidation_price" => null,
            //                 "lever_rate" => 5,
            //                 "adjust_factor" => 0.025000000000000000,
            //                 "margin_static" => 0,
            //                 "is_debit" => 0, // $future only
            //                 "contract_code" => "BTC-USD", // $swap only
            //                 "margin_asset" => "USDT", // $linear only
            //                 "margin_mode" => "isolated", // $linear only
            //                 "margin_account" => "BTC-USDT" // $linear only
            //                 "transfer_profit_ratio" => null // $inverse only
            //             ),
            //         ),
            //         "ts" => 1637644827566
            //     }
            //
            // $linear $cross futures and $linear $cross $swap
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             {
            //                 "futures_contract_detail" => array(
            //                     array(
            //                         "symbol" => "ETH",
            //                         "contract_code" => "ETH-USDT-220325",
            //                         "margin_position" => 0,
            //                         "margin_frozen" => 0,
            //                         "margin_available" => 200.000000000000000000,
            //                         "profit_unreal" => 0E-18,
            //                         "liquidation_price" => null,
            //                         "lever_rate" => 5,
            //                         "adjust_factor" => 0.060000000000000000,
            //                         "contract_type" => "quarter",
            //                         "pair" => "ETH-USDT",
            //                         "business_type" => "futures"
            //                     ),
            //                 ),
            //                 "margin_mode" => "cross",
            //                 "margin_account" => "USDT",
            //                 "margin_asset" => "USDT",
            //                 "margin_balance" => 200.000000000000000000,
            //                 "margin_static" => 200.000000000000000000,
            //                 "margin_position" => 0,
            //                 "margin_frozen" => 0,
            //                 "profit_real" => 0E-18,
            //                 "profit_unreal" => 0,
            //                 "withdraw_available" => 2E+2,
            //                 "risk_rate" => null,
            //                 "contract_detail" => array(
            //                     array(
            //                         "symbol" => "MANA",
            //                         "contract_code" => "MANA-USDT",
            //                         "margin_position" => 0,
            //                         "margin_frozen" => 0,
            //                         "margin_available" => 200.000000000000000000,
            //                         "profit_unreal" => 0E-18,
            //                         "liquidation_price" => null,
            //                         "lever_rate" => 5,
            //                         "adjust_factor" => 0.100000000000000000,
            //                         "contract_type" => "swap",
            //                         "pair" => "MANA-USDT",
            //                         "business_type" => "swap"
            //                     ),
            //                 )
            //             }
            //         ),
            //         "ts" => 1640915104870
            //     }
            //
            // TODO add $balance parsing for $linear $swap
            //
            $result = array( 'info' => $response );
            $data = $this->safe_value($response, 'data');
            if ($spot || $margin) {
                if ($isolated) {
                    for ($i = 0; $i < count($data); $i++) {
                        $entry = $data[$i];
                        $symbol = $this->safe_symbol($this->safe_string($entry, 'symbol'));
                        $balances = $this->safe_value($entry, 'list');
                        $subResult = array();
                        for ($i = 0; $i < count($balances); $i++) {
                            $balance = $balances[$i];
                            $currencyId = $this->safe_string($balance, 'currency');
                            $code = $this->safe_currency_code($currencyId);
                            $subResult[$code] = $this->parse_margin_balance_helper($balance, $code, $subResult);
                        }
                        $result[$symbol] = $this->safe_balance($subResult);
                    }
                } else {
                    $balances = $this->safe_value($data, 'list', array());
                    for ($i = 0; $i < count($balances); $i++) {
                        $balance = $balances[$i];
                        $currencyId = $this->safe_string($balance, 'currency');
                        $code = $this->safe_currency_code($currencyId);
                        $result[$code] = $this->parse_margin_balance_helper($balance, $code, $result);
                    }
                    $result = $this->safe_balance($result);
                }
            } elseif ($linear) {
                $first = $this->safe_value($data, 0, array());
                if ($isolated) {
                    for ($i = 0; $i < count($data); $i++) {
                        $balance = $data[$i];
                        $marketId = $this->safe_string_2($balance, 'contract_code', 'margin_account');
                        $market = $this->safe_market($marketId);
                        $currencyId = $this->safe_string($balance, 'margin_asset');
                        $currency = $this->safe_currency($currencyId);
                        $code = $this->safe_string($market, 'settle', $currency['code']);
                        // the exchange outputs positions for delisted markets
                        // https://www.huobi.com/support/en-us/detail/74882968522337
                        // we skip it if the $market was delisted
                        if ($code !== null) {
                            $account = $this->account();
                            $account['free'] = $this->safe_string($balance, 'margin_balance');
                            $account['used'] = $this->safe_string($balance, 'margin_frozen');
                            $accountsByCode = array();
                            $accountsByCode[$code] = $account;
                            $symbol = $market['symbol'];
                            $result[$symbol] = $this->safe_balance($accountsByCode);
                        }
                    }
                } else {
                    $account = $this->account();
                    $account['free'] = $this->safe_string($first, 'margin_balance', 'margin_available');
                    $account['used'] = $this->safe_string($first, 'margin_frozen');
                    $currencyId = $this->safe_string_2($first, 'margin_asset', 'symbol');
                    $code = $this->safe_currency_code($currencyId);
                    $result[$code] = $account;
                    $result = $this->safe_balance($result);
                }
            } elseif ($inverse) {
                for ($i = 0; $i < count($data); $i++) {
                    $balance = $data[$i];
                    $currencyId = $this->safe_string($balance, 'symbol');
                    $code = $this->safe_currency_code($currencyId);
                    $account = $this->account();
                    $account['free'] = $this->safe_string($balance, 'margin_available');
                    $account['used'] = $this->safe_string($balance, 'margin_frozen');
                    $result[$code] = $account;
                }
                $result = $this->safe_balance($result);
            }
            return $result;
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an $order made by the user
             * @param {string|null} $symbol unified $symbol of the $market the $order was made in
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('fetchOrder', $market, $params);
            $request = array(
                // spot -----------------------------------------------------------
                // 'order-id' => 'id',
                // 'symbol' => $market['id'],
                // 'client-$order-id' => $clientOrderId,
                // 'clientOrderId' => $clientOrderId,
                // contracts ------------------------------------------------------
                // 'order_id' => $id,
                // 'client_order_id' => $clientOrderId,
                // 'contract_code' => $market['id'],
                // 'pair' => 'BTC-USDT',
                // 'contract_type' => 'this_week', // swap, this_week, next_week, quarter, next_ quarter
            );
            $method = null;
            if ($marketType === 'spot') {
                $clientOrderId = $this->safe_string($params, 'clientOrderId');
                $method = 'spotPrivateGetV1OrderOrdersOrderId';
                if ($clientOrderId !== null) {
                    $method = 'spotPrivateGetV1OrderOrdersGetClientOrder';
                    // will be filled below in extend ()
                    // they expect $clientOrderId instead of client-$order-$id
                    // $request['clientOrderId'] = $clientOrderId;
                } else {
                    $request['order-id'] = $id;
                }
            } else {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol for ' . $marketType . ' orders');
                }
                $request['contract_code'] = $market['id'];
                if ($market['linear']) {
                    $marginMode = null;
                    list($marginMode, $params) = $this->handle_margin_mode_and_params('fetchOrder', $params);
                    $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
                    if ($marginMode === 'isolated') {
                        $method = 'contractPrivatePostLinearSwapApiV1SwapOrderInfo';
                    } elseif ($marginMode === 'cross') {
                        $method = 'contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo';
                    }
                } elseif ($market['inverse']) {
                    if ($marketType === 'future') {
                        $method = 'contractPrivatePostApiV1ContractOrderInfo';
                        $request['symbol'] = $market['settleId'];
                    } elseif ($marketType === 'swap') {
                        $method = 'contractPrivatePostSwapApiV1SwapOrderInfo';
                    } else {
                        throw new NotSupported($this->id . ' fetchOrder() does not support ' . $marketType . ' markets');
                    }
                }
                $clientOrderId = $this->safe_string_2($params, 'client_order_id', 'clientOrderId');
                if ($clientOrderId === null) {
                    $request['order_id'] = $id;
                } else {
                    $request['client_order_id'] = $clientOrderId;
                    $params = $this->omit($params, array( 'client_order_id', 'clientOrderId' ));
                }
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "data":{
            //             "id":438398393065481,
            //             "symbol":"ethusdt",
            //             "account-$id":1528640,
            //             "client-$order-$id":"AA03022abc2163433e-006b-480e-9ad1-d4781478c5e7",
            //             "amount":"0.100000000000000000",
            //             "price":"3000.000000000000000000",
            //             "created-at":1640549994642,
            //             "type":"buy-limit",
            //             "field-amount":"0.0",
            //             "field-cash-amount":"0.0",
            //             "field-fees":"0.0",
            //             "finished-at":0,
            //             "source":"spot-api",
            //             "state":"submitted",
            //             "canceled-at":0
            //         }
            //     }
            //
            // linear swap cross margin
            //
            //     {
            //         "status":"ok",
            //         "data":array(
            //             {
            //                 "business_type":"swap",
            //                 "contract_type":"swap",
            //                 "pair":"BTC-USDT",
            //                 "symbol":"BTC",
            //                 "contract_code":"BTC-USDT",
            //                 "volume":1,
            //                 "price":3000,
            //                 "order_price_type":"limit",
            //                 "order_type":1,
            //                 "direction":"buy",
            //                 "offset":"open",
            //                 "lever_rate":1,
            //                 "order_id":924912513206878210,
            //                 "client_order_id":null,
            //                 "created_at":1640557927189,
            //                 "trade_volume":0,
            //                 "trade_turnover":0,
            //                 "fee":0,
            //                 "trade_avg_price":null,
            //                 "margin_frozen":3.000000000000000000,
            //                 "profit":0,
            //                 "status":3,
            //                 "order_source":"api",
            //                 "order_id_str":"924912513206878210",
            //                 "fee_asset":"USDT",
            //                 "liquidation_type":"0",
            //                 "canceled_at":0,
            //                 "margin_asset":"USDT",
            //                 "margin_account":"USDT",
            //                 "margin_mode":"cross",
            //                 "is_tpsl":0,
            //                 "real_profit":0
            //             }
            //         ),
            //         "ts":1640557982556
            //     }
            //
            // linear swap isolated margin detail
            //
            //     {
            //         "status" => "ok",
            //         "data" => {
            //             "symbol" => "BTC",
            //             "contract_code" => "BTC-USDT",
            //             "instrument_price" => 0,
            //             "final_interest" => 0,
            //             "adjust_value" => 0,
            //             "lever_rate" => 10,
            //             "direction" => "sell",
            //             "offset" => "open",
            //             "volume" => 1.000000000000000000,
            //             "price" => 13059.800000000000000000,
            //             "created_at" => 1603703614712,
            //             "canceled_at" => 0,
            //             "order_source" => "api",
            //             "order_price_type" => "opponent",
            //             "margin_frozen" => 0,
            //             "profit" => 0,
            //             "trades" => array(
            //                 array(
            //                     "trade_id" => 131560927,
            //                     "trade_price" => 13059.800000000000000000,
            //                     "trade_volume" => 1.000000000000000000,
            //                     "trade_turnover" => 13.059800000000000000,
            //                     "trade_fee" => -0.005223920000000000,
            //                     "created_at" => 1603703614715,
            //                     "role" => "taker",
            //                     "fee_asset" => "USDT",
            //                     "profit" => 0,
            //                     "real_profit" => 0,
            //                     "id" => "131560927-770334322963152896-1"
            //                 }
            //             ),
            //             "total_page" => 1,
            //             "current_page" => 1,
            //             "total_size" => 1,
            //             "liquidation_type" => "0",
            //             "fee_asset" => "USDT",
            //             "fee" => -0.005223920000000000,
            //             "order_id" => 770334322963152896,
            //             "order_id_str" => "770334322963152896",
            //             "client_order_id" => 57012021045,
            //             "order_type" => "1",
            //             "status" => 6,
            //             "trade_avg_price" => 13059.800000000000000000,
            //             "trade_turnover" => 13.059800000000000000,
            //             "trade_volume" => 1.000000000000000000,
            //             "margin_asset" => "USDT",
            //             "margin_mode" => "isolated",
            //             "margin_account" => "BTC-USDT",
            //             "real_profit" => 0,
            //             "is_tpsl" => 0
            //         ),
            //         "ts" => 1603703678477
            //     }
            $order = $this->safe_value($response, 'data');
            if (gettype($order) === 'array' && array_keys($order) === array_keys(array_keys($order))) {
                $order = $this->safe_value($order, 0);
            }
            return $this->parse_order($order);
        }) ();
    }

    public function parse_margin_balance_helper($balance, $code, $result) {
        $account = null;
        if (is_array($result) && array_key_exists($code, $result)) {
            $account = $result[$code];
        } else {
            $account = $this->account();
        }
        if ($balance['type'] === 'trade') {
            $account['free'] = $this->safe_string($balance, 'balance');
        }
        if ($balance['type'] === 'frozen') {
            $account['used'] = $this->safe_string($balance, 'balance');
        }
        return $account;
    }

    public function fetch_spot_orders_by_states($states, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($states, $symbol, $since, $limit, $params) {
            $method = $this->safe_string($this->options, 'fetchOrdersByStatesMethod', 'spot_private_get_v1_order_orders'); // spot_private_get_v1_order_history
            if ($method === 'spot_private_get_v1_order_orders') {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' fetchOrders() requires a $symbol argument');
                }
            }
            Async\await($this->load_markets());
            $market = null;
            $request = array(
                // spot_private_get_v1_order_orders GET /v1/order/orders ----------
                // 'symbol' => $market['id'], // required
                // 'types' => 'buy-$market,sell-$market,buy-$limit,sell-$limit,buy-ioc,sell-ioc,buy-stop-$limit,sell-stop-$limit,buy-$limit-fok,sell-$limit-fok,buy-stop-$limit-fok,sell-stop-$limit-fok',
                // 'start-time' => $since, // max window of 48h within a range of 180 days, within past 2 hours for cancelled orders
                // 'end-time' => $this->milliseconds(),
                'states' => $states, // filled, partial-canceled, canceled
                // 'from' => order['id'],
                // 'direct' => 'next', // next, prev, used with from
                // 'size' => 100, // max 100
                // spot_private_get_v1_order_history GET /v1/order/history --------
                // 'symbol' => $market['id'], // optional
                // 'start-time' => $since, // max window of 48h within a range of 180 days, within past 2 hours for cancelled orders
                // 'end-time' => $this->milliseconds(),
                // 'direct' => 'next', // next, prev, used with from
                // 'size' => 100, // max 100
            );
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            if ($since !== null) {
                $request['start-time'] = $since; // a window of 48 hours within 180 days
                $request['end-time'] = $this->sum($since, 48 * 60 * 60 * 1000);
            }
            if ($limit !== null) {
                $request['size'] = $limit;
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot_private_get_v1_order_orders GET /v1/order/orders
            //
            //     {
            //         status => "ok",
            //         $data => array(
            //             {
            //                 id => 13997833014,
            //                 $symbol => "ethbtc",
            //                 'account-id' => 3398321,
            //                 'client-order-id' => "23456",
            //                 amount => "0.045000000000000000",
            //                 price => "0.034014000000000000",
            //                 'created-at' => 1545836976871,
            //                 type => "sell-$limit",
            //                 'field-amount' => "0.045000000000000000",
            //                 'field-cash-amount' => "0.001530630000000000",
            //                 'field-fees' => "0.000003061260000000",
            //                 'finished-at' => 1545837948214,
            //                 source => "spot-api",
            //                 state => "filled",
            //                 'canceled-at' => 0
            //             }
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_orders($data, $market, $since, $limit);
        }) ();
    }

    public function fetch_spot_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            return Async\await($this->fetch_spot_orders_by_states('pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled', $symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_closed_spot_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            return Async\await($this->fetch_spot_orders_by_states('filled,partial-canceled,canceled', $symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_contract_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchContractOrders() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('fetchOrders', $market, $params);
            $request = array(
                // POST /api/v1/contract_hisorders inverse futures ----------------
                // 'symbol' => $market['settleId'], // BTC, ETH, ...
                // 'order_type' => '1', // 1 $limit，3 opponent，4 lightning, 5 trigger order, 6 pst_only, 7 optimal_5, 8 optimal_10, 9 optimal_20, 10 fok, 11 ioc
                // POST /swap-api/v3/swap_hisorders inverse swap ------------------
                // POST /linear-swap-api/v3/swap_hisorders linear isolated --------
                // POST /linear-swap-api/v3/swap_cross_hisorders linear cross -----
                'contract' => $market['id'],
                'trade_type' => 0, // 0:All; 1 => Open long; 2 => Open short; 3 => Close short; 4 => Close long; 5 => Liquidate long positions; 6 => Liquidate short positions, 17:buy(one-way mode), 18:sell(one-way mode)
                'type' => 1, // 1:All Orders,2:Order in Finished Status
                'status' => '0', // support multiple query seperated by ',',such as '3,4,5', 0 => all. 3. Have sumbmitted the $orders; 4. Orders partially matched; 5. Orders cancelled with partially matched; 6. Orders fully matched; 7. Orders cancelled;
            );
            if ($since !== null) {
                $request['start_time'] = $since; // max 90 days back
                // $request['end_time'] = $since + 172800000; // 48 hours window
            }
            $method = null;
            if ($market['linear']) {
                $marginMode = null;
                list($marginMode, $params) = $this->handle_margin_mode_and_params('fetchContractOrders', $params);
                $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
                $method = $this->get_supported_mapping($marginMode, array(
                    'isolated' => 'contractPrivatePostLinearSwapApiV3SwapHisorders',
                    'cross' => 'contractPrivatePostLinearSwapApiV3SwapCrossHisorders',
                ));
            } elseif ($market['inverse']) {
                $method = $this->get_supported_mapping($marketType, array(
                    'future' => 'contractPrivatePostApiV3ContractHisorders',
                    'swap' => 'contractPrivatePostSwapApiV3SwapHisorders',
                ));
                if ($marketType === 'future') {
                    $request['symbol'] = $market['settleId'];
                }
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            //     {
            //         "status" => "ok",
            //         "data" => {
            //             "orders" => array(
            //                 array(
            //                     "order_id" => 773131315209248768,
            //                     "contract_code" => "ADA201225",
            //                     "symbol" => "ADA",
            //                     "lever_rate" => 20,
            //                     "direction" => "buy",
            //                     "offset" => "close",
            //                     "volume" => 1,
            //                     "price" => 0.0925,
            //                     "create_date" => 1604370469629,
            //                     "update_time" => 1603704221118,
            //                     "order_source" => "web",
            //                     "order_price_type" => 6,
            //                     "order_type" => 1,
            //                     "margin_frozen" => 0,
            //                     "profit" => 0,
            //                     "contract_type" => "quarter",
            //                     "trade_volume" => 0,
            //                     "trade_turnover" => 0,
            //                     "fee" => 0,
            //                     "trade_avg_price" => 0,
            //                     "status" => 3,
            //                     "order_id_str" => "773131315209248768",
            //                     "fee_asset" => "ADA",
            //                     "liquidation_type" => "0",
            //                     "is_tpsl" => 0,
            //                     "real_profit" => 0
            //                     "margin_asset" => "USDT",
            //                     "margin_mode" => "cross",
            //                     "margin_account" => "USDT",
            //                     "trade_partition" => "USDT", // only in isolated & cross of linear
            //                     "reduce_only" => "1", // only in isolated & cross of linear
            //                     "contract_type" => "quarter", // only in cross-margin (inverse & linear)
            //                     "pair" => "BTC-USDT", // only in cross-margin (inverse & linear)
            //                     "business_type" => "futures" // only in cross-margin (inverse & linear)
            //                 }
            //             ),
            //             "total_page" => 19,
            //             "current_page" => 1,
            //             "total_size" => 19
            //         ),
            //         "ts" => 1604370617322
            //     }
            //
            $orders = $this->safe_value($response, 'data', array());
            return $this->parse_orders($orders, $market, $since, $limit);
        }) ();
    }

    public function fetch_closed_contract_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            $request = array(
                'status' => '5,6,7', // comma separated, 0 all, 3 submitted orders, 4 partially matched, 5 partially cancelled, 6 fully matched and closed, 7 canceled
            );
            return Async\await($this->fetch_contract_orders($symbol, $since, $limit, array_merge($request, $params)));
        }) ();
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('fetchOrders', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'fetchSpotOrders',
                'swap' => 'fetchContractOrders',
                'future' => 'fetchContractOrders',
            ));
            if ($method === null) {
                throw new NotSupported($this->id . ' fetchOrders() does not support ' . $marketType . ' markets yet');
            }
            $contract = ($marketType === 'swap') || ($marketType === 'future');
            if ($contract && ($symbol === null)) {
                throw new ArgumentsRequired($this->id . ' fetchOrders() requires a $symbol argument for ' . $marketType . ' orders');
            }
            return Async\await($this->$method ($symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple closed orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('fetchClosedOrders', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'fetchClosedSpotOrders',
                'swap' => 'fetchClosedContractOrders',
                'future' => 'fetchClosedContractOrders',
            ));
            if ($method === null) {
                throw new NotSupported($this->id . ' fetchClosedOrders() does not support ' . $marketType . ' markets yet');
            }
            return Async\await($this->$method ($symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open $orders
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch open $orders for
             * @param {int|null} $limit the maximum number of  open $orders structures to retrieve
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('fetchOpenOrders', $market, $params);
            $request = array(
                // spot -----------------------------------------------------------
                // 'account-id' => $account['id'],
                // 'symbol' => $market['id'],
                // 'side' => 'buy', // buy, sell
                // 'from' => 'id', // order id to begin with
                // 'direct' => 'prev', // prev, next, mandatory if from is defined
                // 'size' => 100, // default 100, max 500
                // futures --------------------------------------------------------
                // 'symbol' => $market['settleId'],
                // 'page_index' => 1, // default 1
                // 'page_size' => $limit, // default 20, max 50
                // 'sort_by' => 'created_at', // created_at, update_time, descending sorting field
                // 'trade_type' => 0, // 0 all, 1 buy long, 2 sell short, 3 buy short, 4 sell long
            );
            $method = null;
            if ($marketType === 'spot') {
                $method = 'spotPrivateGetV1OrderOpenOrders';
                if ($symbol !== null) {
                    $market = $this->market($symbol);
                    $request['symbol'] = $market['id'];
                }
                // todo replace with fetchAccountIdByType
                $accountId = $this->safe_string($params, 'account-id');
                if ($accountId === null) {
                    // pick the first $account
                    Async\await($this->load_accounts());
                    for ($i = 0; $i < count($this->accounts); $i++) {
                        $account = $this->accounts[$i];
                        if ($account['type'] === 'spot') {
                            $accountId = $this->safe_string($account, 'id');
                            if ($accountId !== null) {
                                break;
                            }
                        }
                    }
                }
                $request['account-id'] = $accountId;
                if ($limit !== null) {
                    $request['size'] = $limit;
                }
                $params = $this->omit($params, 'account-id');
            } else {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' fetchOpenOrders() requires a $symbol for ' . $marketType . ' orders');
                }
                $market = $this->market($symbol);
                $request['contract_code'] = $market['id'];
                if ($market['linear']) {
                    $marginMode = null;
                    list($marginMode, $params) = $this->handle_margin_mode_and_params('fetchOpenOrders', $params);
                    $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
                    if ($marginMode === 'isolated') {
                        $method = 'contractPrivatePostLinearSwapApiV1SwapOpenorders';
                    } elseif ($marginMode === 'cross') {
                        $method = 'contractPrivatePostLinearSwapApiV1SwapCrossOpenorders';
                    }
                } elseif ($market['inverse']) {
                    if ($market['future']) {
                        $method = 'contractPrivatePostApiV1ContractOpenorders';
                        $request['symbol'] = $market['settleId'];
                    } elseif ($market['swap']) {
                        $method = 'contractPrivatePostSwapApiV1SwapOpenorders';
                    }
                }
                if ($limit !== null) {
                    $request['page_size'] = $limit;
                }
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "data":array(
            //             {
            //                 "symbol":"ethusdt",
            //                 "source":"api",
            //                 "amount":"0.010000000000000000",
            //                 "account-id":1528640,
            //                 "created-at":1561597491963,
            //                 "price":"400.000000000000000000",
            //                 "filled-amount":"0.0",
            //                 "filled-cash-amount":"0.0",
            //                 "filled-fees":"0.0",
            //                 "id":38477101630,
            //                 "state":"submitted",
            //                 "type":"sell-$limit"
            //             }
            //         )
            //     }
            //
            // futures
            //
            //     {
            //         "status" => "ok",
            //         "data" => {
            //             "orders" => array(
            //                 array(
            //                     "symbol" => "ADA",
            //                     "contract_code" => "ADA201225",
            //                     "contract_type" => "quarter",
            //                     "volume" => 1,
            //                     "price" => 0.0925,
            //                     "order_price_type" => "post_only",
            //                     "order_type" => 1,
            //                     "direction" => "buy",
            //                     "offset" => "close",
            //                     "lever_rate" => 20,
            //                     "order_id" => 773131315209248768,
            //                     "client_order_id" => null,
            //                     "created_at" => 1604370469629,
            //                     "trade_volume" => 0,
            //                     "trade_turnover" => 0,
            //                     "fee" => 0,
            //                     "trade_avg_price" => null,
            //                     "margin_frozen" => 0,
            //                     "profit" => 0,
            //                     "status" => 3,
            //                     "order_source" => "web",
            //                     "order_id_str" => "773131315209248768",
            //                     "fee_asset" => "ADA",
            //                     "liquidation_type" => null,
            //                     "canceled_at" => null,
            //                     "is_tpsl" => 0,
            //                     "update_time" => 1606975980467,
            //                     "real_profit" => 0
            //                 }
            //             ),
            //             "total_page" => 1,
            //             "current_page" => 1,
            //             "total_size" => 1
            //         ),
            //         "ts" => 1604370488518
            //     }
            //
            $orders = $this->safe_value($response, 'data');
            if (gettype($orders) !== 'array' || array_keys($orders) !== array_keys(array_keys($orders))) {
                $orders = $this->safe_value($orders, 'orders', array());
            }
            return $this->parse_orders($orders, $market, $since, $limit);
        }) ();
    }

    public function parse_order_status($status) {
        $statuses = array(
            // spot
            'partial-filled' => 'open',
            'partial-canceled' => 'canceled',
            'filled' => 'closed',
            'canceled' => 'canceled',
            'submitted' => 'open',
            'created' => 'open',  // For stop orders
            // contract
            '1' => 'open',
            '2' => 'open',
            '3' => 'open',
            '4' => 'open',
            '5' => 'canceled', // partially matched
            '6' => 'closed',
            '7' => 'canceled',
            '11' => 'canceling',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        //
        // spot
        //
        //     {
        //         $id =>  13997833014,
        //         symbol => "ethbtc",
        //         'account-id' =>  3398321,
        //         $amount => "0.045000000000000000",
        //         $price => "0.034014000000000000",
        //         'created-at' =>  1545836976871,
        //         $type => "sell-limit",
        //         'field-amount' => "0.045000000000000000", // they have fixed it for $filled-$amount
        //         'field-cash-amount' => "0.001530630000000000", // they have fixed it for $filled-cash-$amount
        //         'field-fees' => "0.000003061260000000", // they have fixed it for $filled-fees
        //         'finished-at' =>  1545837948214,
        //         source => "spot-api",
        //         state => "filled",
        //         'canceled-at' =>  0
        //     }
        //
        //     {
        //         $id =>  20395337822,
        //         symbol => "ethbtc",
        //         'account-id' =>  5685075,
        //         $amount => "0.001000000000000000",
        //         $price => "0.0",
        //         'created-at' =>  1545831584023,
        //         $type => "buy-$market",
        //         'field-amount' => "0.029100000000000000", // they have fixed it for $filled-$amount
        //         'field-cash-amount' => "0.000999788700000000", // they have fixed it for $filled-cash-$amount
        //         'field-fees' => "0.000058200000000000", // they have fixed it for $filled-fees
        //         'finished-at' =>  1545831584181,
        //         source => "spot-api",
        //         state => "filled",
        //         'canceled-at' =>  0
        //     }
        //
        // linear swap cross margin createOrder
        //
        //     {
        //         "order_id":924660854912552960,
        //         "order_id_str":"924660854912552960"
        //     }
        //
        // contracts fetchOrder
        //
        //     {
        //         "business_type":"swap",
        //         "contract_type":"swap",
        //         "pair":"BTC-USDT",
        //         "symbol":"BTC",
        //         "contract_code":"BTC-USDT",
        //         "volume":1,
        //         "price":3000,
        //         "order_price_type":"limit",
        //         "order_type":1,
        //         "direction":"buy",
        //         "offset":"open",
        //         "lever_rate":1,
        //         "order_id":924912513206878210,
        //         "client_order_id":null,
        //         "created_at":1640557927189,
        //         "trade_volume":0,
        //         "trade_turnover":0,
        //         "fee":0,
        //         "trade_avg_price":null,
        //         "margin_frozen":3.000000000000000000,
        //         "profit":0,
        //         "status":3,
        //         "order_source":"api",
        //         "order_id_str":"924912513206878210",
        //         "fee_asset":"USDT",
        //         "liquidation_type":"0",
        //         "canceled_at":0,
        //         "margin_asset":"USDT",
        //         "margin_account":"USDT",
        //         "margin_mode":"cross",
        //         "is_tpsl":0,
        //         "real_profit":0
        //     }
        //
        // contracts fetchOrder detailed
        //
        //     {
        //         "symbol" => "BTC",
        //         "contract_code" => "BTC-USDT",
        //         "instrument_price" => 0,
        //         "final_interest" => 0,
        //         "adjust_value" => 0,
        //         "lever_rate" => 10,
        //         "direction" => "sell",
        //         "offset" => "open",
        //         "volume" => 1.000000000000000000,
        //         "price" => 13059.800000000000000000,
        //         "created_at" => 1603703614712,
        //         "canceled_at" => 0,
        //         "order_source" => "api",
        //         "order_price_type" => "opponent",
        //         "margin_frozen" => 0,
        //         "profit" => 0,
        //         "trades" => array(
        //             {
        //                 "trade_id" => 131560927,
        //                 "trade_price" => 13059.800000000000000000,
        //                 "trade_volume" => 1.000000000000000000,
        //                 "trade_turnover" => 13.059800000000000000,
        //                 "trade_fee" => -0.005223920000000000,
        //                 "created_at" => 1603703614715,
        //                 "role" => "taker",
        //                 "fee_asset" => "USDT",
        //                 "profit" => 0,
        //                 "real_profit" => 0,
        //                 "id" => "131560927-770334322963152896-1"
        //             }
        //         ),
        //         "total_page" => 1,
        //         "current_page" => 1,
        //         "total_size" => 1,
        //         "liquidation_type" => "0",
        //         "fee_asset" => "USDT",
        //         "fee" => -0.005223920000000000,
        //         "order_id" => 770334322963152896,
        //         "order_id_str" => "770334322963152896",
        //         "client_order_id" => 57012021045,
        //         "order_type" => "1",
        //         "status" => 6,
        //         "trade_avg_price" => 13059.800000000000000000,
        //         "trade_turnover" => 13.059800000000000000,
        //         "trade_volume" => 1.000000000000000000,
        //         "margin_asset" => "USDT",
        //         "margin_mode" => "isolated",
        //         "margin_account" => "BTC-USDT",
        //         "real_profit" => 0,
        //         "is_tpsl" => 0
        //     }
        //
        // fetchOrders
        //
        //     {
        //         "order_id" => 773131315209248768,
        //         "contract_code" => "ADA201225",
        //         "symbol" => "ADA",
        //         "lever_rate" => 20,
        //         "direction" => "buy",
        //         "offset" => "close",
        //         "volume" => 1,
        //         "price" => 0.0925,
        //         "create_date" => 1604370469629,
        //         "update_time" => 1603704221118,
        //         "order_source" => "web",
        //         "order_price_type" => 6,
        //         "order_type" => 1,
        //         "margin_frozen" => 0,
        //         "profit" => 0,
        //         "contract_type" => "quarter",
        //         "trade_volume" => 0,
        //         "trade_turnover" => 0,
        //         "fee" => 0,
        //         "trade_avg_price" => 0,
        //         "status" => 3,
        //         "order_id_str" => "773131315209248768",
        //         "fee_asset" => "ADA",
        //         "liquidation_type" => "0",
        //         "is_tpsl" => 0,
        //         "real_profit" => 0
        //         "margin_asset" => "USDT",
        //         "margin_mode" => "cross",
        //         "margin_account" => "USDT",
        //         "trade_partition" => "USDT", // only in isolated & cross of linear
        //         "reduce_only" => "1", // only in isolated & cross of linear
        //         "contract_type" => "quarter", // only in cross-margin (inverse & linear)
        //         "pair" => "BTC-USDT", // only in cross-margin (inverse & linear)
        //         "business_type" => "futures" // only in cross-margin (inverse & linear)
        //     }
        //
        $id = $this->safe_string_2($order, 'id', 'order_id_str');
        $side = $this->safe_string($order, 'direction');
        $type = $this->safe_string($order, 'order_price_type');
        if (is_array($order) && array_key_exists('type', $order)) {
            $orderType = explode('-', $order['type']);
            $side = $orderType[0];
            $type = $orderType[1];
        }
        $status = $this->parse_order_status($this->safe_string_2($order, 'state', 'status'));
        $marketId = $this->safe_string_2($order, 'contract_code', 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer_n($order, array( 'created_at', 'created-at', 'create_date' ));
        $clientOrderId = $this->safe_string_2($order, 'client_order_id', 'client-$order-id');
        $cost = null;
        $amount = null;
        if (($type !== null) && (mb_strpos($type, 'market') !== false)) {
            // for $market orders $amount is in quote currency, meaning it is the $cost
            if ($side === 'sell') {
                $cost = $this->safe_string($order, 'field-cash-amount');
            } else {
                $cost = $this->safe_string($order, 'amount');
            }
        } else {
            $amount = $this->safe_string_2($order, 'volume', 'amount');
            $cost = $this->safe_string_n($order, array( 'filled-cash-amount', 'field-cash-amount', 'trade_turnover' )); // same typo
        }
        $filled = $this->safe_string_n($order, array( 'filled-amount', 'field-amount', 'trade_volume' )); // typo in their API, $filled $amount
        $price = $this->safe_string($order, 'price');
        $feeCost = $this->safe_string_2($order, 'filled-fees', 'field-fees'); // typo in their API, $filled feeSide
        $feeCost = $this->safe_string($order, 'fee', $feeCost);
        $fee = null;
        if ($feeCost !== null) {
            $feeCurrency = null;
            $feeCurrencyId = $this->safe_string($order, 'fee_asset');
            if ($feeCurrencyId !== null) {
                $feeCurrency = $this->safe_currency_code($feeCurrencyId);
            } else {
                $feeCurrency = ($side === 'sell') ? $market['quote'] : $market['base'];
            }
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrency,
            );
        }
        $stopPrice = $this->safe_string($order, 'stop-price');
        $average = $this->safe_string($order, 'trade_avg_price');
        $trades = $this->safe_value($order, 'trades');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $market['symbol'],
            'type' => $type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'triggerPrice' => $stopPrice,
            'average' => $average,
            'cost' => $cost,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => $trades,
        ), $market);
    }

    public function create_order(string $symbol, $type, string $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float|null} $price the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @param {float|null} $params->stopPrice *spot and margin only* The $price at which a trigger order is triggered at
             * @param {string|null} $params->operator *spot and margin only* gte or lte, trigger $price condition
             * @param {string|null} $params->offset *contract only* 'open', 'close', or 'both', required in hedge mode
             * @param {bool|null} $params->postOnly *contract only* true or false
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            list($marketType, $query) = $this->handle_market_type_and_params('createOrder', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'createSpotOrder',
                'swap' => 'createContractOrder',
                'future' => 'createContractOrder',
            ));
            if ($method === null) {
                throw new NotSupported($this->id . ' createOrder() does not support ' . $marketType . ' markets yet');
            }
            return Async\await($this->$method ($symbol, $type, $side, $amount, $price, $query));
        }) ();
    }

    public function create_spot_order(string $symbol, $type, $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            Async\await($this->load_markets());
            Async\await($this->load_accounts());
            $market = $this->market($symbol);
            $accountId = Async\await($this->fetch_account_id_by_type($market['type']));
            $request = array(
                // spot -----------------------------------------------------------
                'account-id' => $accountId,
                'symbol' => $market['id'],
                // 'type' => $side . '-' . $type, // buy-$market, sell-$market, buy-limit, sell-limit, buy-ioc, sell-ioc, buy-limit-maker, sell-limit-maker, buy-stop-limit, sell-stop-limit, buy-limit-fok, sell-limit-fok, buy-stop-limit-fok, sell-stop-limit-fok
                // 'amount' => $this->amount_to_precision($symbol, $amount), // for buy $market orders it's the order cost
                // 'price' => $this->price_to_precision($symbol, $price),
                // 'source' => 'spot-api', // optional, spot-api, margin-api = isolated margin, super-margin-api = cross margin, c2c-margin-api
                // 'client-order-id' => $clientOrderId, // optional, max 64 chars, must be unique within 8 hours
                // 'stop-price' => $this->price_to_precision($symbol, $stopPrice), // trigger $price for stop limit orders
                // 'operator' => 'gte', // gte, lte, trigger $price condition
            );
            $orderType = str_replace('buy-', '', $type);
            $orderType = str_replace('sell-', '', $orderType);
            $options = $this->safe_value($this->options, $market['type'], array());
            $stopPrice = $this->safe_string_2($params, 'stopPrice', 'stop-price');
            if ($stopPrice === null) {
                $stopOrderTypes = $this->safe_value($options, 'stopOrderTypes', array());
                if (is_array($stopOrderTypes) && array_key_exists($orderType, $stopOrderTypes)) {
                    throw new ArgumentsRequired($this->id . ' createOrder() requires a $stopPrice or a stop-$price parameter for a stop order');
                }
            } else {
                $stopOperator = $this->safe_string($params, 'operator');
                if ($stopOperator === null) {
                    throw new ArgumentsRequired($this->id . ' createOrder() requires an operator parameter "gte" or "lte" for a stop order');
                }
                $params = $this->omit($params, array( 'stopPrice', 'stop-price' ));
                $request['stop-price'] = $this->price_to_precision($symbol, $stopPrice);
                $request['operator'] = $stopOperator;
                if (($orderType === 'limit') || ($orderType === 'limit-fok')) {
                    $orderType = 'stop-' . $orderType;
                } elseif (($orderType !== 'stop-limit') && ($orderType !== 'stop-limit-fok')) {
                    throw new NotSupported($this->id . ' createOrder() does not support ' . $type . ' orders');
                }
            }
            $postOnly = null;
            list($postOnly, $params) = $this->handle_post_only($orderType === 'market', $orderType === 'limit-maker', $params);
            if ($postOnly) {
                $orderType = 'limit-maker';
            }
            $request['type'] = $side . '-' . $orderType;
            $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'client-order-id'); // must be 64 chars max and unique within 24 hours
            if ($clientOrderId === null) {
                $broker = $this->safe_value($this->options, 'broker', array());
                $brokerId = $this->safe_string($broker, 'id');
                $request['client-order-id'] = $brokerId . $this->uuid();
            } else {
                $request['client-order-id'] = $clientOrderId;
            }
            $params = $this->omit($params, array( 'clientOrderId', 'client-order-id', 'postOnly' ));
            if (($orderType === 'market') && ($side === 'buy')) {
                if ($this->options['createMarketBuyOrderRequiresPrice']) {
                    if ($price === null) {
                        throw new InvalidOrder($this->id . " $market buy order requires $price argument to calculate cost (total $amount of quote currency to spend for buying, $amount * $price). To switch off this warning exception and specify cost in the $amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");
                    } else {
                        // despite that cost = $amount * $price is in quote currency and should have quote precision
                        // the exchange API requires the cost supplied in 'amount' to be of base precision
                        // more about it here:
                        // https://github.com/ccxt/ccxt/pull/4395
                        // https://github.com/ccxt/ccxt/issues/7611
                        // we use amountToPrecision here because the exchange requires cost in base precision
                        $amountString = $this->number_to_string($amount);
                        $priceString = $this->number_to_string($price);
                        $request['amount'] = $this->cost_to_precision($symbol, Precise::string_mul($amountString, $priceString));
                    }
                } else {
                    $request['amount'] = $this->cost_to_precision($symbol, $amount);
                }
            } else {
                $request['amount'] = $this->amount_to_precision($symbol, $amount);
            }
            $limitOrderTypes = $this->safe_value($options, 'limitOrderTypes', array());
            if (is_array($limitOrderTypes) && array_key_exists($orderType, $limitOrderTypes)) {
                $request['price'] = $this->price_to_precision($symbol, $price);
            }
            $response = Async\await($this->spotPrivatePostV1OrderOrdersPlace (array_merge($request, $params)));
            //
            // spot
            //
            //     array("status":"ok","data":"438398393065481")
            //
            $id = $this->safe_string($response, 'data');
            return array(
                'info' => $response,
                'id' => $id,
                'timestamp' => null,
                'datetime' => null,
                'lastTradeTimestamp' => null,
                'status' => null,
                'symbol' => null,
                'type' => null,
                'side' => null,
                'price' => null,
                'amount' => null,
                'filled' => null,
                'remaining' => null,
                'cost' => null,
                'trades' => null,
                'fee' => null,
                'clientOrderId' => null,
                'average' => null,
            );
        }) ();
    }

    public function create_contract_order(string $symbol, $type, $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            $offset = $this->safe_string($params, 'offset');
            $stopPrice = $this->safe_string($params, 'stopPrice');
            if ($stopPrice !== null) {
                throw new NotSupported($this->id . ' createOrder() supports tp_trigger_price . tp_order_price for take profit orders and/or sl_trigger_price . sl_order $price for stop loss orders, stop orders are supported only with open long orders and open short orders');
            }
            $market = $this->market($symbol);
            $request = array(
                // 'symbol' => 'BTC', // optional, case-insensitive, both uppercase and lowercase are supported, "BTC", "ETH", ...
                // 'contract_type' => 'this_week', // optional, this_week, next_week, quarter, next_quarter
                'contract_code' => $market['id'], // optional BTC180914
                // 'client_order_id' => $clientOrderId, // optional, must be less than 9223372036854775807
                // 'price' => $this->price_to_precision($symbol, $price), // optional
                'volume' => $this->amount_to_precision($symbol, $amount),
                'direction' => $side, // buy, sell
                // 'offset' => $offset, // open, close, both
                //
                //     direction buy, $offset open = open long
                //     direction sell, $offset close = close long
                //     direction sell, $offset open = open short
                //     direction buy, $offset close = close short
                //
                // 'reduce_only' => 0, // 1 or 0, in hedge mode it is invalid, and in one-way mode its value is 0 when not filled
                'lever_rate' => 1, // required, using leverage greater than 20x requires prior approval of high-leverage agreement
                // 'order_price_type' => 'limit', // required
                //
                //     order_price_type can be:
                //
                //     limit
                //     opponent // BBO
                //     post_only
                //     optimal_5
                //     optimal_10
                //     optimal_20
                //     ioc
                //     fok
                //     opponent_ioc // IOC order using the BBO $price
                //     optimal_5_ioc
                //     optimal_10_ioc
                //     optimal_20_ioc
                //     opponent_fok // FOK order using the BBO $price
                //     optimal_5_fok
                //     optimal_10_fok
                //     optimal_20_fok
                //
                // 'tp_trigger_price' => $this->price_to_precision($symbol, triggerPrice),
                // 'tp_order_price' => $this->price_to_precision($symbol, $price),
                // 'tp_order_price_type' => 'limit', // limit，optimal_5，optimal_10，optimal_20
                // 'sl_trigger_price' => $this->price_to_precision($symbol, stopLossPrice),
                // 'sl_order_price' => $this->price_to_precision($symbol, $price),
                // 'sl_order_price_type' => 'limit', // limit，optimal_5，optimal_10，optimal_20
            );
            $stopLossOrderPrice = $this->safe_string($params, 'sl_order_price');
            $stopLossTriggerPrice = $this->safe_string($params, 'sl_trigger_price');
            $takeProfitOrderPrice = $this->safe_string($params, 'tp_order_price');
            $takeProfitTriggerPrice = $this->safe_string($params, 'tp_trigger_price');
            $isOpenOrder = ($offset === 'open');
            $isStopOrder = false;
            if ($stopLossTriggerPrice !== null) {
                $request['sl_trigger_price'] = $this->price_to_precision($symbol, $stopLossTriggerPrice);
                $isStopOrder = true;
                if ($price !== null) {
                    $request['sl_order_price'] = $this->price_to_precision($symbol, $price);
                }
            }
            if ($stopLossOrderPrice !== null) {
                $request['sl_order_price'] = $this->price_to_precision($symbol, $stopLossOrderPrice);
                $isStopOrder = true;
            }
            if ($takeProfitTriggerPrice !== null) {
                $request['tp_trigger_price'] = $this->price_to_precision($symbol, $takeProfitTriggerPrice);
                $isStopOrder = true;
                if ($price !== null) {
                    $request['tp_order_price'] = $this->price_to_precision($symbol, $price);
                }
            }
            if ($takeProfitOrderPrice !== null) {
                $request['tp_order_price'] = $this->price_to_precision($symbol, $takeProfitOrderPrice);
                $isStopOrder = true;
            }
            if ($isStopOrder && !$isOpenOrder) {
                throw new NotSupported($this->id . ' createOrder() supports tp_trigger_price . tp_order_price for take profit orders and/or sl_trigger_price . sl_order $price for stop loss orders, stop orders are supported only with open long orders and open short orders');
            }
            $params = $this->omit($params, array( 'sl_order_price', 'sl_trigger_price', 'tp_order_price', 'tp_trigger_price' ));
            $postOnly = null;
            list($postOnly, $params) = $this->handle_post_only($type === 'market', $type === 'post_only', $params);
            if ($postOnly) {
                $type = 'post_only';
            }
            if ($type === 'limit' || $type === 'ioc' || $type === 'fok' || $type === 'post_only') {
                $request['price'] = $this->price_to_precision($symbol, $price);
            }
            $request['order_price_type'] = $type;
            $broker = $this->safe_value($this->options, 'broker', array());
            $brokerId = $this->safe_string($broker, 'id');
            $request['channel_code'] = $brokerId;
            $clientOrderId = $this->safe_string_2($params, 'client_order_id', 'clientOrderId');
            if ($clientOrderId !== null) {
                $request['client_order_id'] = $clientOrderId;
                $params = $this->omit($params, array( 'client_order_id', 'clientOrderId' ));
            }
            $method = null;
            if ($market['linear']) {
                $marginMode = null;
                list($marginMode, $params) = $this->handle_margin_mode_and_params('createOrder', $params);
                $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
                if ($marginMode === 'isolated') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapOrder';
                } elseif ($marginMode === 'cross') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCrossOrder';
                }
            } elseif ($market['inverse']) {
                if ($market['swap']) {
                    $method = 'contractPrivatePostSwapApiV1SwapOrder';
                } elseif ($market['future']) {
                    $method = 'contractPrivatePostApiV1ContractOrder';
                }
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // linear swap cross margin
            //
            //     {
            //         "status":"ok",
            //         "data":array(
            //             "order_id":924660854912552960,
            //             "order_id_str":"924660854912552960"
            //         ),
            //         "ts":1640497927185
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_order($data, $market);
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open order
             * @param {string} $id order $id
             * @param {string|null} $symbol unified $symbol of the $market the order was made in
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('cancelOrder', $market, $params);
            $request = array(
                // spot -----------------------------------------------------------
                // 'order-id' => 'id',
                // 'symbol' => $market['id'],
                // 'client-order-id' => $clientOrderId,
                // contracts ------------------------------------------------------
                // 'order_id' => $id,
                // 'client_order_id' => $clientOrderId,
                // 'contract_code' => $market['id'],
                // 'pair' => 'BTC-USDT',
                // 'contract_type' => 'this_week', // swap, this_week, next_week, quarter, next_ quarter
            );
            $method = null;
            if ($marketType === 'spot') {
                $clientOrderId = $this->safe_string_2($params, 'client-order-id', 'clientOrderId');
                $method = 'spotPrivatePostV1OrderOrdersOrderIdSubmitcancel';
                if ($clientOrderId === null) {
                    $request['order-id'] = $id;
                } else {
                    $request['client-order-id'] = $clientOrderId;
                    $method = 'spotPrivatePostV1OrderOrdersSubmitCancelClientOrder';
                    $params = $this->omit($params, array( 'client-order-id', 'clientOrderId' ));
                }
            } else {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol for ' . $marketType . ' orders');
                }
                $request['contract_code'] = $market['id'];
                if ($market['linear']) {
                    $marginMode = null;
                    list($marginMode, $params) = $this->handle_margin_mode_and_params('cancelOrder', $params);
                    $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
                    if ($marginMode === 'isolated') {
                        $method = 'contractPrivatePostLinearSwapApiV1SwapCancel';
                    } elseif ($marginMode === 'cross') {
                        $method = 'contractPrivatePostLinearSwapApiV1SwapCrossCancel';
                    }
                } elseif ($market['inverse']) {
                    if ($market['future']) {
                        $method = 'contractPrivatePostApiV1ContractCancel';
                        $request['symbol'] = $market['settleId'];
                    } elseif ($market['swap']) {
                        $method = 'contractPrivatePostSwapApiV1SwapCancel';
                    }
                } else {
                    throw new NotSupported($this->id . ' cancelOrder() does not support ' . $marketType . ' markets');
                }
                $clientOrderId = $this->safe_string_2($params, 'client_order_id', 'clientOrderId');
                if ($clientOrderId === null) {
                    $request['order_id'] = $id;
                } else {
                    $request['client_order_id'] = $clientOrderId;
                    $params = $this->omit($params, array( 'client_order_id', 'clientOrderId' ));
                }
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         'status' => 'ok',
            //         'data' => '10138899000',
            //     }
            //
            // linear swap cross margin
            //
            //     {
            //         "status":"ok",
            //         "data":array(
            //             "errors":array(),
            //             "successes":"924660854912552960"
            //         ),
            //         "ts":1640504486089
            //     }
            //
            return array_merge($this->parse_order($response, $market), array(
                'id' => $id,
                'status' => 'canceled',
            ));
        }) ();
    }

    public function cancel_orders($ids, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($ids, $symbol, $params) {
            /**
             * cancel multiple orders
             * @param {[string]} $ids order $ids
             * @param {string|null} $symbol unified $market $symbol, default is null
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('cancelOrders', $market, $params);
            $request = array(
                // spot -----------------------------------------------------------
                // 'order-ids' => $ids->jsoin (','), // max 50
                // 'client-order-ids' => implode(',', $ids), // max 50
                // contracts ------------------------------------------------------
                // 'order_id' => id, // comma separated, max 10
                // 'client_order_id' => clientOrderId, // comma separated, max 10
                // 'contract_code' => $market['id'],
                // 'symbol' => $market['settleId'],
            );
            $method = null;
            if ($marketType === 'spot') {
                $clientOrderIds = $this->safe_value_2($params, 'client-order-id', 'clientOrderId');
                $clientOrderIds = $this->safe_value_2($params, 'client-order-ids', 'clientOrderIds', $clientOrderIds);
                if ($clientOrderIds === null) {
                    if (gettype($clientOrderIds) === 'string') {
                        $request['order-ids'] = $ids;
                    } else {
                        $request['order-ids'] = implode(',', $ids);
                    }
                } else {
                    if (gettype($clientOrderIds) === 'string') {
                        $request['client-order-ids'] = $clientOrderIds;
                    } else {
                        $request['client-order-ids'] = implode(',', $clientOrderIds);
                    }
                    $params = $this->omit($params, array( 'client-order-id', 'client-order-ids', 'clientOrderId', 'clientOrderIds' ));
                }
                $method = 'spotPrivatePostV1OrderOrdersBatchcancel';
            } else {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' cancelOrders() requires a $symbol for ' . $marketType . ' orders');
                }
                $market = $this->market($symbol);
                $request['contract_code'] = $market['id'];
                if ($market['linear']) {
                    $marginMode = null;
                    list($marginMode, $params) = $this->handle_margin_mode_and_params('cancelOrders', $params);
                    $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
                    if ($marginMode === 'isolated') {
                        $method = 'contractPrivatePostLinearSwapApiV1SwapCancel';
                    } elseif ($marginMode === 'cross') {
                        $method = 'contractPrivatePostLinearSwapApiV1SwapCrossCancel';
                    }
                } elseif ($market['inverse']) {
                    if ($market['future']) {
                        $method = 'contractPrivatePostApiV1ContractCancel';
                        $request['symbol'] = $market['settleId'];
                    } elseif ($market['swap']) {
                        $method = 'contractPrivatePostSwapApiV1SwapCancel';
                    } else {
                        throw new NotSupported($this->id . ' cancelOrders() does not support ' . $marketType . ' markets');
                    }
                }
                $clientOrderIds = $this->safe_string_2($params, 'client_order_id', 'clientOrderId');
                $clientOrderIds = $this->safe_string_2($params, 'client_order_ids', 'clientOrderIds', $clientOrderIds);
                if ($clientOrderIds === null) {
                    $request['order_id'] = implode(',', $ids);
                } else {
                    $request['client_order_id'] = $clientOrderIds;
                    $params = $this->omit($params, array( 'client_order_id', 'client_order_ids', 'clientOrderId', 'clientOrderIds' ));
                }
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "status" => "ok",
            //         "data" => {
            //             "success" => array(
            //                 "5983466"
            //             ),
            //             "failed" => array(
            //                 array(
            //                     "err-msg" => "Incorrect order state",
            //                     "order-state" => 7,
            //                     "order-id" => "",
            //                     "err-code" => "order-orderstate-error",
            //                     "client-order-id" => "first"
            //                 ),
            //                 array(
            //                     "err-msg" => "Incorrect order state",
            //                     "order-state" => 7,
            //                     "order-id" => "",
            //                     "err-code" => "order-orderstate-error",
            //                     "client-order-id" => "second"
            //                 ),
            //                 {
            //                     "err-msg" => "The record is not found.",
            //                     "order-id" => "",
            //                     "err-code" => "base-not-found",
            //                     "client-order-id" => "third"
            //                 }
            //             )
            //         }
            //     }
            //
            // contracts
            //
            //     {
            //         "status" => "ok",
            //         "data" => {
            //             "errors" => array(
            //                 array(
            //                     "order_id" => "769206471845261312",
            //                     "err_code" => 1061,
            //                     "err_msg" => "This order doesnt exist."
            //                 }
            //             ),
            //             "successes" => "773120304138219520"
            //         ),
            //         "ts" => 1604367997451
            //     }
            //
            return $response;
        }) ();
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * cancel all open orders
             * @param {string|null} $symbol unified $market $symbol, only orders in the $market of this $symbol are cancelled when $symbol is not null
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('cancelAllOrders', $market, $params);
            $request = array(
                // spot -----------------------------------------------------------
                // 'account-id' => account['id'],
                // 'symbol' => $market['id'], // a list of comma-separated symbols, all symbols by default
                // 'types' 'string', buy-$market, sell-$market, buy-limit, sell-limit, buy-ioc, sell-ioc, buy-stop-limit, sell-stop-limit, buy-limit-fok, sell-limit-fok, buy-stop-limit-fok, sell-stop-limit-fok
                // 'side' => 'buy', // or 'sell'
                // 'size' => 100, // the number of orders to cancel 1-100
                // contract -------------------------------------------------------
                // 'symbol' => $market['settleId'], // required
                // 'contract_code' => $market['id'],
                // 'contract_type' => 'this_week', // swap, this_week, next_week, quarter, next_ quarter
                // 'direction' => 'buy' => // buy, sell
                // 'offset' => 'open', // open, close
            );
            $method = null;
            if ($marketType === 'spot') {
                if ($symbol !== null) {
                    $market = $this->market($symbol);
                    $request['symbol'] = $market['id'];
                }
                $method = 'spotPrivatePostV1OrderOrdersBatchCancelOpenOrders';
            } else {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol for ' . $marketType . ' orders');
                }
                $market = $this->market($symbol);
                $request['contract_code'] = $market['id'];
                if ($market['linear']) {
                    $marginMode = null;
                    list($marginMode, $params) = $this->handle_margin_mode_and_params('cancelAllOrders', $params);
                    $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
                    if ($marginMode === 'isolated') {
                        $method = 'contractPrivatePostLinearSwapApiV1SwapCancelallall';
                    } elseif ($marginMode === 'cross') {
                        $method = 'contractPrivatePostLinearSwapApiV1SwapCrossCancelall';
                    }
                } elseif ($market['inverse']) {
                    if ($marketType === 'future') {
                        $method = 'contractPrivatePostApiV1ContractCancelall';
                        $request['symbol'] = $market['settleId'];
                    } elseif ($marketType === 'swap') {
                        $method = 'contractPrivatePostSwapApiV1SwapCancelall';
                    } else {
                        throw new NotSupported($this->id . ' cancelAllOrders() does not support ' . $marketType . ' markets');
                    }
                }
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            //     {
            //         code => 200,
            //         data => {
            //             "success-count" => 2,
            //             "failed-count" => 0,
            //             "next-id" => 5454600
            //         }
            //     }
            //
            return $response;
        }) ();
    }

    public function parse_deposit_address($depositAddress, $currency = null) {
        //
        //     {
        //         $currency => "usdt",
        //         $address => "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //         addressTag => "",
        //         chain => "usdterc20", // trc20usdt, hrc20usdt, usdt, algousdt
        //     }
        //
        $address = $this->safe_string($depositAddress, 'address');
        $tag = $this->safe_string($depositAddress, 'addressTag');
        $currencyId = $this->safe_string($depositAddress, 'currency');
        $currency = $this->safe_currency($currencyId, $currency);
        $code = $this->safe_currency_code($currencyId, $currency);
        $note = $this->safe_string($depositAddress, 'note');
        $networkId = $this->safe_string($depositAddress, 'chain');
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => $this->network_id_to_code($networkId, $code),
            'note' => $note,
            'info' => $depositAddress,
        );
    }

    public function fetch_deposit_addresses_by_network(string $code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch a dictionary of addresses for a $currency, indexed by network
             * @param {string} $code unified $currency $code of the $currency for the deposit address
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=address-structure address structures~ indexed by the network
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
            );
            $response = Async\await($this->spotPrivateGetV2AccountDepositAddress (array_merge($request, $params)));
            //
            //     {
            //         $code => 200,
            //         $data => array(
            //             {
            //                 $currency => "eth",
            //                 address => "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
            //                 addressTag => "",
            //                 chain => "eth"
            //             }
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $parsed = $this->parse_deposit_addresses($data, [ $currency['code'] ], false);
            return $this->index_by($parsed, 'network');
        }) ();
    }

    public function fetch_deposit_address(string $code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the deposit address for a $currency associated with this account
             * @param {string} $code unified $currency $code
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=address-structure address structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            list($networkCode, $paramsOmited) = $this->handle_network_code_and_params($params);
            $indexedAddresses = Async\await($this->fetch_deposit_addresses_by_network($code, $paramsOmited));
            $selectedNetworkCode = $this->select_network_code_from_unified_networks($currency['code'], $networkCode, $indexedAddresses);
            return $indexedAddresses[$selectedNetworkCode];
        }) ();
    }

    public function fetch_withdraw_addresses(string $code, $note = null, $networkCode = null, $params = array ()) {
        return Async\async(function () use ($code, $note, $networkCode, $params) {
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
            );
            $response = Async\await($this->spotPrivateGetV2AccountWithdrawAddress (array_merge($request, $params)));
            //
            //     {
            //         $code => 200,
            //         $data => array(
            //             {
            //                 $currency => "eth",
            //                 chain => "eth"
            //                 $note => "Binance - TRC20",
            //                 addressTag => "",
            //                 $address => "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
            //             }
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $allAddresses = $this->parse_deposit_addresses($data, [ $currency['code'] ], false); // cjg => to do remove this weird object or array ambiguity
            $addresses = array();
            for ($i = 0; $i < count($allAddresses); $i++) {
                $address = $allAddresses[$i];
                $noteMatch = ($note === null) || ($address['note'] === $note);
                $networkMatch = ($networkCode === null) || ($address['network'] === $networkCode);
                if ($noteMatch && $networkMatch) {
                    $addresses[] = $address;
                }
            }
            return $addresses;
        }) ();
    }

    public function fetch_deposits(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all deposits made to an account
             * @param {string|null} $code unified $currency $code
             * @param {int|null} $since the earliest time in ms to fetch deposits for
             * @param {int|null} $limit the maximum number of deposits structures to retrieve
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            if ($limit === null || $limit > 100) {
                $limit = 100;
            }
            Async\await($this->load_markets());
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
            }
            $request = array(
                'type' => 'deposit',
                'direct' => 'next',
                'from' => 0, // From 'id' ... if you want to get results after a particular transaction id, pass the id in $params->from
            );
            if ($currency !== null) {
                $request['currency'] = $currency['id'];
            }
            if ($limit !== null) {
                $request['size'] = $limit; // max 100
            }
            $response = Async\await($this->spotPrivateGetV1QueryDepositWithdraw (array_merge($request, $params)));
            //
            //    {
            //         "status" => "ok",
            //         "data" => array(
            //             array(
            //                 "id" => "75115912",
            //                 "type" => "deposit",
            //                 "sub-type" => "NORMAL",
            //                 "request-id" => "trc20usdt-a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff-200",
            //                 "currency" => "usdt",
            //                 "chain" => "trc20usdt",
            //                 "tx-hash" => "a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff",
            //                 "amount" => "12.000000000000000000",
            //                 "from-addr-tag" => "",
            //                 "address-id" => "0",
            //                 "address" => "TRFTd1FxepQE6CnpwzUEMEbFaLm5bJK67s",
            //                 "address-tag" => "",
            //                 "fee" => "0",
            //                 "state" => "safe",
            //                 "wallet-confirm" => "2",
            //                 "created-at" => "1621843808662",
            //                 "updated-at" => "1621843857137"
            //             ),
            //         )
            //     }
            //
            return $this->parse_transactions($response['data'], $currency, $since, $limit);
        }) ();
    }

    public function fetch_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all withdrawals made from an account
             * @param {string|null} $code unified $currency $code
             * @param {int|null} $since the earliest time in ms to fetch withdrawals for
             * @param {int|null} $limit the maximum number of withdrawals structures to retrieve
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            if ($limit === null || $limit > 100) {
                $limit = 100;
            }
            Async\await($this->load_markets());
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
            }
            $request = array(
                'type' => 'withdraw',
                'direct' => 'next',
                'from' => 0, // From 'id' ... if you want to get results after a particular transaction id, pass the id in $params->from
            );
            if ($currency !== null) {
                $request['currency'] = $currency['id'];
            }
            if ($limit !== null) {
                $request['size'] = $limit; // max 100
            }
            $response = Async\await($this->spotPrivateGetV1QueryDepositWithdraw (array_merge($request, $params)));
            //
            //    {
            //         "status" => "ok",
            //         "data" => array(
            //             array(
            //                 "id" => "61335312",
            //                 "type" => "withdraw",
            //                 "sub-type" => "NORMAL",
            //                 "currency" => "usdt",
            //                 "chain" => "trc20usdt",
            //                 "tx-hash" => "30a3111f2fead74fae45c6218ca3150fc33cab2aa59cfe41526b96aae79ce4ec",
            //                 "amount" => "12.000000000000000000",
            //                 "from-addr-tag" => "",
            //                 "address-id" => "27321591",
            //                 "address" => "TRf5JacJQRsF4Nm2zu11W6maDGeiEWQu9e",
            //                 "address-tag" => "",
            //                 "fee" => "1.000000000000000000",
            //                 "state" => "confirmed",
            //                 "created-at" => "1621852316553",
            //                 "updated-at" => "1621852467041"
            //             ),
            //         )
            //     }
            //
            return $this->parse_transactions($response['data'], $currency, $since, $limit);
        }) ();
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits
        //
        //     array(
        //         "id" => "75115912",
        //         "type" => "deposit",
        //         "sub-$type" => "NORMAL",
        //         "request-id" => "trc20usdt-a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff-200",
        //         "currency" => "usdt",
        //         "chain" => "trc20usdt",
        //         "tx-hash" => "a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff",
        //         "amount" => "2849.000000000000000000",
        //         "from-addr-tag" => "",
        //         "address-id" => "0",
        //         "address" => "TRFTd1FxepQE6CnpwzUEMEbFaLm5bJK67s",
        //         "address-tag" => "",
        //         "fee" => "0",
        //         "state" => "safe",
        //         "wallet-confirm" => "2",
        //         "created-at" => "1621843808662",
        //         "updated-at" => "1621843857137"
        //     ),
        //
        // fetchWithdrawals
        //
        //     {
        //         "id" => "61335312",
        //         "type" => "withdraw",
        //         "sub-$type" => "NORMAL",
        //         "currency" => "usdt",
        //         "chain" => "trc20usdt",
        //         "tx-hash" => "30a3111f2fead74fae45c6218ca3150fc33cab2aa59cfe41526b96aae79ce4ec",
        //         "amount" => "12.000000000000000000",
        //         "from-addr-tag" => "",
        //         "address-id" => "27321591",
        //         "address" => "TRf5JacJQRsF4Nm2zu11W6maDGeiEWQu9e",
        //         "address-tag" => "",
        //         "fee" => "1.000000000000000000",
        //         "state" => "confirmed",
        //         "created-at" => "1621852316553",
        //         "updated-at" => "1621852467041"
        //     }
        //
        // withdraw
        //
        //     {
        //         "status" => "ok",
        //         "data" => "99562054"
        //     }
        //
        $timestamp = $this->safe_integer($transaction, 'created-at');
        $code = $this->safe_currency_code($this->safe_string($transaction, 'currency'));
        $type = $this->safe_string($transaction, 'type');
        if ($type === 'withdraw') {
            $type = 'withdrawal';
        }
        $feeCost = $this->safe_string($transaction, 'fee');
        if ($feeCost !== null) {
            $feeCost = Precise::string_abs($feeCost);
        }
        $networkId = $this->safe_string($transaction, 'chain');
        return array(
            'info' => $transaction,
            'id' => $this->safe_string_2($transaction, 'id', 'data'),
            'txid' => $this->safe_string($transaction, 'tx-hash'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => $this->network_id_to_code($networkId, $code),
            'address' => $this->safe_string($transaction, 'address'),
            'addressTo' => null,
            'addressFrom' => null,
            'tag' => $this->safe_string($transaction, 'address-tag'),
            'tagTo' => null,
            'tagFrom' => null,
            'type' => $type,
            'amount' => $this->safe_number($transaction, 'amount'),
            'currency' => $code,
            'status' => $this->parse_transaction_status($this->safe_string($transaction, 'state')),
            'updated' => $this->safe_integer($transaction, 'updated-at'),
            'fee' => array(
                'currency' => $code,
                'cost' => $this->parse_number($feeCost),
                'rate' => null,
            ),
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            // deposit $statuses
            'unknown' => 'failed',
            'confirming' => 'pending',
            'confirmed' => 'ok',
            'safe' => 'ok',
            'orphan' => 'failed',
            // withdrawal $statuses
            'submitted' => 'pending',
            'canceled' => 'canceled',
            'reexamine' => 'pending',
            'reject' => 'failed',
            'pass' => 'pending',
            'wallet-reject' => 'failed',
            // 'confirmed' => 'ok', // present in deposit $statuses
            'confirm-error' => 'failed',
            'repealed' => 'failed',
            'wallet-transfer' => 'pending',
            'pre-transfer' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function withdraw(string $code, $amount, $address, $tag = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string|null} $tag
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
            Async\await($this->load_markets());
            $this->check_address($address);
            $currency = $this->currency($code);
            $request = array(
                'address' => $address, // only supports existing addresses in your withdraw $address list
                'currency' => strtolower($currency['id']),
            );
            if ($tag !== null) {
                $request['addr-tag'] = $tag; // only for XRP?
            }
            $networkCode = null;
            list($networkCode, $params) = $this->handle_network_code_and_params($params);
            if ($networkCode !== null) {
                $request['chain'] = $this->network_code_to_id($networkCode, $code);
            }
            $amount = floatval($this->currency_to_precision($code, $amount, $networkCode));
            $withdrawOptions = $this->safe_value($this->options, 'withdraw', array());
            if ($this->safe_value($withdrawOptions, 'includeFee', false)) {
                $fee = $this->safe_number($params, 'fee');
                if ($fee === null) {
                    $currencies = Async\await($this->fetch_currencies());
                    $this->currencies = $this->deep_extend($this->currencies, $currencies);
                    $targetNetwork = $this->safe_value($currency['networks'], $networkCode, array());
                    $fee = $this->safe_number($targetNetwork, 'fee');
                    if ($fee === null) {
                        throw new ArgumentsRequired($this->id . ' withdraw() function can not find withdraw $fee for chosen network. You need to re-load markets with "exchange.loadMarkets(true)", or provide the "fee" parameter');
                    }
                }
                // $fee needs to be deducted from whole $amount
                $feeString = $this->currency_to_precision($code, $fee, $networkCode);
                $params = $this->omit($params, 'fee');
                $amountString = $this->number_to_string($amount);
                $amountSubtractedString = Precise::string_sub($amountString, $feeString);
                $amountSubtracted = floatval($amountSubtractedString);
                $request['fee'] = floatval($feeString);
                $amount = floatval($this->currency_to_precision($code, $amountSubtracted, $networkCode));
            }
            $request['amount'] = $amount;
            $response = Async\await($this->spotPrivatePostV1DwWithdrawApiCreate (array_merge($request, $params)));
            //
            //     {
            //         "status" => "ok",
            //         "data" => "99562054"
            //     }
            //
            return $this->parse_transaction($response, $currency);
        }) ();
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        // $transfer
        //
        //     {
        //         "data" => 12345,
        //         "status" => "ok"
        //     }
        //
        $id = $this->safe_string($transfer, 'data');
        $code = $this->safe_currency_code(null, $currency);
        return array(
            'info' => $transfer,
            'id' => $id,
            'timestamp' => null,
            'datetime' => null,
            'currency' => $code,
            'amount' => null,
            'fromAccount' => null,
            'toAccount' => null,
            'status' => null,
        );
    }

    public function transfer(string $code, $amount, $fromAccount, $toAccount, $params = array ()) {
        return Async\async(function () use ($code, $amount, $fromAccount, $toAccount, $params) {
            /**
             * transfer $currency internally between wallets on the same account
             * @see https://huobiapi.github.io/docs/dm/v1/en/#transfer-margin-between-spot-account-and-future-account
             * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-fund-between-spot-account-and-future-contract-account
             * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-transfer-margin-between-spot-account-and-usdt-margined-contracts-account
             * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-spot-trading-account-to-cross-margin-account-cross
             * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-spot-trading-account-to-isolated-margin-account-isolated
             * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-cross-margin-account-to-spot-trading-account-cross
             * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-isolated-margin-account-to-spot-trading-account-isolated
             * @param {string} $code unified $currency $code
             * @param {float} $amount amount to transfer
             * @param {string} $fromAccount account to transfer from 'spot', 'future', 'swap'
             * @param {string} $toAccount account to transfer to 'spot', 'future', 'swap'
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @param {string|null} $params->symbol used for isolated margin transfer
             * @param {string|null} $params->subType 'linear' or 'inverse', only used when transfering to/from swap accounts
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transfer-structure transfer structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
                'amount' => floatval($this->currency_to_precision($code, $amount)),
            );
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('transfer', null, $params);
            $method = null;
            $fromAccountId = $this->convert_type_to_account($fromAccount);
            $toAccountId = $this->convert_type_to_account($toAccount);
            $toCross = $toAccountId === 'cross';
            $fromCross = $fromAccountId === 'cross';
            $toIsolated = $this->in_array($toAccountId, $this->ids);
            $fromIsolated = $this->in_array($fromAccountId, $this->ids);
            $fromSpot = $fromAccountId === 'pro';
            $toSpot = $toAccountId === 'pro';
            if ($fromSpot && $toSpot) {
                throw new BadRequest($this->id . ' transfer () cannot make a transfer between ' . $fromAccount . ' and ' . $toAccount);
            }
            $fromOrToFuturesAccount = ($fromAccountId === 'futures') || ($toAccountId === 'futures');
            if ($fromOrToFuturesAccount) {
                $type = $fromAccountId . '-to-' . $toAccountId;
                $type = $this->safe_string($params, 'type', $type);
                $request['type'] = $type;
                $method = 'spotPrivatePostV1FuturesTransfer';
            } elseif ($fromSpot && $toCross) {
                $method = 'privatePostCrossMarginTransferIn';
            } elseif ($fromCross && $toSpot) {
                $method = 'privatePostCrossMarginTransferOut';
            } elseif ($fromSpot && $toIsolated) {
                $request['symbol'] = $toAccountId;
                $method = 'privatePostDwTransferInMargin';
            } elseif ($fromIsolated && $toSpot) {
                $request['symbol'] = $fromAccountId;
                $method = 'privatePostDwTransferOutMargin';
            } else {
                $method = 'v2PrivatePostAccountTransfer';
                if ($subType === 'linear') {
                    if (($fromAccountId === 'swap') || ($fromAccount === 'linear-swap')) {
                        $fromAccountId = 'linear-swap';
                    } else {
                        $toAccountId = 'linear-swap';
                    }
                    // check if cross-margin or isolated
                    $symbol = $this->safe_string($params, 'symbol');
                    $params = $this->omit($params, 'symbol');
                    if ($symbol !== null) {
                        $symbol = $this->market_id($symbol);
                        $request['margin-account'] = $symbol;
                    } else {
                        $request['margin-account'] = 'USDT'; // cross-margin
                    }
                }
                $request['from'] = $fromSpot ? 'spot' : $fromAccountId;
                $request['to'] = $toSpot ? 'spot' : $toAccountId;
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            //    {
            //        $code => '200',
            //        data => '660150061',
            //        message => 'Succeed',
            //        success => true,
            //        'print-log' => true
            //    }
            //
            return $this->parse_transfer($response, $currency);
        }) ();
    }

    public function fetch_borrow_rates_per_symbol($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetch borrow $rates for $currencies within individual markets
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=borrow-$rate-structure borrow $rate structures~ indexed by market $symbol
             */
            Async\await($this->load_markets());
            $response = Async\await($this->spotPrivateGetV1MarginLoanInfo ($params));
            //
            //    {
            //        "status" => "ok",
            //        "data" => array(
            //            {
            //                "symbol" => "1inchusdt",
            //                "currencies" => array(
            //                    array(
            //                        "currency" => "1inch",
            //                        "interest-$rate" => "0.00098",
            //                        "min-loan-amt" => "90.000000000000000000",
            //                        "max-loan-amt" => "1000.000000000000000000",
            //                        "loanable-amt" => "0.0",
            //                        "actual-$rate" => "0.00098"
            //                    ),
            //                    array(
            //                        "currency" => "usdt",
            //                        "interest-$rate" => "0.00098",
            //                        "min-loan-amt" => "100.000000000000000000",
            //                        "max-loan-amt" => "1000.000000000000000000",
            //                        "loanable-amt" => "0.0",
            //                        "actual-$rate" => "0.00098"
            //                    }
            //                )
            //            ),
            //            ...
            //        )
            //    }
            //
            $timestamp = $this->milliseconds();
            $data = $this->safe_value($response, 'data', array());
            $rates = array(
                'info' => $response,
            );
            for ($i = 0; $i < count($data); $i++) {
                $rate = $data[$i];
                $currencies = $this->safe_value($rate, 'currencies', array());
                $symbolRates = array();
                for ($j = 0; $j < count($currencies); $j++) {
                    $currency = $currencies[$j];
                    $currencyId = $this->safe_string($currency, 'currency');
                    $code = $this->safe_currency_code($currencyId, 'currency');
                    $symbolRates[$code] = array(
                        'currency' => $code,
                        'rate' => $this->safe_number($currency, 'actual-rate'),
                        'span' => 86400000,
                        'timestamp' => $timestamp,
                        'datetime' => $this->iso8601($timestamp),
                    );
                }
                $marketId = $this->safe_string($rate, 'symbol');
                $symbol = $this->safe_symbol($marketId);
                $rates[$symbol] = $symbolRates;
            }
            return $rates;
        }) ();
    }

    public function fetch_borrow_rates($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetch the borrow interest $rates of all $currencies
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=borrow-rate-structure borrow rate structures~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->spotPrivateGetV1MarginLoanInfo ($params));
            // {
            //     "status" => "ok",
            //     "data" => array(
            //         {
            //             "symbol" => "1inchusdt",
            //             "currencies" => array(
            //                 array(
            //                     "currency" => "1inch",
            //                     "interest-rate" => "0.00098",
            //                     "min-loan-amt" => "90.000000000000000000",
            //                     "max-loan-amt" => "1000.000000000000000000",
            //                     "loanable-amt" => "0.0",
            //                     "actual-rate" => "0.00098"
            //                 ),
            //                 array(
            //                     "currency" => "usdt",
            //                     "interest-rate" => "0.00098",
            //                     "min-loan-amt" => "100.000000000000000000",
            //                     "max-loan-amt" => "1000.000000000000000000",
            //                     "loanable-amt" => "0.0",
            //                     "actual-rate" => "0.00098"
            //                 }
            //             )
            //         ),
            //         ...
            //     )
            // }
            $timestamp = $this->milliseconds();
            $data = $this->safe_value($response, 'data', array());
            $rates = array();
            for ($i = 0; $i < count($data); $i++) {
                $market = $data[$i];
                $currencies = $this->safe_value($market, 'currencies', array());
                for ($j = 0; $j < count($currencies); $j++) {
                    $currency = $currencies[$j];
                    $currencyId = $this->safe_string($currency, 'currency');
                    $code = $this->safe_currency_code($currencyId, 'currency');
                    $rates[$code] = array(
                        'currency' => $code,
                        'rate' => $this->safe_number($currency, 'actual-rate'),
                        'span' => 86400000,
                        'timestamp' => $timestamp,
                        'datetime' => $this->iso8601($timestamp),
                        'info' => null,
                    );
                }
            }
            return $rates;
        }) ();
    }

    public function fetch_funding_rate_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches historical funding rate prices
             * @param {string|null} $symbol unified $symbol of the $market to fetch the funding rate history for
             * @param {int|null} $since not used by huobi, but filtered internally by ccxt
             * @param {int|null} $limit not used by huobi, but filtered internally by ccxt
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure funding rate structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'contract_code' => $market['id'],
            );
            $method = null;
            if ($market['inverse']) {
                $method = 'contractPublicGetSwapApiV1SwapHistoricalFundingRate';
            } elseif ($market['linear']) {
                $method = 'contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate';
            } else {
                throw new NotSupported($this->id . ' fetchFundingRateHistory() supports inverse and linear swaps only');
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // {
            //     "status" => "ok",
            //     "data" => array(
            //         "total_page" => 62,
            //         "current_page" => 1,
            //         "total_size" => 1237,
            //         "data" => array(
            //             array(
            //                 "avg_premium_index" => "-0.000208064395065541",
            //                 "funding_rate" => "0.000100000000000000",
            //                 "realized_rate" => "0.000100000000000000",
            //                 "funding_time" => "1638921600000",
            //                 "contract_code" => "BTC-USDT",
            //                 "symbol" => "BTC",
            //                 "fee_asset" => "USDT"
            //             ),
            //         )
            //     ),
            //     "ts" => 1638939294277
            // }
            //
            $data = $this->safe_value($response, 'data');
            $result = $this->safe_value($data, 'data', array());
            $rates = array();
            for ($i = 0; $i < count($result); $i++) {
                $entry = $result[$i];
                $marketId = $this->safe_string($entry, 'contract_code');
                $symbol = $this->safe_symbol($marketId);
                $timestamp = $this->safe_integer($entry, 'funding_time');
                $rates[] = array(
                    'info' => $entry,
                    'symbol' => $symbol,
                    'fundingRate' => $this->safe_number($entry, 'funding_rate'),
                    'timestamp' => $timestamp,
                    'datetime' => $this->iso8601($timestamp),
                );
            }
            $sorted = $this->sort_by($rates, 'timestamp');
            return $this->filter_by_symbol_since_limit($sorted, $market['symbol'], $since, $limit);
        }) ();
    }

    public function parse_funding_rate($contract, $market = null) {
        //
        // {
        //      "status" => "ok",
        //      "data" => array(
        //         "estimated_rate" => "0.000100000000000000",
        //         "funding_rate" => "0.000100000000000000",
        //         "contract_code" => "BCH-USD",
        //         "symbol" => "BCH",
        //         "fee_asset" => "BCH",
        //         "funding_time" => "1639094400000",
        //         "next_funding_time" => "1639123200000"
        //     ),
        //     "ts" => 1639085854775
        // }
        //
        $nextFundingRate = $this->safe_number($contract, 'estimated_rate');
        $fundingTimestamp = $this->safe_integer($contract, 'funding_time');
        $nextFundingTimestamp = $this->safe_integer($contract, 'next_funding_time');
        $marketId = $this->safe_string($contract, 'contract_code');
        $symbol = $this->safe_symbol($marketId, $market);
        return array(
            'info' => $contract,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'fundingRate' => $this->safe_number($contract, 'funding_rate'),
            'fundingTimestamp' => $fundingTimestamp,
            'fundingDatetime' => $this->iso8601($fundingTimestamp),
            'nextFundingRate' => $nextFundingRate,
            'nextFundingTimestamp' => $nextFundingTimestamp,
            'nextFundingDatetime' => $this->iso8601($nextFundingTimestamp),
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function fetch_funding_rate(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch the current funding rate
             * @param {string} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=funding-rate-structure funding rate structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $method = null;
            if ($market['inverse']) {
                $method = 'contractPublicGetSwapApiV1SwapFundingRate';
            } elseif ($market['linear']) {
                $method = 'contractPublicGetLinearSwapApiV1SwapFundingRate';
            } else {
                throw new NotSupported($this->id . ' fetchFundingRate() supports inverse and linear swaps only');
            }
            $request = array(
                'contract_code' => $market['id'],
            );
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // {
            //     "status" => "ok",
            //     "data" => array(
            //         "estimated_rate" => "0.000100000000000000",
            //         "funding_rate" => "0.000100000000000000",
            //         "contract_code" => "BTC-USDT",
            //         "symbol" => "BTC",
            //         "fee_asset" => "USDT",
            //         "funding_time" => "1603699200000",
            //         "next_funding_time" => "1603728000000"
            //     ),
            //     "ts" => 1603696494714
            // }
            //
            $result = $this->safe_value($response, 'data', array());
            return $this->parse_funding_rate($result, $market);
        }) ();
    }

    public function fetch_funding_rates(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetch the funding rate for multiple markets
             * @param {[string]|null} $symbols list of unified market $symbols
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=funding-rates-structure funding rates structures~, indexe by market $symbols
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $options = $this->safe_value($this->options, 'fetchFundingRates', array());
            $defaultSubType = $this->safe_string($this->options, 'defaultSubType', 'inverse');
            $subType = $this->safe_string($options, 'subType', $defaultSubType);
            $subType = $this->safe_string($params, 'subType', $subType);
            $request = array(
                // 'contract_code' => market['id'],
            );
            $method = $this->get_supported_mapping($subType, array(
                'linear' => 'contractPublicGetLinearSwapApiV1SwapBatchFundingRate',
                'inverse' => 'contractPublicGetSwapApiV1SwapBatchFundingRate',
            ));
            $params = $this->omit($params, 'subType');
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             array(
            //                 "estimated_rate" => "0.000100000000000000",
            //                 "funding_rate" => "0.000100000000000000",
            //                 "contract_code" => "MANA-USDT",
            //                 "symbol" => "MANA",
            //                 "fee_asset" => "USDT",
            //                 "funding_time" => "1643356800000",
            //                 "next_funding_time" => "1643385600000",
            //                 "trade_partition":"USDT"
            //             ),
            //         ),
            //         "ts" => 1643346173103
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $result = $this->parse_funding_rates($data);
            return $this->filter_by_array($result, 'symbol', $symbols);
        }) ();
    }

    public function fetch_borrow_interest(?string $code = null, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $symbol, $since, $limit, $params) {
            /**
             * fetch the $interest owed by the user for borrowing $currency for margin trading
             * @param {string|null} $code unified $currency $code
             * @param {string|null} $symbol unified $market $symbol when fetch $interest in isolated markets
             * @param {int|null} $since the earliest time in ms to fetch borrrow $interest for
             * @param {int|null} $limit the maximum number of structures to retrieve
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=borrow-$interest-structure borrow $interest structures~
             */
            Async\await($this->load_markets());
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('fetchBorrowInterest', $params);
            $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
            $request = array();
            if ($since !== null) {
                $request['start-date'] = $this->yyyymmdd($since);
            }
            if ($limit !== null) {
                $request['size'] = $limit;
            }
            $market = null;
            $method = null;
            if ($marginMode === 'isolated') {
                $method = 'privateGetMarginLoanOrders';
                if ($symbol !== null) {
                    $market = $this->market($symbol);
                    $request['symbol'] = $market['id'];
                }
            } else {  // Cross
                $method = 'privateGetCrossMarginLoanOrders';
                if ($code !== null) {
                    $currency = $this->currency($code);
                    $request['currency'] = $currency['id'];
                }
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            //    {
            //        "status":"ok",
            //        "data":array(
            //            {
            //                "loan-balance":"0.100000000000000000",
            //                "interest-balance":"0.000200000000000000",
            //                "loan-amount":"0.100000000000000000",
            //                "accrued-at":1511169724531,
            //                "interest-amount":"0.000200000000000000",
            //                "filled-points":"0.2",
            //                "filled-ht":"0.2",
            //                "currency":"btc",
            //                "id":394,
            //                "state":"accrual",
            //                "account-id":17747,
            //                "user-id":119913,
            //                "created-at":1511169724531
            //            }
            //        )
            //    }
            //
            $data = $this->safe_value($response, 'data');
            $interest = $this->parse_borrow_interests($data, $market);
            return $this->filter_by_currency_since_limit($interest, $code, $since, $limit);
        }) ();
    }

    public function parse_borrow_interest($info, $market = null) {
        // isolated
        //    {
        //        "interest-rate":"0.000040830000000000",
        //        "user-id":35930539,
        //        "account-id":48916071,
        //        "updated-at":1649320794195,
        //        "deduct-rate":"1",
        //        "day-interest-rate":"0.000980000000000000",
        //        "hour-interest-rate":"0.000040830000000000",
        //        "loan-balance":"100.790000000000000000",
        //        "interest-balance":"0.004115260000000000",
        //        "loan-amount":"100.790000000000000000",
        //        "paid-coin":"0.000000000000000000",
        //        "accrued-at":1649320794148,
        //        "created-at":1649320794148,
        //        "interest-amount":"0.004115260000000000",
        //        "deduct-amount":"0",
        //        "deduct-currency":"",
        //        "paid-point":"0.000000000000000000",
        //        "currency":"usdt",
        //        "symbol":"ltcusdt",
        //        "id":20242721,
        //    }
        //
        // cross
        //   {
        //       "id":3416576,
        //       "user-id":35930539,
        //       "account-id":48956839,
        //       "currency":"usdt",
        //       "loan-amount":"102",
        //       "loan-balance":"102",
        //       "interest-amount":"0.00416466",
        //       "interest-balance":"0.00416466",
        //       "created-at":1649322735333,
        //       "accrued-at":1649322735382,
        //       "state":"accrual",
        //       "filled-points":"0",
        //       "filled-ht":"0"
        //   }
        //
        $marketId = $this->safe_string($info, 'symbol');
        $marginMode = ($marketId === null) ? 'cross' : 'isolated';
        $market = $this->safe_market($marketId);
        $symbol = $this->safe_string($market, 'symbol');
        $timestamp = $this->safe_number($info, 'accrued-at');
        return array(
            'account' => ($marginMode === 'isolated') ? $symbol : 'cross',  // deprecated
            'symbol' => $symbol,
            'marginMode' => $marginMode,
            'currency' => $this->safe_currency_code($this->safe_string($info, 'currency')),
            'interest' => $this->safe_number($info, 'interest-amount'),
            'interestRate' => $this->safe_number($info, 'interest-rate'),
            'amountBorrowed' => $this->safe_number($info, 'loan-amount'),
            'timestamp' => $timestamp,  // Interest accrued time
            'datetime' => $this->iso8601($timestamp),
            'info' => $info,
        );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = '/';
        $query = $this->omit($params, $this->extract_params($path));
        if (gettype($api) === 'string') {
            // signing implementation for the old endpoints
            if (($api === 'public') || ($api === 'private')) {
                $url .= $this->version;
            } elseif (($api === 'v2Public') || ($api === 'v2Private')) {
                $url .= 'v2';
            }
            $url .= '/' . $this->implode_params($path, $params);
            if ($api === 'private' || $api === 'v2Private') {
                $this->check_required_credentials();
                $timestamp = $this->ymdhms($this->milliseconds(), 'T');
                $request = array(
                    'SignatureMethod' => 'HmacSHA256',
                    'SignatureVersion' => '2',
                    'AccessKeyId' => $this->apiKey,
                    'Timestamp' => $timestamp,
                );
                if ($method !== 'POST') {
                    $request = array_merge($request, $query);
                }
                $sortedRequest = $this->keysort($request);
                $auth = $this->urlencode($sortedRequest);
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                $payload = implode("\n", array($method, $this->hostname, $url, $auth)); // eslint-disable-line quotes
                $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256', 'base64');
                $auth .= '&' . $this->urlencode(array( 'Signature' => $signature ));
                $url .= '?' . $auth;
                if ($method === 'POST') {
                    $body = $this->json($query);
                    $headers = array(
                        'Content-Type' => 'application/json',
                    );
                } else {
                    $headers = array(
                        'Content-Type' => 'application/x-www-form-urlencoded',
                    );
                }
            } else {
                if ($query) {
                    $url .= '?' . $this->urlencode($query);
                }
            }
            $url = $this->implode_params($this->urls['api'][$api], array(
                'hostname' => $this->hostname,
            )) . $url;
        } else {
            // signing implementation for the new endpoints
            // list($type, $access) = $api;
            $type = $this->safe_string($api, 0);
            $access = $this->safe_string($api, 1);
            $levelOneNestedPath = $this->safe_string($api, 2);
            $levelTwoNestedPath = $this->safe_string($api, 3);
            $hostname = null;
            $hostnames = $this->safe_value($this->urls['hostnames'], $type);
            if (gettype($hostnames) !== 'string') {
                $hostnames = $this->safe_value($hostnames, $levelOneNestedPath);
                if ((gettype($hostname) !== 'string') && ($levelTwoNestedPath !== null)) {
                    $hostnames = $this->safe_value($hostnames, $levelTwoNestedPath);
                }
            }
            $hostname = $hostnames;
            $url .= $this->implode_params($path, $params);
            if ($access === 'public') {
                if ($query) {
                    $url .= '?' . $this->urlencode($query);
                }
            } elseif ($access === 'private') {
                $this->check_required_credentials();
                $timestamp = $this->ymdhms($this->milliseconds(), 'T');
                $request = array(
                    'SignatureMethod' => 'HmacSHA256',
                    'SignatureVersion' => '2',
                    'AccessKeyId' => $this->apiKey,
                    'Timestamp' => $timestamp,
                );
                if ($method !== 'POST') {
                    $request = array_merge($request, $query);
                }
                $request = $this->keysort($request);
                $auth = $this->urlencode($request);
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                $payload = implode("\n", array($method, $hostname, $url, $auth)); // eslint-disable-line quotes
                $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256', 'base64');
                $auth .= '&' . $this->urlencode(array( 'Signature' => $signature ));
                $url .= '?' . $auth;
                if ($method === 'POST') {
                    $body = $this->json($query);
                    if (strlen($body) === 2) {
                        $body = '{}';
                    }
                    $headers = array(
                        'Content-Type' => 'application/json',
                    );
                } else {
                    $headers = array(
                        'Content-Type' => 'application/x-www-form-urlencoded',
                    );
                }
            }
            $url = $this->implode_params($this->urls['api'][$type], array(
                'hostname' => $hostname,
            )) . $url;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return; // fallback to default error handler
        }
        if (is_array($response) && array_key_exists('status', $response)) {
            //
            //     array("status":"error","err-$code":"order-limitorder-amount-min-error","err-msg":"limit order amount error, min => `0.001`","data":null)
            //
            $status = $this->safe_string($response, 'status');
            if ($status === 'error') {
                $code = $this->safe_string_2($response, 'err-code', 'err_code');
                $feedback = $this->id . ' ' . $body;
                $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
                $message = $this->safe_string_2($response, 'err-msg', 'err_msg');
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
                throw new ExchangeError($feedback);
            }
        }
        if (is_array($response) && array_key_exists('code', $response)) {
            // array($code => '1003', $message => 'invalid signature')
            $feedback = $this->id . ' ' . $body;
            $code = $this->safe_string($response, 'code');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
        }
    }

    public function fetch_funding_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch the history of funding payments paid and received on this account
             * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-$query-account-financial-records-via-multiple-fields-new   // linear swaps
             * @see https://huobiapi.github.io/docs/dm/v1/en/#$query-financial-records-via-multiple-fields-new                          // coin-m futures
             * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#$query-financial-records-via-multiple-fields-new          // coin-m swaps
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch funding history for
             * @param {int|null} $limit the maximum number of funding history structures to retrieve
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=funding-history-structure funding history structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            list($marketType, $query) = $this->handle_market_type_and_params('fetchFundingHistory', $market, $params);
            $method = null;
            $request = array(
                'type' => '30,31',
            );
            if ($since !== null) {
                $request['start_date'] = $since;
            }
            if ($marketType === 'swap') {
                $request['contract'] = $market['id'];
                if ($market['linear']) {
                    $method = 'contractPrivatePostLinearSwapApiV3SwapFinancialRecordExact';
                    //
                    //    {
                    //        status => 'ok',
                    //        $data => array(
                    //           financial_record => array(
                    //               array(
                    //                   id => '1320088022',
                    //                   type => '30',
                    //                   amount => '0.004732510000000000',
                    //                   ts => '1641168019321',
                    //                   contract_code => 'BTC-USDT',
                    //                   asset => 'USDT',
                    //                   margin_account => 'BTC-USDT',
                    //                   face_margin_account => ''
                    //               ),
                    //           ),
                    //           remain_size => '0',
                    //           next_id => null
                    //        ),
                    //        ts => '1641189898425'
                    //    }
                    //
                    $marginMode = null;
                    list($marginMode, $params) = $this->handle_margin_mode_and_params('fetchFundingHistory', $params);
                    $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
                    if ($marginMode === 'isolated') {
                        $request['mar_acct'] = $market['id'];
                    } else {
                        $request['mar_acct'] = $market['quoteId'];
                    }
                } else {
                    $method = 'contractPrivatePostSwapApiV3SwapFinancialRecordExact';
                    //
                    //     {
                    //         "code" => 200,
                    //         "msg" => "",
                    //         "data" => array(
                    //             {
                    //                 "query_id" => 138798248,
                    //                 "id" => 117840,
                    //                 "type" => 5,
                    //                 "amount" => -0.024464850000000000,
                    //                 "ts" => 1638758435635,
                    //                 "contract_code" => "BTC-USDT-211210",
                    //                 "asset" => "USDT",
                    //                 "margin_account" => "USDT",
                    //                 "face_margin_account" => ""
                    //             }
                    //         ),
                    //         "ts" => 1604312615051
                    //     }
                    //
                }
            } else {
                $method = 'contractPrivatePostApiV3ContractFinancialRecordExact';
                $request['symbol'] = $market['id'];
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_incomes($data, $market, $since, $limit);
        }) ();
    }

    public function set_leverage($leverage, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($leverage, $symbol, $params) {
            /**
             * set the level of $leverage for a $market
             * @param {float} $leverage the rate of $leverage
             * @param {string} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} $response from the exchange
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            list($marketType, $query) = $this->handle_market_type_and_params('setLeverage', $market, $params);
            $method = null;
            if ($market['linear']) {
                $marginMode = null;
                list($marginMode, $params) = $this->handle_margin_mode_and_params('setLeverage', $params);
                $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
                $method = $this->get_supported_mapping($marginMode, array(
                    'isolated' => 'contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate',
                    'cross' => 'contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate',
                ));
                //
                //     {
                //       status => 'ok',
                //       data => array(
                //         contract_code => 'BTC-USDT',
                //         lever_rate => '100',
                //         margin_mode => 'isolated'
                //       ),
                //       ts => '1641184710649'
                //     }
                //
            } else {
                $method = $this->get_supported_mapping($marketType, array(
                    'future' => 'contractPrivatePostApiV1ContractSwitchLeverRate',
                    'swap' => 'contractPrivatePostSwapApiV1SwapSwitchLeverRate',
                ));
                //
                // future
                //     {
                //       status => 'ok',
                //       data => array( $symbol => 'BTC', lever_rate => 5 ),
                //       ts => 1641184578678
                //     }
                //
                // swap
                //
                //     {
                //       status => 'ok',
                //       data => array( contract_code => 'BTC-USD', lever_rate => '5' ),
                //       ts => '1641184652979'
                //     }
                //
            }
            $request = array(
                'lever_rate' => $leverage,
            );
            if ($marketType === 'future' && $market['inverse']) {
                $request['symbol'] = $market['settleId'];
            } else {
                $request['contract_code'] = $market['id'];
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            return $response;
        }) ();
    }

    public function parse_income($income, $market = null) {
        //
        //     {
        //       $id => '1667161118',
        //       $symbol => 'BTC',
        //       type => '31',
        //       $amount => '-2.11306593188E-7',
        //       ts => '1641139308983',
        //       contract_code => 'BTC-USD'
        //     }
        //
        $marketId = $this->safe_string($income, 'contract_code');
        $symbol = $this->safe_symbol($marketId, $market);
        $amount = $this->safe_number($income, 'amount');
        $timestamp = $this->safe_integer($income, 'ts');
        $id = $this->safe_string($income, 'id');
        $currencyId = $this->safe_string_2($income, 'symbol', 'asset');
        $code = $this->safe_currency_code($currencyId);
        return array(
            'info' => $income,
            'symbol' => $symbol,
            'code' => $code,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'id' => $id,
            'amount' => $amount,
        );
    }

    public function parse_position($position, $market = null) {
        //
        //     {
        //       $symbol => 'BTC',
        //       contract_code => 'BTC-USDT',
        //       volume => '1.000000000000000000',
        //       available => '1.000000000000000000',
        //       frozen => '0E-18',
        //       cost_open => '47162.000000000000000000',
        //       cost_hold => '47151.300000000000000000',
        //       profit_unreal => '0.007300000000000000',
        //       profit_rate => '-0.000144183876850008',
        //       lever_rate => '2',
        //       position_margin => '23.579300000000000000',
        //       direction => 'buy',
        //       profit => '-0.003400000000000000',
        //       last_price => '47158.6',
        //       margin_asset => 'USDT',
        //       margin_mode => 'isolated',
        //       margin_account => 'BTC-USDT',
        //       margin_balance => '24.973020070000000000',
        //       margin_position => '23.579300000000000000',
        //       margin_frozen => '0',
        //       margin_available => '1.393720070000000000',
        //       profit_real => '0E-18',
        //       risk_rate => '1.044107779705080303',
        //       withdraw_available => '1.386420070000000000000000000000000000',
        //       liquidation_price => '22353.229148614609571788',
        //       adjust_factor => '0.015000000000000000',
        //       margin_static => '24.965720070000000000'
        //     }
        //
        $market = $this->safe_market($this->safe_string($position, 'contract_code'));
        $symbol = $market['symbol'];
        $contracts = $this->safe_string($position, 'volume');
        $contractSize = $this->safe_value($market, 'contractSize');
        $contractSizeString = $this->number_to_string($contractSize);
        $entryPrice = $this->safe_number($position, 'cost_open');
        $initialMargin = $this->safe_string($position, 'position_margin');
        $rawSide = $this->safe_string($position, 'direction');
        $side = ($rawSide === 'buy') ? 'long' : 'short';
        $unrealizedProfit = $this->safe_number($position, 'profit_unreal');
        $marginMode = $this->safe_string($position, 'margin_mode');
        $leverage = $this->safe_string($position, 'lever_rate');
        $percentage = Precise::string_mul($this->safe_string($position, 'profit_rate'), '100');
        $lastPrice = $this->safe_string($position, 'last_price');
        $faceValue = Precise::string_mul($contracts, $contractSizeString);
        $notional = null;
        if ($market['linear']) {
            $notional = Precise::string_mul($faceValue, $lastPrice);
        } else {
            $notional = Precise::string_div($faceValue, $lastPrice);
            $marginMode = 'cross';
        }
        $intialMarginPercentage = Precise::string_div($initialMargin, $notional);
        $collateral = $this->safe_string($position, 'margin_balance');
        $liquidationPrice = $this->safe_number($position, 'liquidation_price');
        $adjustmentFactor = $this->safe_string($position, 'adjust_factor');
        $maintenanceMarginPercentage = Precise::string_div($adjustmentFactor, $leverage);
        $maintenanceMargin = Precise::string_mul($maintenanceMarginPercentage, $notional);
        $marginRatio = Precise::string_div($maintenanceMargin, $collateral);
        return $this->safe_position(array(
            'info' => $position,
            'id' => null,
            'symbol' => $symbol,
            'contracts' => $this->parse_number($contracts),
            'contractSize' => $contractSize,
            'entryPrice' => $entryPrice,
            'collateral' => $this->parse_number($collateral),
            'side' => $side,
            'unrealizedProfit' => $unrealizedProfit,
            'leverage' => $this->parse_number($leverage),
            'percentage' => $this->parse_number($percentage),
            'marginMode' => $marginMode,
            'notional' => $this->parse_number($notional),
            'markPrice' => null,
            'lastPrice' => null,
            'liquidationPrice' => $liquidationPrice,
            'initialMargin' => $this->parse_number($initialMargin),
            'initialMarginPercentage' => $this->parse_number($intialMarginPercentage),
            'maintenanceMargin' => $this->parse_number($maintenanceMargin),
            'maintenanceMarginPercentage' => $this->parse_number($maintenanceMarginPercentage),
            'marginRatio' => $this->parse_number($marginRatio),
            'timestamp' => null,
            'datetime' => null,
            'lastUpdateTimestamp' => null,
        ));
    }

    public function fetch_positions(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetch all open positions
             * @param {[string]|null} $symbols list of unified $market $symbols
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=$position-structure $position structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $market = null;
            if ($symbols !== null) {
                $first = $this->safe_string($symbols, 0);
                $market = $this->market($first);
            }
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('fetchPositions', $params);
            $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('fetchPositions', $market, $params, 'linear');
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('fetchPositions', $market, $params);
            if ($marketType === 'spot') {
                $marketType = 'future';
            }
            $method = null;
            if ($subType === 'linear') {
                $method = $this->get_supported_mapping($marginMode, array(
                    'isolated' => 'contractPrivatePostLinearSwapApiV1SwapPositionInfo',
                    'cross' => 'contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo',
                ));
                //
                //     {
                //       status => 'ok',
                //       $data => array(
                //         {
                //           symbol => 'BTC',
                //           contract_code => 'BTC-USDT',
                //           volume => '1.000000000000000000',
                //           available => '1.000000000000000000',
                //           frozen => '0E-18',
                //           cost_open => '47162.000000000000000000',
                //           cost_hold => '47162.000000000000000000',
                //           profit_unreal => '0.047300000000000000',
                //           profit_rate => '0.002005852169119206',
                //           lever_rate => '2',
                //           position_margin => '23.604650000000000000',
                //           direction => 'buy',
                //           profit => '0.047300000000000000',
                //           last_price => '47209.3',
                //           margin_asset => 'USDT',
                //           margin_mode => 'isolated',
                //           margin_account => 'BTC-USDT'
                //         }
                //       ),
                //       ts => '1641108676768'
                //     }
                //
            } else {
                $method = $this->get_supported_mapping($marketType, array(
                    'future' => 'contractPrivatePostApiV1ContractPositionInfo',
                    'swap' => 'contractPrivatePostSwapApiV1SwapPositionInfo',
                ));
                //
                // future
                //     {
                //       status => 'ok',
                //       $data => array(
                //         {
                //           symbol => 'BTC',
                //           contract_code => 'BTC220624',
                //           contract_type => 'next_quarter',
                //           volume => '1.000000000000000000',
                //           available => '1.000000000000000000',
                //           frozen => '0E-18',
                //           cost_open => '49018.880000000009853343',
                //           cost_hold => '49018.880000000009853343',
                //           profit_unreal => '-8.62360608500000000000000000000000000000000000000E-7',
                //           profit_rate => '-0.000845439023678622',
                //           lever_rate => '2',
                //           position_margin => '0.001019583964880634',
                //           direction => 'sell',
                //           profit => '-8.62360608500000000000000000000000000000000000000E-7',
                //           last_price => '49039.61'
                //         }
                //       ),
                //       ts => '1641109895199'
                //     }
                //
                // swap
                //     {
                //       status => 'ok',
                //       $data => array(
                //         {
                //           symbol => 'BTC',
                //           contract_code => 'BTC-USD',
                //           volume => '1.000000000000000000',
                //           available => '1.000000000000000000',
                //           frozen => '0E-18',
                //           cost_open => '47150.000000000012353300',
                //           cost_hold => '47150.000000000012353300',
                //           profit_unreal => '0E-54',
                //           profit_rate => '-7.86E-16',
                //           lever_rate => '3',
                //           position_margin => '0.000706963591375044',
                //           direction => 'buy',
                //           profit => '0E-54',
                //           last_price => '47150'
                //         }
                //       ),
                //       ts => '1641109636572'
                //     }
                //
            }
            $response = Async\await($this->$method ($params));
            $data = $this->safe_value($response, 'data', array());
            $timestamp = $this->safe_integer($response, 'ts');
            $result = array();
            for ($i = 0; $i < count($data); $i++) {
                $position = $data[$i];
                $parsed = $this->parse_position($position);
                $result[] = array_merge($parsed, array(
                    'timestamp' => $timestamp,
                    'datetime' => $this->iso8601($timestamp),
                ));
            }
            return $this->filter_by_array($result, 'symbol', $symbols, false);
        }) ();
    }

    public function fetch_position(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch $data on a single open contract trade $position
             * @param {string} $symbol unified $market $symbol of the $market the $position is held in, default is null
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$position-structure $position structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('fetchPosition', $params);
            $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
            list($marketType, $query) = $this->handle_market_type_and_params('fetchPosition', $market, $params);
            $method = null;
            if ($market['linear']) {
                $method = $this->get_supported_mapping($marginMode, array(
                    'isolated' => 'contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo',
                    'cross' => 'contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo',
                ));
                //
                // isolated
                //
                //     {
                //         "status" => "ok",
                //         "data" => array(
                //             array(
                //                 "positions" => array(),
                //                 "symbol" => "BTC",
                //                 "margin_balance" => 1.949728350000000000,
                //                 "margin_position" => 0,
                //                 "margin_frozen" => 0E-18,
                //                 "margin_available" => 1.949728350000000000,
                //                 "profit_real" => -0.050271650000000000,
                //                 "profit_unreal" => 0,
                //                 "risk_rate" => null,
                //                 "withdraw_available" => 1.949728350000000000,
                //                 "liquidation_price" => null,
                //                 "lever_rate" => 20,
                //                 "adjust_factor" => 0.150000000000000000,
                //                 "margin_static" => 1.949728350000000000,
                //                 "contract_code" => "BTC-USDT",
                //                 "margin_asset" => "USDT",
                //                 "margin_mode" => "isolated",
                //                 "margin_account" => "BTC-USDT",
                //                 "trade_partition" => "USDT",
                //                 "position_mode" => "dual_side"
                //             ),
                //             ... opposite side $position can be present here too (if hedge)
                //         ),
                //         "ts" => 1653605008286
                //     }
                //
                // cross
                //
                //     {
                //         "status" => "ok",
                //         "data" => array(
                //             "positions" => array(
                //                 array(
                //                     "symbol" => "BTC",
                //                     "contract_code" => "BTC-USDT",
                //                     "volume" => "1.000000000000000000",
                //                     "available" => "1.000000000000000000",
                //                     "frozen" => "0E-18",
                //                     "cost_open" => "29530.000000000000000000",
                //                     "cost_hold" => "29530.000000000000000000",
                //                     "profit_unreal" => "-0.010000000000000000",
                //                     "profit_rate" => "-0.016931933626820200",
                //                     "lever_rate" => "50",
                //                     "position_margin" => "0.590400000000000000",
                //                     "direction" => "buy",
                //                     "profit" => "-0.010000000000000000",
                //                     "last_price" => "29520",
                //                     "margin_asset" => "USDT",
                //                     "margin_mode" => "cross",
                //                     "margin_account" => "USDT",
                //                     "contract_type" => "swap",
                //                     "pair" => "BTC-USDT",
                //                     "business_type" => "swap",
                //                     "trade_partition" => "USDT",
                //                     "position_mode" => "dual_side"
                //                 ),
                //                 ... opposite side $position can be present here too (if hedge)
                //             ),
                //             "futures_contract_detail" => array(
                //                 array(
                //                     "symbol" => "BTC",
                //                     "contract_code" => "BTC-USDT-220624",
                //                     "margin_position" => "0",
                //                     "margin_frozen" => "0E-18",
                //                     "margin_available" => "1.497799766913531118",
                //                     "profit_unreal" => "0",
                //                     "liquidation_price" => null,
                //                     "lever_rate" => "30",
                //                     "adjust_factor" => "0.250000000000000000",
                //                     "contract_type" => "quarter",
                //                     "pair" => "BTC-USDT",
                //                     "business_type" => "futures",
                //                     "trade_partition" => "USDT"
                //                 ),
                //                 ... other items listed with different expiration (contract_code)
                //             ),
                //             "margin_mode" => "cross",
                //             "margin_account" => "USDT",
                //             "margin_asset" => "USDT",
                //             "margin_balance" => "2.088199766913531118",
                //             "margin_static" => "2.098199766913531118",
                //             "margin_position" => "0.590400000000000000",
                //             "margin_frozen" => "0E-18",
                //             "profit_real" => "-0.016972710000000000",
                //             "profit_unreal" => "-0.010000000000000000",
                //             "withdraw_available" => "1.497799766913531118",
                //             "risk_rate" => "9.105496355562965147",
                //             "contract_detail" => array(
                //                array(
                //                     "symbol" => "BTC",
                //                     "contract_code" => "BTC-USDT",
                //                     "margin_position" => "0.590400000000000000",
                //                     "margin_frozen" => "0E-18",
                //                     "margin_available" => "1.497799766913531118",
                //                     "profit_unreal" => "-0.010000000000000000",
                //                     "liquidation_price" => "27625.176468365024050352",
                //                     "lever_rate" => "50",
                //                     "adjust_factor" => "0.350000000000000000",
                //                     "contract_type" => "swap",
                //                     "pair" => "BTC-USDT",
                //                     "business_type" => "swap",
                //                     "trade_partition" => "USDT"
                //                 ),
                //                 ... all symbols listed
                //             ),
                //             "position_mode" => "dual_side"
                //         ),
                //         "ts" => "1653604697466"
                //     }
                //
            } else {
                $method = $this->get_supported_mapping($marketType, array(
                    'future' => 'contractPrivatePostApiV1ContractAccountPositionInfo',
                    'swap' => 'contractPrivatePostSwapApiV1SwapAccountPositionInfo',
                ));
                //
                // future, swap
                //
                //     {
                //       "status" => "ok",
                //       "data" => array(
                //         {
                //             "symbol" => "XRP",
                //             "contract_code" => "XRP-USD", // only present in swap
                //             "margin_balance" => 12.186361450698276582,
                //             "margin_position" => 5.036261079774375503,
                //             "margin_frozen" => 0E-18,
                //             "margin_available" => 7.150100370923901079,
                //             "profit_real" => -0.012672343876723438,
                //             "profit_unreal" => 0.163382354575000020,
                //             "risk_rate" => 2.344723929650649798,
                //             "withdraw_available" => 6.986718016348901059,
                //             "liquidation_price" => 0.271625200493799547,
                //             "lever_rate" => 5,
                //             "adjust_factor" => 0.075000000000000000,
                //             "margin_static" => 12.022979096123276562,
                //             "positions" => array(
                //                 array(
                //                     "symbol" => "XRP",
                //                     "contract_code" => "XRP-USD",
                //                     // "contract_type" => "this_week", // only present in future
                //                     "volume" => 1.0,
                //                     "available" => 1.0,
                //                     "frozen" => 0E-18,
                //                     "cost_open" => 0.394560000000000000,
                //                     "cost_hold" => 0.394560000000000000,
                //                     "profit_unreal" => 0.163382354575000020,
                //                     "profit_rate" => 0.032232070910556005,
                //                     "lever_rate" => 5,
                //                     "position_margin" => 5.036261079774375503,
                //                     "direction" => "buy",
                //                     "profit" => 0.163382354575000020,
                //                     "last_price" => 0.39712
                //                 ),
                //                 ... opposite side $position can be present here too (if hedge)
                //             )
                //         }
                //       ),
                //       "ts" => 1653600470199
                //     }
                //
                // cross usdt swap
                //
                //     {
                //         "status":"ok",
                //         "data":array(
                //             "positions":array(),
                //             "futures_contract_detail":array()
                //             "margin_mode":"cross",
                //             "margin_account":"USDT",
                //             "margin_asset":"USDT",
                //             "margin_balance":"1.000000000000000000",
                //             "margin_static":"1.000000000000000000",
                //             "margin_position":"0",
                //             "margin_frozen":"1.000000000000000000",
                //             "profit_real":"0E-18",
                //             "profit_unreal":"0",
                //             "withdraw_available":"0",
                //             "risk_rate":"15.666666666666666666",
                //             "contract_detail":array()
                //         ),
                //         "ts":"1645521118946"
                //     }
                //
            }
            $request = array();
            if ($market['future'] && $market['inverse']) {
                $request['symbol'] = $market['settleId'];
            } else {
                if ($marginMode === 'cross') {
                    $request['margin_account'] = 'USDT'; // only allowed value
                }
                $request['contract_code'] = $market['id'];
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            $data = $this->safe_value($response, 'data');
            $account = null;
            if ($marginMode === 'cross') {
                $account = $data;
            } else {
                $account = $this->safe_value($data, 0);
            }
            $omitted = $this->omit($account, array( 'positions' ));
            $positions = $this->safe_value($account, 'positions');
            $position = null;
            if ($market['future'] && $market['inverse']) {
                for ($i = 0; $i < count($positions); $i++) {
                    $entry = $positions[$i];
                    if ($entry['contract_code'] === $market['id']) {
                        $position = $entry;
                        break;
                    }
                }
            } else {
                $position = $this->safe_value($positions, 0);
            }
            $timestamp = $this->safe_integer($response, 'ts');
            $parsed = $this->parse_position(array_merge($position, $omitted));
            return array_merge($parsed, array(
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            ));
        }) ();
    }

    public function parse_ledger_entry_type($type) {
        $types = array(
            'trade' => 'trade',
            'etf' => 'trade',
            'transact-fee' => 'fee',
            'fee-deduction' => 'fee',
            'transfer' => 'transfer',
            'credit' => 'credit',
            'liquidation' => 'trade',
            'interest' => 'credit',
            'deposit' => 'deposit',
            'withdraw' => 'withdrawal',
            'withdraw-fee' => 'fee',
            'exchange' => 'exchange',
            'other-types' => 'transfer',
            'rebate' => 'rebate',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_ledger_entry($item, $currency = null) {
        //
        //     {
        //         "accountId" => 10000001,
        //         "currency" => "usdt",
        //         "transactAmt" => 10.000000000000000000,
        //         "transactType" => "transfer",
        //         "transferType" => "margin-transfer-out",
        //         "transactId" => 0,
        //         "transactTime" => 1629882331066,
        //         "transferer" => 28483123,
        //         "transferee" => 13496526
        //     }
        //
        $id = $this->safe_string($item, 'transactId');
        $currencyId = $this->safe_string($item, 'currency');
        $code = $this->safe_currency_code($currencyId, $currency);
        $amount = $this->safe_number($item, 'transactAmt');
        $transferType = $this->safe_string($item, 'transferType');
        $type = $this->parse_ledger_entry_type($transferType);
        $direction = $this->safe_string($item, 'direction');
        $timestamp = $this->safe_integer($item, 'transactTime');
        $datetime = $this->iso8601($timestamp);
        $account = $this->safe_string($item, 'accountId');
        return array(
            'id' => $id,
            'direction' => $direction,
            'account' => $account,
            'referenceId' => $id,
            'referenceAccount' => $account,
            'type' => $type,
            'currency' => $code,
            'amount' => $amount,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'before' => null,
            'after' => null,
            'status' => null,
            'fee' => null,
            'info' => $item,
        );
    }

    public function fetch_ledger(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch the history of changes, actions done by the user or operations that altered balance of the user
             * @param {string|null} $code unified $currency $code, default is null
             * @param {int|null} $since timestamp in ms of the earliest ledger entry, default is null
             * @param {int|null} $limit max number of ledger entrys to return, default is null
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ledger-structure ledger structure~
             */
            Async\await($this->load_markets());
            $accountId = Async\await($this->fetch_account_id_by_type('spot', $params));
            $request = array(
                'accountId' => $accountId,
                // 'currency' => $code,
                // 'transactTypes' => 'all', // default all
                // 'startTime' => 1546272000000,
                // 'endTime' => 1546272000000,
                // 'sort' => asc, // asc, desc
                // 'limit' => 100, // range 1-500
                // 'fromId' => 323 // first record ID in this query for pagination
            );
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['currency'] = $currency['id'];
            }
            if ($since !== null) {
                $request['startTime'] = $since;
            }
            if ($limit !== null) {
                $request['limit'] = $limit; // max 500
            }
            $response = Async\await($this->spotPrivateGetV2AccountLedger (array_merge($request, $params)));
            //
            //     {
            //         "code" => 200,
            //         "message" => "success",
            //         "data" => array(
            //             array(
            //                 "accountId" => 10000001,
            //                 "currency" => "usdt",
            //                 "transactAmt" => 10.000000000000000000,
            //                 "transactType" => "transfer",
            //                 "transferType" => "margin-transfer-out",
            //                 "transactId" => 0,
            //                 "transactTime" => 1629882331066,
            //                 "transferer" => 28483123,
            //                 "transferee" => 13496526
            //             ),
            //             {
            //                 "accountId" => 10000001,
            //                 "currency" => "usdt",
            //                 "transactAmt" => -10.000000000000000000,
            //                 "transactType" => "transfer",
            //                 "transferType" => "margin-transfer-in",
            //                 "transactId" => 0,
            //                 "transactTime" => 1629882096562,
            //                 "transferer" => 13496526,
            //                 "transferee" => 28483123
            //             }
            //         ),
            //         "nextId" => 1624316679,
            //         "ok" => true
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_ledger($data, $currency, $since, $limit);
        }) ();
    }

    public function fetch_leverage_tiers(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
             * @param {[string]|null} $symbols list of unified market $symbols
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=leverage-tiers-structure leverage tiers structures~, indexed by market $symbols
             */
            Async\await($this->load_markets());
            $response = Async\await($this->contractPublicGetLinearSwapApiV1SwapAdjustfactor ($params));
            //
            //    {
            //        "status" => "ok",
            //        "data" => array(
            //            {
            //                "symbol" => "MANA",
            //                "contract_code" => "MANA-USDT",
            //                "margin_mode" => "isolated",
            //                "trade_partition" => "USDT",
            //                "list" => array(
            //                    array(
            //                        "lever_rate" => 75,
            //                        "ladders" => array(
            //                            array(
            //                                "ladder" => 0,
            //                                "min_size" => 0,
            //                                "max_size" => 999,
            //                                "adjust_factor" => 0.7
            //                            ),
            //                            ...
            //                        )
            //                    }
            //                    ...
            //                )
            //            ),
            //            ...
            //        )
            //    }
            //
            $data = $this->safe_value($response, 'data');
            return $this->parse_leverage_tiers($data, $symbols, 'contract_code');
        }) ();
    }

    public function fetch_market_leverage_tiers(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single $market
             * @param {string} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=leverage-$tiers-structure leverage $tiers structure~
             */
            Async\await($this->load_markets());
            $request = array();
            if ($symbol !== null) {
                $market = $this->market($symbol);
                if (!$market['contract']) {
                    throw new BadRequest($this->id . ' fetchMarketLeverageTiers() $symbol supports contract markets only');
                }
                $request['contract_code'] = $market['id'];
            }
            $response = Async\await($this->contractPublicGetLinearSwapApiV1SwapAdjustfactor (array_merge($request, $params)));
            //
            //    {
            //        "status" => "ok",
            //        "data" => array(
            //            {
            //                "symbol" => "MANA",
            //                "contract_code" => "MANA-USDT",
            //                "margin_mode" => "isolated",
            //                "trade_partition" => "USDT",
            //                "list" => array(
            //                    array(
            //                        "lever_rate" => 75,
            //                        "ladders" => array(
            //                            array(
            //                                "ladder" => 0,
            //                                "min_size" => 0,
            //                                "max_size" => 999,
            //                                "adjust_factor" => 0.7
            //                            ),
            //                            ...
            //                        )
            //                    }
            //                    ...
            //                )
            //            ),
            //            ...
            //        )
            //    }
            //
            $data = $this->safe_value($response, 'data');
            $tiers = $this->parse_leverage_tiers($data, array( $symbol ), 'contract_code');
            return $this->safe_value($tiers, $symbol);
        }) ();
    }

    public function parse_leverage_tiers($response, ?array $symbols = null, $marketIdKey = null) {
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $item = $response[$i];
            $list = $this->safe_value($item, 'list', array());
            $tiers = array();
            $currency = $this->safe_string($item, 'trade_partition');
            $id = $this->safe_string($item, $marketIdKey);
            $symbol = $this->safe_symbol($id);
            if ($this->in_array($symbol, $symbols)) {
                for ($j = 0; $j < count($list); $j++) {
                    $obj = $list[$j];
                    $leverage = $this->safe_string($obj, 'lever_rate');
                    $ladders = $this->safe_value($obj, 'ladders', array());
                    for ($k = 0; $k < count($ladders); $k++) {
                        $bracket = $ladders[$k];
                        $adjustFactor = $this->safe_string($bracket, 'adjust_factor');
                        $tiers[] = array(
                            'tier' => $this->safe_integer($bracket, 'ladder'),
                            'currency' => $this->safe_currency_code($currency),
                            'minNotional' => $this->safe_number($bracket, 'min_size'),
                            'maxNotional' => $this->safe_number($bracket, 'max_size'),
                            'maintenanceMarginRate' => $this->parse_number(Precise::string_div($adjustFactor, $leverage)),
                            'maxLeverage' => $this->parse_number($leverage),
                            'info' => $bracket,
                        );
                    }
                }
                $result[$symbol] = $tiers;
            }
        }
        return $result;
    }

    public function fetch_open_interest_history(string $symbol, $timeframe = '1h', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * Retrieves the open interest history of a currency
             * @see https://huobiapi.github.io/docs/dm/v1/en/#query-information-on-open-interest
             * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-information-on-open-interest
             * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-information-on-open-interest
             * @param {string} $symbol Unified CCXT $market $symbol
             * @param {string} $timeframe '1h', '4h', '12h', or '1d'
             * @param {int|null} $since Not used by huobi api, but $response parsed by CCXT
             * @param {int|null} $limit Default：48，Data Range [1,200]
             * @param {array} $params Exchange specific parameters
             * @param {int} $params->amount_type *required* Open interest unit. 1-cont，2-cryptocurrency
             * @param {int|null} $params->pair eg BTC-USDT *Only for USDT-M*
             * @return {array} an array of ~@link https://docs.ccxt.com/#/?id=open-interest-structure open interest structures~
             */
            if ($timeframe !== '1h' && $timeframe !== '4h' && $timeframe !== '12h' && $timeframe !== '1d') {
                throw new BadRequest($this->id . ' fetchOpenInterestHistory cannot only use the 1h, 4h, 12h and 1d timeframe');
            }
            Async\await($this->load_markets());
            $timeframes = array(
                '1h' => '60min',
                '4h' => '4hour',
                '12h' => '12hour',
                '1d' => '1day',
            );
            $market = $this->market($symbol);
            $amountType = $this->safe_number_2($params, 'amount_type', 'amountType');
            if ($amountType === null) {
                throw new ArgumentsRequired($this->id . ' fetchOpenInterestHistory requires parameter $params->amountType to be either 1 (cont), or 2 (cryptocurrency)');
            }
            $request = array(
                'period' => $timeframes[$timeframe],
                'amount_type' => $amountType,
            );
            $method = null;
            if ($market['future']) {
                $request['contract_type'] = $this->safe_string($market['info'], 'contract_type');
                $request['symbol'] = $market['baseId'];  // currency code on coin-m futures
                $method = 'contractPublicGetApiV1ContractHisOpenInterest'; // coin-m futures
            } elseif ($market['linear']) {
                $request['contract_type'] = 'swap';
                $request['contract_code'] = $market['id'];
                $request['contract_code'] = $market['id'];
                $method = 'contractPublicGetLinearSwapApiV1SwapHisOpenInterest'; // USDT-M
            } else {
                $request['contract_code'] = $market['id'];
                $method = 'contractPublicGetSwapApiV1SwapHisOpenInterest'; // coin-m swaps
            }
            if ($limit !== null) {
                $request['size'] = $limit;
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            //  contractPublicGetlinearSwapApiV1SwapHisOpenInterest
            //    {
            //        status => 'ok',
            //        $data => array(
            //            $symbol => 'BTC',
            //            $tick => array(
            //                array(
            //                    volume => '4385.4350000000000000',
            //                    amount_type => '2',
            //                    ts => '1648220400000',
            //                    value => '194059884.1850000000000000'
            //                ),
            //                ...
            //            ),
            //            contract_code => 'BTC-USDT',
            //            business_type => 'swap',
            //            pair => 'BTC-USDT',
            //            contract_type => 'swap',
            //            trade_partition => 'USDT'
            //        ),
            //        ts => '1648223733007'
            //    }
            //
            //  contractPublicGetSwapApiV1SwapHisOpenInterest
            //    {
            //        "status" => "ok",
            //        "data" => array(
            //            "symbol" => "CRV",
            //            "tick" => array(
            //                array(
            //                    "volume" => 19174.0000000000000000,
            //                    "amount_type" => 1,
            //                    "ts" => 1648224000000
            //                ),
            //                ...
            //            ),
            //            "contract_code" => "CRV-USD"
            //        ),
            //        "ts" => 1648226554260
            //    }
            //
            //  contractPublicGetApiV1ContractHisOpenInterest
            //    {
            //         "status" => "ok",
            //         "data" => array(
            //             "symbol" => "BTC",
            //             "contract_type" => "this_week",
            //             "tick" => array(
            //                array(
            //                     "volume" => "48419.0000000000000000",
            //                     "amount_type" => 1,
            //                     "ts" => 1648224000000
            //                ),
            //                ...
            //            )
            //        ),
            //        "ts" => 1648227062944
            //    }
            //
            $data = $this->safe_value($response, 'data');
            $tick = $this->safe_value($data, 'tick');
            return $this->parse_open_interests($tick, $market, $since, $limit);
        }) ();
    }

    public function fetch_open_interest(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * Retrieves the open interest of a currency
             * @see https://huobiapi.github.io/docs/dm/v1/en/#get-contract-open-interest-information
             * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-swap-open-interest-information
             * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-swap-open-interest-information
             * @param {string} $symbol Unified CCXT $market $symbol
             * @param {array} $params exchange specific parameters
             * @return {array} an open interest structurearray(@link https://docs.ccxt.com/#/?id=interest-history-structure)
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['contract']) {
                throw new BadRequest($this->id . ' fetchOpenInterest() supports contract markets only');
            }
            if ($market['option']) {
                throw new NotSupported($this->id . ' fetchOpenInterest() does not currently support option markets');
            }
            $request = array(
                'contract_code' => $market['id'],
            );
            $method = null;
            if ($market['future']) {
                $request['contract_type'] = $this->safe_string($market['info'], 'contract_type');
                $request['symbol'] = $market['baseId'];
                $method = 'contractPublicGetApiV1ContractOpenInterest'; // COIN-M futures
            } elseif ($market['linear']) {
                $request['contract_type'] = 'swap';
                $method = 'contractPublicGetLinearSwapApiV1SwapOpenInterest'; // USDT-M
            } else {
                $method = 'contractPublicGetSwapApiV1SwapOpenInterest'; // COIN-M swaps
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // USDT-M contractPublicGetLinearSwapApiV1SwapOpenInterest
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             {
            //                 "volume" => 7192610.000000000000000000,
            //                 "amount" => 7192.610000000000000000,
            //                 "symbol" => "BTC",
            //                 "value" => 134654290.332000000000000000,
            //                 "contract_code" => "BTC-USDT",
            //                 "trade_amount" => 70692.804,
            //                 "trade_volume" => 70692804,
            //                 "trade_turnover" => 1379302592.9518,
            //                 "business_type" => "swap",
            //                 "pair" => "BTC-USDT",
            //                 "contract_type" => "swap",
            //                 "trade_partition" => "USDT"
            //             }
            //         ),
            //         "ts" => 1664336503144
            //     }
            //
            // COIN-M Swap contractPublicGetSwapApiV1SwapOpenInterest
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             {
            //                 "volume" => 518018.000000000000000000,
            //                 "amount" => 2769.675777407074725180,
            //                 "symbol" => "BTC",
            //                 "contract_code" => "BTC-USD",
            //                 "trade_amount" => 9544.4032080046491323463688602729806842458,
            //                 "trade_volume" => 1848448,
            //                 "trade_turnover" => 184844800.000000000000000000
            //             }
            //         ),
            //         "ts" => 1664337226028
            //     }
            //
            // COIN-M Futures contractPublicGetApiV1ContractOpenInterest
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             {
            //                 "volume" => 118850.000000000000000000,
            //                 "amount" => 635.502025211544374189,
            //                 "symbol" => "BTC",
            //                 "contract_type" => "this_week",
            //                 "contract_code" => "BTC220930",
            //                 "trade_amount" => 1470.9400749347598691119206024033947897351,
            //                 "trade_volume" => 286286,
            //                 "trade_turnover" => 28628600.000000000000000000
            //             }
            //         ),
            //         "ts" => 1664337928805
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $openInterest = $this->parse_open_interest($data[0], $market);
            $timestamp = $this->safe_integer($response, 'ts');
            return array_merge($openInterest, array(
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            ));
        }) ();
    }

    public function parse_open_interest($interest, $market = null) {
        //
        // fetchOpenInterestHistory
        //
        //    {
        //        volume => '4385.4350000000000000',
        //        amount_type => '2',
        //        ts => '1648220400000',
        //        $value => '194059884.1850000000000000'
        //    }
        //
        // fetchOpenInterest => USDT-M
        //
        //     {
        //         "volume" => 7192610.000000000000000000,
        //         "amount" => 7192.610000000000000000,
        //         "symbol" => "BTC",
        //         "value" => 134654290.332000000000000000,
        //         "contract_code" => "BTC-USDT",
        //         "trade_amount" => 70692.804,
        //         "trade_volume" => 70692804,
        //         "trade_turnover" => 1379302592.9518,
        //         "business_type" => "swap",
        //         "pair" => "BTC-USDT",
        //         "contract_type" => "swap",
        //         "trade_partition" => "USDT"
        //     }
        //
        // fetchOpenInterest => COIN-M Swap
        //
        //     {
        //         "volume" => 518018.000000000000000000,
        //         "amount" => 2769.675777407074725180,
        //         "symbol" => "BTC",
        //         "contract_code" => "BTC-USD",
        //         "trade_amount" => 9544.4032080046491323463688602729806842458,
        //         "trade_volume" => 1848448,
        //         "trade_turnover" => 184844800.000000000000000000
        //     }
        //
        // fetchOpenInterest => COIN-M Futures
        //
        //     {
        //         "volume" => 118850.000000000000000000,
        //         "amount" => 635.502025211544374189,
        //         "symbol" => "BTC",
        //         "contract_type" => "this_week",
        //         "contract_code" => "BTC220930",
        //         "trade_amount" => 1470.9400749347598691119206024033947897351,
        //         "trade_volume" => 286286,
        //         "trade_turnover" => 28628600.000000000000000000
        //     }
        //
        $timestamp = $this->safe_integer($interest, 'ts');
        $amount = $this->safe_number($interest, 'volume');
        $value = $this->safe_number($interest, 'value');
        return array(
            'symbol' => $this->safe_string($market, 'symbol'),
            'baseVolume' => $amount,  // deprecated
            'quoteVolume' => $value,  // deprecated
            'openInterestAmount' => $amount,
            'openInterestValue' => $value,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $interest,
        );
    }

    public function borrow_margin(string $code, $amount, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $symbol, $params) {
            /**
             * create a loan to borrow margin
             * @see https://huobiapi.github.io/docs/spot/v1/en/#$request-a-margin-loan-isolated
             * @see https://huobiapi.github.io/docs/spot/v1/en/#$request-a-margin-loan-cross
             * @param {string} $code unified $currency $code of the $currency to borrow
             * @param {float} $amount the $amount to borrow
             * @param {string|null} $symbol unified $market $symbol, required for isolated margin
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=margin-loan-structure margin loan structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
                'amount' => $this->currency_to_precision($code, $amount),
            );
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('borrowMargin', $params);
            $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
            $method = null;
            if ($marginMode === 'isolated') {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' borrowMargin() requires a $symbol argument for isolated margin');
                }
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
                $method = 'privatePostMarginOrders';
            } elseif ($marginMode === 'cross') {
                $method = 'privatePostCrossMarginOrders';
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // Cross
            //
            //     {
            //         "status" => "ok",
            //         "data" => null
            //     }
            //
            // Isolated
            //
            //     {
            //         "data" => 1000
            //     }
            //
            $transaction = $this->parse_margin_loan($response, $currency);
            return array_merge($transaction, array(
                'amount' => $amount,
                'symbol' => $symbol,
            ));
        }) ();
    }

    public function repay_margin(string $code, $amount, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $symbol, $params) {
            /**
             * repay borrowed margin and interest
             * @see https://huobiapi.github.io/docs/spot/v1/en/#repay-margin-$loan-cross-isolated
             * @param {string} $code unified $currency $code of the $currency to repay
             * @param {float} $amount the $amount to repay
             * @param {string|null} $symbol unified market $symbol
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=margin-$loan-structure margin $loan structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('repayMargin', $params);
            $marginMode = ($marginMode === null) ? 'cross' : $marginMode;
            $marginAccounts = $this->safe_value($this->options, 'marginAccounts', array());
            $accountType = $this->get_supported_mapping($marginMode, $marginAccounts);
            $accountId = Async\await($this->fetch_account_id_by_type($accountType, $params));
            $request = array(
                'currency' => $currency['id'],
                'amount' => $this->currency_to_precision($code, $amount),
                'accountId' => $accountId,
            );
            $response = Async\await($this->v2PrivatePostAccountRepayment (array_merge($request, $params)));
            //
            //     {
            //         "code":200,
            //         "data" => array(
            //             {
            //                 "repayId":1174424,
            //                 "repayTime":1600747722018
            //             }
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'Data', array());
            $loan = $this->safe_value($data, 0);
            $transaction = $this->parse_margin_loan($loan, $currency);
            return array_merge($transaction, array(
                'amount' => $amount,
                'symbol' => $symbol,
            ));
        }) ();
    }

    public function parse_margin_loan($info, $currency = null) {
        //
        // borrowMargin cross
        //
        //     {
        //         "status" => "ok",
        //         "data" => null
        //     }
        //
        // borrowMargin isolated
        //
        //     {
        //         "data" => 1000
        //     }
        //
        // repayMargin
        //
        //     {
        //         "repayId":1174424,
        //         "repayTime":1600747722018
        //     }
        //
        $timestamp = $this->safe_integer($info, 'repayTime');
        return array(
            'id' => $this->safe_integer_2($info, 'repayId', 'data'),
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'symbol' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $info,
        );
    }

    public function fetch_settlement_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * Fetches historical settlement records
             * @param {string} $symbol unified $symbol of the $market to fetch the settlement history for
             * @param {int} $since timestamp in ms, value range = current time - 90 days，default = current time - 90 days
             * @param {int} $limit page items, default 20, shall not exceed 50
             * @param {array} $params exchange specific $params
             * @param {int} $params->until timestamp in ms, value range = start_time -> current time，default = current time
             * @param {int} $params->page_index page index, default page 1 if not filled
             * @param {int} $params->code unified currency $code, can be used when $symbol is null
             * @return A list of settlement history objects
             */
            $code = $this->safe_string($params, 'code');
            $until = $this->safe_integer_2($params, 'until', 'till');
            $params = $this->omit($params, array( 'until', 'till' ));
            $market = ($symbol === null) ? null : $this->market($symbol);
            list($type, $query) = $this->handle_market_type_and_params('fetchSettlementHistory', $market, $params);
            if ($type === 'future') {
                if ($symbol === null && $code === null) {
                    throw new ArgumentsRequired($this->id . ' requires a $symbol argument or $params["code"] for fetchSettlementHistory future');
                }
            } elseif ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' requires a $symbol argument for fetchSettlementHistory swap');
            }
            $request = array();
            if ($market['future']) {
                $request['symbol'] = $market['baseId'];
            } else {
                $request['contract_code'] = $market['id'];
            }
            if ($since !== null) {
                $request['start_at'] = $since;
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            if ($until !== null) {
                $request['end_at'] = $until;
            }
            $method = 'contractPublicGetApiV1ContractSettlementRecords';
            if ($market['swap']) {
                if ($market['linear']) {
                    $method = 'contractPublicGetLinearSwapApiV1SwapSettlementRecords';
                } else {
                    $method = 'contractPublicGetSwapApiV1SwapSettlementRecords';
                }
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            //
            // linear swap, coin-m swap
            //
            //    {
            //        "status" => "ok",
            //        "data" => {
            //        "total_page" => 14,
            //        "current_page" => 1,
            //        "total_size" => 270,
            //        "settlement_record" => array(
            //            array(
            //                "symbol" => "ADA",
            //                "contract_code" => "ADA-USDT",
            //                "settlement_time" => 1652313600000,
            //                "clawback_ratio" => 0E-18,
            //                "settlement_price" => 0.512303000000000000,
            //                "settlement_type" => "settlement",
            //                "business_type" => "swap",
            //                "pair" => "ADA-USDT",
            //                "trade_partition" => "USDT"
            //            ),
            //            ...
            //        ),
            //        "ts" => 1652338693256
            //    }
            //
            // coin-m future
            //
            //    {
            //        "status" => "ok",
            //        "data" => {
            //            "total_page" => 5,
            //            "current_page" => 1,
            //            "total_size" => 90,
            //            "settlement_record" => array(
            //                array(
            //                    "symbol" => "FIL",
            //                    "settlement_time" => 1652342400000,
            //                    "clawback_ratio" => 0E-18,
            //                    "list" => array(
            //                        array(
            //                            "contract_code" => "FIL220513",
            //                            "settlement_price" => 7.016000000000000000,
            //                            "settlement_type" => "settlement"
            //                        ),
            //                        ...
            //                    )
            //                ),
            //            )
            //        }
            //    }
            //
            $data = $this->safe_value($response, 'data');
            $settlementRecord = $this->safe_value($data, 'settlement_record');
            $settlements = $this->parse_settlements($settlementRecord, $market);
            return $this->sort_by($settlements, 'timestamp');
        }) ();
    }

    public function fetch_deposit_withdraw_fees($codes = null, $params = array ()) {
        return Async\async(function () use ($codes, $params) {
            /**
             * fetch deposit and withdraw fees
             * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-supported-currencies-v2
             * @param {[string]|null} $codes list of unified currency $codes
             * @param {array} $params extra parameters specific to the huobi api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=fee-structure fees structures~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->spotPublicGetV2ReferenceCurrencies ($params));
            //
            //    {
            //        "code" => 200,
            //        "data" => array(
            //            {
            //                "currency" => "sxp",
            //                "assetType" => "1",
            //                "chains" => array(
            //                    {
            //                        "chain" => "sxp",
            //                        "displayName" => "ERC20",
            //                        "baseChain" => "ETH",
            //                        "baseChainProtocol" => "ERC20",
            //                        "isDynamic" => true,
            //                        "numOfConfirmations" => "12",
            //                        "numOfFastConfirmations" => "12",
            //                        "depositStatus" => "allowed",
            //                        "minDepositAmt" => "0.23",
            //                        "withdrawStatus" => "allowed",
            //                        "minWithdrawAmt" => "0.23",
            //                        "withdrawPrecision" => "8",
            //                        "maxWithdrawAmt" => "227000.000000000000000000",
            //                        "withdrawQuotaPerDay" => "227000.000000000000000000",
            //                        "withdrawQuotaPerYear" => null,
            //                        "withdrawQuotaTotal" => null,
            //                        "withdrawFeeType" => "fixed",
            //                        "transactFeeWithdraw" => "11.1653",
            //                        "addrWithTag" => false,
            //                        "addrDepositTag" => false
            //                    }
            //                ),
            //                "instStatus" => "normal"
            //            }
            //        )
            //    }
            //
            $data = $this->safe_value($response, 'data');
            return $this->parse_deposit_withdraw_fees($data, $codes, 'currency');
        }) ();
    }

    public function parse_deposit_withdraw_fee($fee, $currency = null) {
        //
        //            {
        //              "currency" => "sxp",
        //              "assetType" => "1",
        //              "chains" => array(
        //                  {
        //                      "chain" => "sxp",
        //                      "displayName" => "ERC20",
        //                      "baseChain" => "ETH",
        //                      "baseChainProtocol" => "ERC20",
        //                      "isDynamic" => true,
        //                      "numOfConfirmations" => "12",
        //                      "numOfFastConfirmations" => "12",
        //                      "depositStatus" => "allowed",
        //                      "minDepositAmt" => "0.23",
        //                      "withdrawStatus" => "allowed",
        //                      "minWithdrawAmt" => "0.23",
        //                      "withdrawPrecision" => "8",
        //                      "maxWithdrawAmt" => "227000.000000000000000000",
        //                      "withdrawQuotaPerDay" => "227000.000000000000000000",
        //                      "withdrawQuotaPerYear" => null,
        //                      "withdrawQuotaTotal" => null,
        //                      "withdrawFeeType" => "fixed",
        //                      "transactFeeWithdraw" => "11.1653",
        //                      "addrWithTag" => false,
        //                      "addrDepositTag" => false
        //                  }
        //              ),
        //              "instStatus" => "normal"
        //          }
        //
        $chains = $this->safe_value($fee, 'chains', array());
        $result = $this->deposit_withdraw_fee($fee);
        for ($j = 0; $j < count($chains); $j++) {
            $chainEntry = $chains[$j];
            $networkId = $this->safe_string($chainEntry, 'chain');
            $withdrawFeeType = $this->safe_string($chainEntry, 'withdrawFeeType');
            $networkCode = $this->network_id_to_code($networkId);
            $withdrawFee = null;
            $withdrawResult = null;
            if ($withdrawFeeType === 'fixed') {
                $withdrawFee = $this->safe_number($chainEntry, 'transactFeeWithdraw');
                $withdrawResult = array(
                    'fee' => $withdrawFee,
                    'percentage' => false,
                );
            } else {
                $withdrawFee = $this->safe_number($chainEntry, 'transactFeeRateWithdraw');
                $withdrawResult = array(
                    'fee' => $withdrawFee,
                    'percentage' => true,
                );
            }
            $result['networks'][$networkCode] = array(
                'withdraw' => $withdrawResult,
                'deposit' => array(
                    'fee' => null,
                    'percentage' => null,
                ),
            );
            $result = $this->assign_default_deposit_withdraw_fees($result, $currency);
        }
        return $result;
    }

    public function parse_settlements($settlements, $market) {
        //
        // linear swap, coin-m swap, fetchSettlementHistory
        //
        //    array(
        //        array(
        //            "symbol" => "ADA",
        //            "contract_code" => "ADA-USDT",
        //            "settlement_time" => 1652313600000,
        //            "clawback_ratio" => 0E-18,
        //            "settlement_price" => 0.512303000000000000,
        //            "settlement_type" => "settlement",
        //            "business_type" => "swap",
        //            "pair" => "ADA-USDT",
        //            "trade_partition" => "USDT"
        //        ),
        //        ...
        //    )
        //
        // coin-m future, fetchSettlementHistory
        //
        //    array(
        //        array(
        //            "symbol" => "FIL",
        //            "settlement_time" => 1652342400000,
        //            "clawback_ratio" => 0E-18,
        //            "list" => array(
        //                array(
        //                    "contract_code" => "FIL220513",
        //                    "settlement_price" => 7.016000000000000000,
        //                    "settlement_type" => "settlement"
        //                ),
        //                ...
        //            )
        //        ),
        //    )
        //
        $result = array();
        for ($i = 0; $i < count($settlements); $i++) {
            $settlement = $settlements[$i];
            $list = $this->safe_value($settlement, 'list');
            if ($list !== null) {
                $timestamp = $this->safe_integer($settlement, 'settlement_time');
                $timestampDetails = array(
                    'timestamp' => $timestamp,
                    'datetime' => $this->iso8601($timestamp),
                );
                for ($j = 0; $j < count($list); $j++) {
                    $item = $list[$j];
                    $parsedSettlement = $this->parse_settlement($item, $market);
                    $result[] = array_merge($parsedSettlement, $timestampDetails);
                }
            } else {
                $result[] = $this->parse_settlement($settlements[$i], $market);
            }
        }
        return $result;
    }

    public function parse_settlement($settlement, $market) {
        //
        // linear swap, coin-m swap, fetchSettlementHistory
        //
        //    {
        //        "symbol" => "ADA",
        //        "contract_code" => "ADA-USDT",
        //        "settlement_time" => 1652313600000,
        //        "clawback_ratio" => 0E-18,
        //        "settlement_price" => 0.512303000000000000,
        //        "settlement_type" => "settlement",
        //        "business_type" => "swap",
        //        "pair" => "ADA-USDT",
        //        "trade_partition" => "USDT"
        //    }
        //
        // coin-m future, fetchSettlementHistory
        //
        //    {
        //        "contract_code" => "FIL220513",
        //        "settlement_price" => 7.016000000000000000,
        //        "settlement_type" => "settlement"
        //    }
        //
        $timestamp = $this->safe_integer($settlement, 'settlement_time');
        $marketId = $this->safe_string($settlement, 'contract_code');
        return array(
            'info' => $settlement,
            'symbol' => $this->safe_symbol($marketId, $market),
            'price' => $this->safe_number($settlement, 'settlement_price'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
    }
}
